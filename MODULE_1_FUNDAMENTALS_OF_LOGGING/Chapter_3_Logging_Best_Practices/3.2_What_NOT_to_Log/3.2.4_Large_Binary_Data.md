# 3.2.4 Large Binary Data

## Overview

Logging large binary data can severely impact application performance, consume excessive storage space, and provide little value for debugging or monitoring. Binary data such as images, videos, documents, and file uploads should never be logged directly. This section provides comprehensive strategies for handling binary data in logging contexts while maintaining useful diagnostic information.

## Understanding Binary Data Challenges

### Performance Impact
- **Memory Consumption**: Binary data can consume massive amounts of memory
- **Serialization Overhead**: Converting binary to text (Base64) increases size by ~33%
- **Network Latency**: Large log entries slow down log transmission
- **Processing Delays**: Log parsing and indexing becomes computationally expensive
- **Storage Costs**: Exponential increase in storage requirements

### Types of Binary Data
- **Image Files**: JPEG, PNG, GIF, SVG, WebP formats
- **Document Files**: PDF, Word, Excel, PowerPoint documents
- **Media Files**: Audio (MP3, WAV), Video (MP4, AVI, MOV)
- **Archive Files**: ZIP, RAR, TAR, 7Z compressed files
- **Application Data**: Serialized objects, protocol buffers, encrypted data
- **Database BLOBs**: Binary large objects from databases

### Common Scenarios
- **File Upload Processing**: User-uploaded content handling
- **API Data Transfer**: Binary data in API requests/responses
- **Microservices Communication**: Binary data exchange between services
- **Caching Operations**: Binary data storage and retrieval
- **Database Operations**: BLOB field processing

## Binary Data Detection and Handling

### Advanced Binary Data Detector

```javascript
const crypto = require('crypto');
const winston = require('winston');
const path = require('path');

/**
 * Intelligent Binary Data Detection and Optimization System
 * Provides comprehensive detection, analysis, and efficient logging for binary content
 */
class BinaryDataHandler {
    constructor(options = {}) {
        this.config = {
            // Size thresholds (in bytes)
            warningThreshold: options.warningThreshold || 1024, // 1KB
            criticalThreshold: options.criticalThreshold || 10240, // 10KB
            maximumLogSize: options.maximumLogSize || 102400, // 100KB
            
            // Detection settings
            enableMimeDetection: options.enableMimeDetection || true,
            enableMetadataExtraction: options.enableMetadataExtraction || true,
            enableContentAnalysis: options.enableContentAnalysis || true,
            
            // Optimization strategies
            compressionEnabled: options.compressionEnabled || true,
            hashingEnabled: options.hashingEnabled || true,
            thumbnailGeneration: options.thumbnailGeneration || false,
            
            // Storage optimization
            enableCaching: options.enableCaching || true,
            cacheMaxSize: options.cacheMaxSize || 100,
            
            // Monitoring
            performanceTracking: options.performanceTracking || true,
            alertOnLargeData: options.alertOnLargeData || true
        };
        
        this.binaryPatterns = this._buildBinaryPatterns();
        this.metadataCache = new Map();
        this.performanceMetrics = this._initializeMetrics();
        this.contentAnalyzer = new ContentAnalyzer();
        this.compressionEngine = new CompressionEngine();
    }
    
    /**
     * Build comprehensive binary data detection patterns
     */
    _buildBinaryPatterns() {
        return {
            // Image formats
            jpeg: {
                signatures: [
                    [0xFF, 0xD8, 0xFF], // JPEG
                    [0xFF, 0xD8, 0xFF, 0xE0], // JPEG/JFIF
                    [0xFF, 0xD8, 0xFF, 0xE1] // JPEG/EXIF
                ],
                mimeType: 'image/jpeg',
                extensions: ['.jpg', '.jpeg'],
                category: 'image',
                typical_size: 'medium'
            },
            png: {
                signatures: [[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]],
                mimeType: 'image/png',
                extensions: ['.png'],
                category: 'image',
                typical_size: 'medium'
            },
            gif: {
                signatures: [
                    [0x47, 0x49, 0x46, 0x38, 0x37, 0x61], // GIF87a
                    [0x47, 0x49, 0x46, 0x38, 0x39, 0x61]  // GIF89a
                ],
                mimeType: 'image/gif',
                extensions: ['.gif'],
                category: 'image',
                typical_size: 'small'
            },
            
            // Document formats
            pdf: {
                signatures: [[0x25, 0x50, 0x44, 0x46]], // %PDF
                mimeType: 'application/pdf',
                extensions: ['.pdf'],
                category: 'document',
                typical_size: 'large'
            },
            docx: {
                signatures: [[0x50, 0x4B, 0x03, 0x04]], // ZIP signature (DOCX is ZIP-based)
                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                extensions: ['.docx'],
                category: 'document',
                typical_size: 'medium'
            },
            
            // Media formats
            mp4: {
                signatures: [
                    [0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70], // MP4
                    [0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70]  // MP4
                ],
                mimeType: 'video/mp4',
                extensions: ['.mp4'],
                category: 'video',
                typical_size: 'very_large'
            },
            mp3: {
                signatures: [
                    [0xFF, 0xFB], // MP3
                    [0x49, 0x44, 0x33] // ID3 tag
                ],
                mimeType: 'audio/mpeg',
                extensions: ['.mp3'],
                category: 'audio',
                typical_size: 'large'
            },
            
            // Archive formats
            zip: {
                signatures: [
                    [0x50, 0x4B, 0x03, 0x04], // ZIP
                    [0x50, 0x4B, 0x05, 0x06], // Empty ZIP
                    [0x50, 0x4B, 0x07, 0x08]  // ZIP with data descriptor
                ],
                mimeType: 'application/zip',
                extensions: ['.zip'],
                category: 'archive',
                typical_size: 'variable'
            },
            
            // Executable formats
            exe: {
                signatures: [[0x4D, 0x5A]], // MZ header
                mimeType: 'application/octet-stream',
                extensions: ['.exe', '.dll'],
                category: 'executable',
                typical_size: 'large'
            },
            
            // Database formats
            sqlite: {
                signatures: [[0x53, 0x51, 0x4C, 0x69, 0x74, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x33, 0x00]],
                mimeType: 'application/x-sqlite3',
                extensions: ['.db', '.sqlite', '.sqlite3'],
                category: 'database',
                typical_size: 'large'
            }
        };
    }
    
    /**
     * Main binary data processing method
     */
    async processBinaryData(data, context = {}) {
        const startTime = Date.now();
        const processingSession = this._createProcessingSession(context);
        
        try {
            // Detect binary data
            const detection = await this._detectBinaryData(data, processingSession);
            
            if (!detection.isBinary) {
                this._recordNonBinaryProcessing(processingSession, Date.now() - startTime);
                return data; // Return original data if not binary
            }
            
            // Analyze binary content
            const analysis = await this._analyzeBinaryContent(data, detection, processingSession);
            
            // Apply optimization strategy
            const optimizedLog = await this._optimizeForLogging(data, analysis, processingSession);
            
            // Update performance metrics
            this._recordBinaryProcessing(processingSession, Date.now() - startTime, analysis);
            
            return optimizedLog;
            
        } catch (error) {
            this._handleProcessingError(error, processingSession);
            return this._createErrorPlaceholder(data, error);
        }
    }
    
    /**
     * Detect if data contains binary content
     */
    async _detectBinaryData(data, session) {
        const detection = {
            isBinary: false,
            confidence: 0,
            dataType: 'unknown',
            size: 0,
            format: null,
            mimeType: null
        };
        
        // Handle different input types
        let buffer;
        if (Buffer.isBuffer(data)) {
            buffer = data;
        } else if (typeof data === 'string') {
            // Check if it's base64 encoded binary
            if (this._isBase64(data)) {
                buffer = Buffer.from(data, 'base64');
                detection.encoding = 'base64';
            } else {
                // Check for binary characters in string
                if (this._hasBinaryCharacters(data)) {
                    buffer = Buffer.from(data, 'utf8');
                } else {
                    return detection; // Not binary
                }
            }
        } else if (typeof data === 'object') {
            // Check if object contains binary data
            const binaryFields = this._findBinaryFields(data);
            if (binaryFields.length > 0) {
                detection.isBinary = true;
                detection.binaryFields = binaryFields;
                detection.dataType = 'object_with_binary';
                return detection;
            }
            return detection; // Not binary
        } else {
            return detection; // Unknown type, assume not binary
        }
        
        detection.size = buffer.length;
        
        // File signature detection
        const format = this._detectFileFormat(buffer);
        if (format) {
            detection.isBinary = true;
            detection.confidence = 0.95;
            detection.format = format;
            detection.dataType = format.category;
            detection.mimeType = format.mimeType;
        } else {
            // Fallback: statistical analysis
            const stats = this._analyzeByteDistribution(buffer);
            detection.isBinary = stats.binaryProbability > 0.5;
            detection.confidence = stats.binaryProbability;
        }
        
        return detection;
    }
    
    /**
     * Detect file format using magic bytes
     */
    _detectFileFormat(buffer) {
        for (const [formatName, format] of Object.entries(this.binaryPatterns)) {
            for (const signature of format.signatures) {
                if (this._matchesSignature(buffer, signature)) {
                    return { ...format, name: formatName };
                }
            }
        }
        return null;
    }
    
    /**
     * Check if buffer matches signature
     */
    _matchesSignature(buffer, signature) {
        if (buffer.length < signature.length) return false;
        
        for (let i = 0; i < signature.length; i++) {
            if (buffer[i] !== signature[i]) return false;
        }
        return true;
    }
    
    /**
     * Analyze byte distribution to determine if binary
     */
    _analyzeByteDistribution(buffer) {
        const byteFreq = new Array(256).fill(0);
        let controlChars = 0;
        let printableChars = 0;
        
        for (let i = 0; i < Math.min(buffer.length, 8192); i++) { // Sample first 8KB
            const byte = buffer[i];
            byteFreq[byte]++;
            
            if (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) {
                controlChars++;
            } else if (byte >= 32 && byte <= 126) {
                printableChars++;
            }
        }
        
        const totalSampled = Math.min(buffer.length, 8192);
        const controlRatio = controlChars / totalSampled;
        const printableRatio = printableChars / totalSampled;
        
        // Calculate entropy
        let entropy = 0;
        for (const freq of byteFreq) {
            if (freq > 0) {
                const probability = freq / totalSampled;
                entropy -= probability * Math.log2(probability);
            }
        }
        
        // Determine binary probability
        let binaryProbability = 0;
        
        // High control character ratio suggests binary
        if (controlRatio > 0.3) binaryProbability += 0.4;
        
        // Low printable ratio suggests binary
        if (printableRatio < 0.7) binaryProbability += 0.3;
        
        // High entropy suggests compressed/encrypted binary
        if (entropy > 7.5) binaryProbability += 0.3;
        
        return {
            binaryProbability: Math.min(binaryProbability, 1.0),
            controlRatio,
            printableRatio,
            entropy,
            byteDistribution: byteFreq
        };
    }
    
    /**
     * Check if string is base64 encoded
     */
    _isBase64(str) {
        if (str.length < 4) return false;
        
        const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
        return base64Regex.test(str) && str.length % 4 === 0;
    }
    
    /**
     * Check if string contains binary characters
     */
    _hasBinaryCharacters(str) {
        for (let i = 0; i < Math.min(str.length, 1000); i++) {
            const charCode = str.charCodeAt(i);
            if (charCode < 32 && charCode !== 9 && charCode !== 10 && charCode !== 13) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Find binary fields in object
     */
    _findBinaryFields(obj, path = '') {
        const binaryFields = [];
        
        for (const [key, value] of Object.entries(obj)) {
            const currentPath = path ? `${path}.${key}` : key;
            
            if (Buffer.isBuffer(value)) {
                binaryFields.push({
                    path: currentPath,
                    type: 'buffer',
                    size: value.length
                });
            } else if (typeof value === 'string' && this._isBase64(value) && value.length > 100) {
                binaryFields.push({
                    path: currentPath,
                    type: 'base64',
                    size: value.length
                });
            } else if (typeof value === 'object' && value !== null) {
                binaryFields.push(...this._findBinaryFields(value, currentPath));
            }
        }
        
        return binaryFields;
    }
    
    /**
     * Analyze binary content for metadata extraction
     */
    async _analyzeBinaryContent(data, detection, session) {
        const analysis = {
            ...detection,
            metadata: {},
            riskLevel: this._calculateRiskLevel(detection),
            optimizationStrategy: this._determineOptimizationStrategy(detection)
        };
        
        if (this.config.enableMetadataExtraction) {
            analysis.metadata = await this._extractMetadata(data, detection);
        }
        
        if (this.config.enableContentAnalysis) {
            analysis.contentSummary = await this._analyzeContent(data, detection);
        }
        
        return analysis;
    }
    
    /**
     * Calculate risk level based on size and type
     */
    _calculateRiskLevel(detection) {
        let riskScore = 0;
        
        // Size-based risk
        if (detection.size > this.config.criticalThreshold) {
            riskScore += 40;
        } else if (detection.size > this.config.warningThreshold) {
            riskScore += 20;
        }
        
        // Type-based risk
        if (detection.format) {
            switch (detection.format.typical_size) {
                case 'very_large': riskScore += 30; break;
                case 'large': riskScore += 20; break;
                case 'medium': riskScore += 10; break;
                default: riskScore += 5;
            }
        }
        
        // Category-based risk
        switch (detection.dataType) {
            case 'video': riskScore += 25; break;
            case 'audio': riskScore += 20; break;
            case 'image': riskScore += 15; break;
            case 'document': riskScore += 10; break;
            default: riskScore += 5;
        }
        
        if (riskScore >= 60) return 'CRITICAL';
        if (riskScore >= 40) return 'HIGH';
        if (riskScore >= 20) return 'MEDIUM';
        return 'LOW';
    }
    
    /**
     * Determine optimization strategy
     */
    _determineOptimizationStrategy(detection) {
        const strategies = [];
        
        if (detection.size > this.config.maximumLogSize) {
            strategies.push('EXCLUDE');
        } else if (detection.size > this.config.criticalThreshold) {
            strategies.push('METADATA_ONLY');
        } else if (detection.size > this.config.warningThreshold) {
            strategies.push('COMPRESS');
        } else {
            strategies.push('HASH_ONLY');
        }
        
        if (detection.format && detection.format.category === 'image') {
            strategies.push('THUMBNAIL');
        }
        
        return strategies;
    }
    
    /**
     * Extract metadata from binary data
     */
    async _extractMetadata(data, detection) {
        const metadata = {
            size: detection.size,
            timestamp: new Date().toISOString()
        };
        
        if (detection.format) {
            metadata.format = detection.format.name;
            metadata.mimeType = detection.format.mimeType;
            metadata.category = detection.format.category;
        }
        
        // Add format-specific metadata
        if (detection.format && detection.format.category === 'image') {
            metadata.imageInfo = this._extractImageMetadata(data);
        }
        
        return metadata;
    }
    
    /**
     * Extract image metadata
     */
    _extractImageMetadata(data) {
        const info = {
            hasExif: false,
            estimatedQuality: 'unknown'
        };
        
        // Basic image analysis (simplified)
        const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'base64');
        
        // Check for EXIF data in JPEG
        if (buffer.length > 4 && buffer[0] === 0xFF && buffer[1] === 0xD8) {
            info.hasExif = this._hasExifData(buffer);
        }
        
        return info;
    }
    
    /**
     * Check for EXIF data in JPEG
     */
    _hasExifData(buffer) {
        for (let i = 0; i < buffer.length - 4; i++) {
            if (buffer[i] === 0xFF && buffer[i + 1] === 0xE1) {
                return true; // EXIF marker found
            }
        }
        return false;
    }
    
    /**
     * Optimize binary data for logging
     */
    async _optimizeForLogging(data, analysis, session) {
        const strategies = analysis.optimizationStrategy;
        
        if (strategies.includes('EXCLUDE')) {
            return this._createExclusionPlaceholder(analysis);
        }
        
        if (strategies.includes('METADATA_ONLY')) {
            return this._createMetadataPlaceholder(analysis);
        }
        
        if (strategies.includes('COMPRESS')) {
            return await this._createCompressedRepresentation(data, analysis);
        }
        
        if (strategies.includes('HASH_ONLY')) {
            return this._createHashPlaceholder(data, analysis);
        }
        
        // Default: return truncated representation
        return this._createTruncatedRepresentation(data, analysis);
    }
    
    /**
     * Create exclusion placeholder
     */
    _createExclusionPlaceholder(analysis) {
        return {
            _binaryData: true,
            _excluded: true,
            reason: 'SIZE_EXCEEDS_MAXIMUM',
            size: analysis.size,
            format: analysis.format?.name || 'unknown',
            riskLevel: analysis.riskLevel,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Create metadata-only placeholder
     */
    _createMetadataPlaceholder(analysis) {
        return {
            _binaryData: true,
            _metadataOnly: true,
            size: analysis.size,
            format: analysis.format?.name || 'unknown',
            mimeType: analysis.format?.mimeType || 'application/octet-stream',
            category: analysis.dataType,
            riskLevel: analysis.riskLevel,
            metadata: analysis.metadata,
            contentSummary: analysis.contentSummary,
            hash: this._generateContentHash(analysis.size),
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Create compressed representation
     */
    async _createCompressedRepresentation(data, analysis) {
        try {
            const compressed = await this.compressionEngine.compress(data);
            
            return {
                _binaryData: true,
                _compressed: true,
                originalSize: analysis.size,
                compressedSize: compressed.length,
                compressionRatio: (compressed.length / analysis.size * 100).toFixed(2) + '%',
                format: analysis.format?.name || 'unknown',
                data: compressed.toString('base64').substring(0, 1000) + '...', // Truncate even compressed data
                metadata: analysis.metadata,
                hash: this._generateContentHash(analysis.size),
                timestamp: new Date().toISOString()
            };
        } catch (error) {
            return this._createHashPlaceholder(data, analysis);
        }
    }
    
    /**
     * Create hash placeholder
     */
    _createHashPlaceholder(data, analysis) {
        const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'base64');
        const hash = crypto.createHash('sha256').update(buffer).digest('hex');
        
        return {
            _binaryData: true,
            _hashed: true,
            size: analysis.size,
            format: analysis.format?.name || 'unknown',
            hash: hash.substring(0, 16), // Truncate hash for readability
            metadata: analysis.metadata,
            riskLevel: analysis.riskLevel,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Create truncated representation
     */
    _createTruncatedRepresentation(data, analysis) {
        const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'base64');
        const preview = buffer.slice(0, 100).toString('base64');
        
        return {
            _binaryData: true,
            _truncated: true,
            size: analysis.size,
            format: analysis.format?.name || 'unknown',
            preview: preview + '...',
            metadata: analysis.metadata,
            hash: this._generateContentHash(analysis.size),
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Generate content hash
     */
    _generateContentHash(size) {
        return crypto.createHash('md5')
            .update(size.toString() + Date.now().toString())
            .digest('hex')
            .substring(0, 8);
    }
    
    /**
     * Create processing session
     */
    _createProcessingSession(context) {
        return {
            id: crypto.randomBytes(8).toString('hex'),
            startTime: Date.now(),
            context: context,
            environment: process.env.NODE_ENV || 'development'
        };
    }
    
    /**
     * Initialize performance metrics
     */
    _initializeMetrics() {
        return {
            totalProcessed: 0,
            binaryDetected: 0,
            bytesProcessed: 0,
            avgProcessingTime: 0,
            optimizationStrategies: {
                excluded: 0,
                metadataOnly: 0,
                compressed: 0,
                hashed: 0,
                truncated: 0
            }
        };
    }
    
    /**
     * Record binary processing metrics
     */
    _recordBinaryProcessing(session, processingTime, analysis) {
        this.performanceMetrics.totalProcessed++;
        this.performanceMetrics.binaryDetected++;
        this.performanceMetrics.bytesProcessed += analysis.size;
        
        // Update average processing time
        this.performanceMetrics.avgProcessingTime = 
            (this.performanceMetrics.avgProcessingTime * (this.performanceMetrics.totalProcessed - 1) + processingTime) /
            this.performanceMetrics.totalProcessed;
        
        // Track optimization strategies
        analysis.optimizationStrategy.forEach(strategy => {
            const key = strategy.toLowerCase().replace('_', '');
            if (this.performanceMetrics.optimizationStrategies[key] !== undefined) {
                this.performanceMetrics.optimizationStrategies[key]++;
            }
        });
    }
    
    /**
     * Record non-binary processing
     */
    _recordNonBinaryProcessing(session, processingTime) {
        this.performanceMetrics.totalProcessed++;
        this.performanceMetrics.avgProcessingTime = 
            (this.performanceMetrics.avgProcessingTime * (this.performanceMetrics.totalProcessed - 1) + processingTime) /
            this.performanceMetrics.totalProcessed;
    }
    
    /**
     * Handle processing errors
     */
    _handleProcessingError(error, session) {
        console.error('Binary data processing error:', {
            sessionId: session.id,
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Create error placeholder
     */
    _createErrorPlaceholder(data, error) {
        return {
            _binaryData: true,
            _error: true,
            error: error.message,
            originalDataType: typeof data,
            timestamp: new Date().toISOString()
        };
    }
    
    /**
     * Get performance statistics
     */
    getStatistics() {
        const stats = { ...this.performanceMetrics };
        
        if (stats.totalProcessed > 0) {
            stats.binaryDetectionRate = (stats.binaryDetected / stats.totalProcessed * 100).toFixed(2) + '%';
            stats.avgBytesPerBinary = stats.binaryDetected > 0 ? 
                Math.round(stats.bytesProcessed / stats.binaryDetected) : 0;
        }
        
        return stats;
    }
}

/**
 * Content Analyzer for advanced binary analysis
 */
class ContentAnalyzer {
    analyzeContent(data, detection) {
        const summary = {
            hasText: false,
            estimatedComplexity: 'unknown',
            potentialSensitiveData: false
        };
        
        // Basic content analysis would go here
        // This is a simplified version
        
        return summary;
    }
}

/**
 * Compression Engine for binary data
 */
class CompressionEngine {
    async compress(data) {
        const zlib = require('zlib');
        const buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'base64');
        
        return new Promise((resolve, reject) => {
            zlib.gzip(buffer, (err, compressed) => {
                if (err) reject(err);
                else resolve(compressed);
            });
        });
    }
}

module.exports = {
    BinaryDataHandler,
    ContentAnalyzer,
    CompressionEngine
};
```

### Winston Integration for Binary Data Handling

```javascript
const winston = require('winston');
const { BinaryDataHandler } = require('./BinaryDataHandler');

/**
 * Binary data optimized Winston format
 */
const binaryOptimizedFormat = (binaryHandler) => {
    return winston.format((info) => {
        const processField = async (value) => {
            if (Buffer.isBuffer(value) || 
                (typeof value === 'string' && value.length > 1000) ||
                (typeof value === 'object' && value !== null)) {
                return await binaryHandler.processBinaryData(value, {
                    logLevel: info.level,
                    logger: info.logger || 'unknown'
                });
            }
            return value;
        };
        
        // Process message
        if (info.message) {
            info.message = processField(info.message);
        }
        
        // Process metadata
        const processObject = async (obj) => {
            for (const [key, value] of Object.entries(obj)) {
                if (Buffer.isBuffer(value) || 
                    (typeof value === 'string' && value.length > 1000)) {
                    obj[key] = await processField(value);
                } else if (typeof value === 'object' && value !== null) {
                    await processObject(value);
                }
            }
        };
        
        if (info.meta && typeof info.meta === 'object') {
            processObject(info.meta);
        }
        
        return info;
    })();
};

/**
 * Create binary-optimized logger
 */
function createBinaryOptimizedLogger(options = {}) {
    const binaryHandler = new BinaryDataHandler({
        warningThreshold: 1024,
        criticalThreshold: 10240,
        maximumLogSize: 102400,
        compressionEnabled: true,
        enableMetadataExtraction: true,
        ...options.binaryConfig
    });
    
    return winston.createLogger({
        level: options.level || 'info',
        format: winston.format.combine(
            winston.format.timestamp(),
            binaryOptimizedFormat(binaryHandler),
            winston.format.json()
        ),
        transports: [
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.simple()
                )
            }),
            new winston.transports.File({
                filename: 'logs/application.log',
                maxsize: 10485760,
                maxFiles: 10
            }),
            // Separate transport for binary data events
            new winston.transports.File({
                filename: 'logs/binary-data.log',
                level: 'warn',
                maxsize: 5242880,
                maxFiles: 5
            })
        ]
    });
}

module.exports = { createBinaryOptimizedLogger };
```

### Express.js Integration Examples

```javascript
const express = require('express');
const multer = require('multer');
const { createBinaryOptimizedLogger } = require('./binary-optimized-logger');

const app = express();
const logger = createBinaryOptimizedLogger();

// Configure multer for file uploads
const upload = multer({
    limits: {
        fileSize: 10 * 1024 * 1024 // 10MB limit
    },
    fileFilter: (req, file, cb) => {
        // Log file upload attempt safely
        logger.info('File upload attempt', {
            filename: file.originalname,
            mimetype: file.mimetype,
            size: file.size,
            fieldname: file.fieldname,
            encoding: file.encoding
        });
        cb(null, true);
    }
});

/**
 * Safe file upload logging middleware
 */
function safeFileUploadLogger() {
    return (req, res, next) => {
        const originalFiles = req.files;
        
        if (originalFiles && originalFiles.length > 0) {
            // Log file metadata without content
            const fileMetadata = originalFiles.map(file => ({
                originalname: file.originalname,
                mimetype: file.mimetype,
                size: file.size,
                fieldname: file.fieldname,
                encoding: file.encoding,
                hash: require('crypto')
                    .createHash('md5')
                    .update(file.buffer || file.filename || file.originalname)
                    .digest('hex')
                    .substring(0, 8)
            }));
            
            logger.info('Files uploaded', {
                fileCount: originalFiles.length,
                totalSize: originalFiles.reduce((sum, file) => sum + file.size, 0),
                files: fileMetadata
            });
        }
        
        next();
    };
}

/**
 * Binary response handler
 */
function safeBinaryResponseLogger() {
    return (req, res, next) => {
        const originalSend = res.send;
        
        res.send = function(body) {
            // Check if response contains binary data
            if (Buffer.isBuffer(body) || 
                (typeof body === 'string' && body.length > 10000)) {
                
                logger.info('Binary response sent', {
                    path: req.path,
                    method: req.method,
                    statusCode: res.statusCode,
                    contentType: res.get('Content-Type'),
                    contentLength: Buffer.isBuffer(body) ? body.length : body.length,
                    isBinary: Buffer.isBuffer(body),
                    responseHash: require('crypto')
                        .createHash('md5')
                        .update(body)
                        .digest('hex')
                        .substring(0, 8)
                });
            }
            
            return originalSend.call(this, body);
        };
        
        next();
    };
}

// Use middleware
app.use(safeFileUploadLogger());
app.use(safeBinaryResponseLogger());

// File upload endpoint
app.post('/api/upload', upload.array('files'), (req, res) => {
    try {
        // DON'T LOG: logger.info('File content', req.files); // NEVER!
        
        // DO LOG: Safe file processing events
        logger.info('File upload completed', {
            uploadId: require('crypto').randomBytes(8).toString('hex'),
            fileCount: req.files ? req.files.length : 0,
            totalSize: req.files ? req.files.reduce((sum, f) => sum + f.size, 0) : 0,
            processingTime: Date.now() - req.startTime
        });
        
        res.json({ 
            success: true, 
            message: 'Files uploaded successfully',
            fileCount: req.files ? req.files.length : 0
        });
        
    } catch (error) {
        logger.error('File upload failed', {
            error: error.message,
            stack: error.stack,
            uploadAttempt: true
        });
        
        res.status(500).json({ error: 'Upload failed' });
    }
});

// Image processing endpoint
app.get('/api/image/:id', (req, res) => {
    try {
        // Simulate image retrieval
        const imageId = req.params.id;
        
        // DON'T LOG: logger.info('Image data', imageBuffer); // NEVER!
        
        // DO LOG: Safe image processing events
        logger.info('Image request processed', {
            imageId: imageId,
            requestor: req.ip,
            userAgent: req.get('User-Agent'),
            format: req.query.format || 'original',
            timestamp: new Date().toISOString()
        });
        
        // Return placeholder response
        res.json({ message: 'Image processing simulated' });
        
    } catch (error) {
        logger.error('Image processing failed', {
            imageId: req.params.id,
            error: error.message,
            requestPath: req.path
        });
        
        res.status(500).json({ error: 'Image processing failed' });
    }
});

module.exports = app;
```

## Performance Impact Analysis

### Memory Usage Impact

```javascript
/**
 * Memory Usage Monitor for Binary Data Logging
 */
class BinaryLoggingMonitor {
    constructor() {
        this.measurements = [];
        this.alertThresholds = {
            memoryIncrease: 50 * 1024 * 1024, // 50MB
            processingTime: 1000 // 1 second
        };
    }
    
    measureBinaryLogging(dataSize, processingTime) {
        const memUsage = process.memoryUsage();
        
        const measurement = {
            timestamp: Date.now(),
            dataSize,
            processingTime,
            memoryUsage: memUsage,
            heapUsed: memUsage.heapUsed,
            external: memUsage.external
        };
        
        this.measurements.push(measurement);
        
        // Alert on concerning patterns
        this._checkForAlerts(measurement);
        
        return measurement;
    }
    
    _checkForAlerts(current) {
        if (this.measurements.length > 1) {
            const previous = this.measurements[this.measurements.length - 2];
            const memoryIncrease = current.heapUsed - previous.heapUsed;
            
            if (memoryIncrease > this.alertThresholds.memoryIncrease) {
                console.warn('High memory usage detected in binary logging', {
                    memoryIncrease: `${Math.round(memoryIncrease / 1024 / 1024)}MB`,
                    dataSize: `${Math.round(current.dataSize / 1024)}KB`,
                    processingTime: `${current.processingTime}ms`
                });
            }
        }
        
        if (current.processingTime > this.alertThresholds.processingTime) {
            console.warn('Slow binary data processing detected', {
                processingTime: `${current.processingTime}ms`,
                dataSize: `${Math.round(current.dataSize / 1024)}KB`
            });
        }
    }
    
    getStatistics() {
        if (this.measurements.length === 0) return null;
        
        const totalSize = this.measurements.reduce((sum, m) => sum + m.dataSize, 0);
        const avgProcessingTime = this.measurements.reduce((sum, m) => sum + m.processingTime, 0) / this.measurements.length;
        
        return {
            totalMeasurements: this.measurements.length,
            totalDataProcessed: `${Math.round(totalSize / 1024 / 1024)}MB`,
            averageProcessingTime: `${Math.round(avgProcessingTime)}ms`,
            peakMemoryUsage: Math.max(...this.measurements.map(m => m.heapUsed))
        };
    }
}
```

## Best Practices Summary

### ✅ **DO: Safe Binary Data Logging**
- **Log metadata only**: Size, type, format, hash
- **Use compression**: For unavoidable binary logging
- **Set size limits**: Prevent oversized log entries
- **Generate hashes**: For content verification
- **Extract thumbnails**: For image data (if needed)

### ❌ **DON'T: Dangerous Binary Logging**
- **Never log full binary content** in production
- **Avoid base64 encoding** large data in logs
- **Don't log file contents** from uploads
- **Skip image/video data** in error logs
- **Prevent accidental serialization** of binary objects

### 🚀 **Performance Optimization**
- **Early detection**: Identify binary data quickly
- **Streaming processing**: Handle large data efficiently
- **Memory management**: Prevent memory leaks
- **Caching strategies**: Cache metadata for repeated data
- **Monitoring**: Track performance impact

### 📊 **Monitoring & Alerting**
- **Size thresholds**: Alert on large data detection
- **Performance metrics**: Track processing times
- **Memory usage**: Monitor memory impact
- **Storage growth**: Track log file sizes
- **Error rates**: Monitor binary processing failures

Binary data logging optimization is essential for maintaining application performance and storage efficiency while preserving valuable diagnostic information.
