# 3.2.1 Sensitive Data (Passwords, API Keys)

## Overview
Logging sensitive data such as passwords, API keys, tokens, and other credentials is one of the most critical security vulnerabilities in application logging. This section provides comprehensive strategies, tools, and implementations to prevent sensitive data exposure while maintaining effective logging capabilities.

## Core Implementation

```javascript
const crypto = require('crypto');
const winston = require('winston');

class SensitiveDataProtector {
    constructor(options = {}) {
        this.logger = winston.createLogger({
            level: options.level || 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                this.createSanitizingFormat(),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ 
                    filename: 'logs/application.log',
                    maxsize: 10485760,
                    maxFiles: 5
                }),
                new winston.transports.Console({
                    format: winston.format.combine(
                        winston.format.colorize(),
                        winston.format.simple()
                    )
                })
            ]
        });

        // Configuration for sensitive data detection and handling
        this.config = {
            // Patterns for detecting sensitive data
            sensitivePatterns: {
                // Password patterns
                passwords: [
                    /password["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /passwd["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /pwd["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /"password"\s*:\s*"[^"]+"/gi,
                    /'password'\s*:\s*'[^']+'/gi
                ],
                // API Key patterns
                apiKeys: [
                    /api[_-]?key["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /apikey["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /api[_-]?secret["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /bearer\s+[a-zA-Z0-9\-._~+\/]+=*/gi,
                    /sk_live_[a-zA-Z0-9]+/gi, // Stripe live keys
                    /sk_test_[a-zA-Z0-9]+/gi, // Stripe test keys
                    /pk_live_[a-zA-Z0-9]+/gi, // Stripe publishable keys
                    /pk_test_[a-zA-Z0-9]+/gi  // Stripe test publishable keys
                ],
                // Token patterns
                tokens: [
                    /token["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /access[_-]?token["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /refresh[_-]?token["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /jwt["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /authorization["\s]*[:=]["\s]*[^"\s,}]+/gi
                ],
                // Database credentials
                dbCredentials: [
                    /mongodb:\/\/[^:]+:[^@]+@/gi,
                    /mysql:\/\/[^:]+:[^@]+@/gi,
                    /postgresql:\/\/[^:]+:[^@]+@/gi,
                    /redis:\/\/[^:]+:[^@]+@/gi,
                    /connection[_-]?string["\s]*[:=]["\s]*[^"\s,}]+/gi
                ],
                // Cloud provider keys
                awsKeys: [
                    /AKIA[0-9A-Z]{16}/g, // AWS Access Key ID
                    /aws[_-]?secret[_-]?access[_-]?key["\s]*[:=]["\s]*[^"\s,}]+/gi
                ],
                // SSH keys
                sshKeys: [
                    /-----BEGIN\s+(RSA\s+)?PRIVATE\s+KEY-----/gi,
                    /ssh-rsa\s+[A-Za-z0-9+\/=]+/gi,
                    /ssh-ed25519\s+[A-Za-z0-9+\/=]+/gi
                ],
                // Generic secrets
                secrets: [
                    /secret["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /private[_-]?key["\s]*[:=]["\s]*[^"\s,}]+/gi,
                    /client[_-]?secret["\s]*[:=]["\s]*[^"\s,}]+/gi
                ]
            },
            
            // Sensitive field names (case-insensitive)
            sensitiveFields: [
                'password', 'passwd', 'pwd', 'pass',
                'apikey', 'api_key', 'apiKey', 'api-key',
                'secret', 'clientSecret', 'client_secret',
                'token', 'accessToken', 'access_token', 'refreshToken',
                'authorization', 'auth', 'bearer',
                'privateKey', 'private_key', 'secretKey', 'secret_key',
                'connectionString', 'connection_string', 'dsn',
                'awsSecretAccessKey', 'aws_secret_access_key'
            ],

            // Replacement strategies
            replacementStrategies: {
                mask: '[MASKED]',
                redact: '[REDACTED]',
                hash: true, // Generate hash instead of masking
                partial: true, // Show partial data (first/last few characters)
                tokenize: false // Replace with secure tokens
            },

            // Environment-specific settings
            environment: process.env.NODE_ENV || 'development',
            strictMode: options.strictMode || process.env.NODE_ENV === 'production',
            
            ...options
        };

        this.tokenStore = new Map(); // For tokenization
        this.setupSecurityValidation();
    }

    // Create custom format for sanitizing sensitive data
    createSanitizingFormat() {
        return winston.format((info) => {
            return this.sanitizeLogEntry(info);
        })();
    }

    // Main sanitization method
    sanitizeLogEntry(logEntry) {
        try {
            // Deep clone to avoid modifying original object
            const sanitized = JSON.parse(JSON.stringify(logEntry));
            
            // Sanitize message string
            if (typeof sanitized.message === 'string') {
                sanitized.message = this.sanitizeString(sanitized.message);
            }

            // Sanitize all object properties recursively
            this.sanitizeObject(sanitized);

            // Add sanitization metadata
            sanitized._sanitized = {
                timestamp: new Date().toISOString(),
                version: '1.0.0',
                strictMode: this.config.strictMode
            };

            return sanitized;

        } catch (error) {
            // Fallback: return minimal safe log entry
            return {
                level: logEntry.level || 'error',
                message: '[SANITIZATION_ERROR] Failed to sanitize log entry',
                timestamp: new Date().toISOString(),
                originalError: error.message,
                _sanitized: true,
                _error: true
            };
        }
    }

    // Sanitize string content
    sanitizeString(text) {
        let sanitized = text;

        // Apply all sensitive data patterns
        Object.entries(this.config.sensitivePatterns).forEach(([category, patterns]) => {
            patterns.forEach(pattern => {
                sanitized = sanitized.replace(pattern, (match) => {
                    return this.applyReplacementStrategy(match, category);
                });
            });
        });

        return sanitized;
    }

    // Recursively sanitize object properties
    sanitizeObject(obj) {
        if (!obj || typeof obj !== 'object') return;

        Object.keys(obj).forEach(key => {
            const lowerKey = key.toLowerCase();
            
            // Check if field name indicates sensitive data
            if (this.isSensitiveField(lowerKey)) {
                obj[key] = this.applySensitiveFieldStrategy(obj[key], key);
            } else if (typeof obj[key] === 'string') {
                // Sanitize string values
                obj[key] = this.sanitizeString(obj[key]);
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                // Recursively sanitize nested objects
                this.sanitizeObject(obj[key]);
            }
        });
    }

    // Check if field name indicates sensitive data
    isSensitiveField(fieldName) {
        return this.config.sensitiveFields.some(sensitive => 
            fieldName.includes(sensitive.toLowerCase())
        );
    }

    // Apply replacement strategy for matched patterns
    applyReplacementStrategy(match, category) {
        const strategy = this.config.replacementStrategies;

        switch (category) {
            case 'passwords':
                return this.maskPassword(match);
            case 'apiKeys':
            case 'tokens':
                return this.maskApiKey(match);
            case 'secrets':
                return strategy.hash ? this.hashValue(match) : strategy.redact;
            case 'dbCredentials':
                return this.maskConnectionString(match);
            case 'awsKeys':
                return this.maskAwsKey(match);
            case 'sshKeys':
                return '[SSH_KEY_REDACTED]';
            default:
                return strategy.mask;
        }
    }

    // Apply strategy for sensitive field values
    applySensitiveFieldStrategy(value, fieldName) {
        if (value === null || value === undefined) return value;

        const strategy = this.config.replacementStrategies;
        
        if (typeof value === 'string') {
            if (strategy.partial && value.length > 8) {
                return this.partialMask(value);
            } else if (strategy.hash) {
                return this.hashValue(value);
            } else if (strategy.tokenize) {
                return this.tokenizeValue(value, fieldName);
            } else {
                return strategy.redact;
            }
        }
        
        return strategy.redact;
    }

    // Specific masking strategies
    maskPassword(match) {
        // Extract key-value pattern and mask only the value
        return match.replace(/([^:=]+[:=]\s*)([^"\s,}]+)/gi, '$1[PASSWORD_MASKED]');
    }

    maskApiKey(match) {
        // Show first 4 and last 4 characters for API keys if partial masking enabled
        if (this.config.replacementStrategies.partial) {
            return match.replace(/([^:=]+[:=]\s*)([^"\s,}]+)/gi, (fullMatch, prefix, key) => {
                if (key.length > 8) {
                    const masked = key.substring(0, 4) + '*'.repeat(key.length - 8) + key.substring(key.length - 4);
                    return prefix + masked;
                }
                return prefix + '[API_KEY_MASKED]';
            });
        }
        return match.replace(/([^:=]+[:=]\s*)([^"\s,}]+)/gi, '$1[API_KEY_MASKED]');
    }

    maskConnectionString(match) {
        // Mask credentials in connection strings while preserving structure
        return match.replace(/(\/\/[^:]+:)[^@]+([@])/gi, '$1[CREDENTIALS_MASKED]$2');
    }

    maskAwsKey(match) {
        // AWS keys - show first 4 characters only
        if (match.length > 8) {
            return match.substring(0, 4) + '*'.repeat(match.length - 4);
        }
        return '[AWS_KEY_MASKED]';
    }

    partialMask(value) {
        if (value.length <= 8) return '[MASKED]';
        const start = value.substring(0, 2);
        const end = value.substring(value.length - 2);
        const middle = '*'.repeat(Math.min(value.length - 4, 10));
        return start + middle + end;
    }

    hashValue(value) {
        // Create SHA-256 hash for audit purposes
        const hash = crypto.createHash('sha256').update(value).digest('hex');
        return `[HASH:${hash.substring(0, 8)}]`;
    }

    tokenizeValue(value, fieldName) {
        // Generate secure token for value
        const token = crypto.randomBytes(16).toString('hex');
        this.tokenStore.set(token, {
            originalField: fieldName,
            timestamp: Date.now(),
            hash: this.hashValue(value)
        });
        return `[TOKEN:${token}]`;
    }

    // Security validation setup
    setupSecurityValidation() {
        // Validate configuration on startup
        this.validateSecurityConfig();
        
        // Set up periodic security audits
        if (this.config.strictMode) {
            setInterval(() => {
                this.performSecurityAudit();
            }, 3600000); // Every hour
        }
    }

    validateSecurityConfig() {
        const issues = [];

        // Check if running in production with appropriate settings
        if (this.config.environment === 'production') {
            if (!this.config.strictMode) {
                issues.push('Strict mode should be enabled in production');
            }
            
            if (this.config.replacementStrategies.partial) {
                issues.push('Partial masking may expose sensitive data in production');
            }
        }

        // Check for weak patterns
        const patternCount = Object.values(this.config.sensitivePatterns)
            .reduce((total, patterns) => total + patterns.length, 0);
        
        if (patternCount < 10) {
            issues.push('Insufficient sensitive data patterns configured');
        }

        if (issues.length > 0) {
            this.logger.warn('Security configuration issues detected', {
                event: 'security_config_validation',
                issues,
                environment: this.config.environment,
                timestamp: new Date().toISOString()
            });
        } else {
            this.logger.info('Security configuration validated successfully', {
                event: 'security_config_ok',
                patternCount,
                strictMode: this.config.strictMode,
                environment: this.config.environment
            });
        }
    }

    performSecurityAudit() {
        const auditResults = {
            timestamp: new Date().toISOString(),
            tokenStoreSize: this.tokenStore.size,
            configHash: crypto.createHash('sha256')
                .update(JSON.stringify(this.config.sensitivePatterns))
                .digest('hex').substring(0, 16),
            environment: this.config.environment,
            strictMode: this.config.strictMode
        };

        this.logger.info('Security audit completed', {
            event: 'security_audit',
            results: auditResults
        });

        // Clean up old tokens
        this.cleanupTokenStore();
    }

    cleanupTokenStore() {
        const oneHour = 3600000;
        const cutoff = Date.now() - oneHour;
        let cleanedCount = 0;

        for (const [token, data] of this.tokenStore.entries()) {
            if (data.timestamp < cutoff) {
                this.tokenStore.delete(token);
                cleanedCount++;
            }
        }

        if (cleanedCount > 0) {
            this.logger.debug('Token store cleanup completed', {
                event: 'token_cleanup',
                cleanedTokens: cleanedCount,
                remainingTokens: this.tokenStore.size
            });
        }
    }

    // Public methods for testing and validation
    testSanitization(testData) {
        const original = JSON.stringify(testData, null, 2);
        const sanitized = this.sanitizeLogEntry({ message: original, data: testData });
        
        return {
            original: testData,
            sanitized: sanitized,
            detectedSensitiveData: this.detectSensitiveData(original),
            securityScore: this.calculateSecurityScore(original, JSON.stringify(sanitized))
        };
    }

    detectSensitiveData(text) {
        const detected = [];
        
        Object.entries(this.config.sensitivePatterns).forEach(([category, patterns]) => {
            patterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    detected.push({
                        category,
                        pattern: pattern.toString(),
                        matches: matches.length
                    });
                }
            });
        });

        return detected;
    }

    calculateSecurityScore(original, sanitized) {
        const originalSensitive = this.detectSensitiveData(original);
        const sanitizedSensitive = this.detectSensitiveData(sanitized);
        
        const originalCount = originalSensitive.reduce((sum, item) => sum + item.matches, 0);
        const sanitizedCount = sanitizedSensitive.reduce((sum, item) => sum + item.matches, 0);
        
        if (originalCount === 0) return 100; // No sensitive data found
        
        const protectionRate = ((originalCount - sanitizedCount) / originalCount) * 100;
        return Math.max(0, Math.round(protectionRate));
    }

    // Safe logging methods
    safeLog(level, message, metadata = {}) {
        this.logger[level](message, metadata);
    }

    safeInfo(message, metadata = {}) {
        this.safeLog('info', message, metadata);
    }

    safeWarn(message, metadata = {}) {
        this.safeLog('warn', message, metadata);
    }

    safeError(message, metadata = {}) {
        this.safeLog('error', message, metadata);
    }

    safeDebug(message, metadata = {}) {
        this.safeLog('debug', message, metadata);
    }
}
```

## Advanced Security Features

### Environment-Specific Configuration

```javascript
class EnvironmentSecurityConfig {
    static getConfig(environment) {
        const baseConfig = {
            sensitiveFields: [
                'password', 'secret', 'token', 'key', 'auth'
            ],
            strictMode: false,
            replacementStrategies: {
                mask: '[MASKED]',
                redact: '[REDACTED]',
                hash: false,
                partial: false
            }
        };

        switch (environment) {
            case 'development':
                return {
                    ...baseConfig,
                    replacementStrategies: {
                        ...baseConfig.replacementStrategies,
                        partial: true // Allow partial masking in dev
                    },
                    logSanitizationEvents: true
                };

            case 'staging':
                return {
                    ...baseConfig,
                    strictMode: true,
                    replacementStrategies: {
                        ...baseConfig.replacementStrategies,
                        hash: true
                    }
                };

            case 'production':
                return {
                    ...baseConfig,
                    strictMode: true,
                    replacementStrategies: {
                        ...baseConfig.replacementStrategies,
                        hash: true,
                        partial: false // No partial data in production
                    },
                    additionalValidation: true,
                    auditLogging: true
                };

            default:
                return baseConfig;
        }
    }
}
```

### Real-time Sensitive Data Detector

```javascript
class RealTimeSensitiveDataDetector {
    constructor(protector) {
        this.protector = protector;
        this.alertThreshold = 5; // Alert after 5 detections
        this.detectionWindow = 300000; // 5 minutes
        this.recentDetections = [];
    }

    analyzeLogEntry(entry) {
        const sensitiveItems = this.protector.detectSensitiveData(
            JSON.stringify(entry)
        );

        if (sensitiveItems.length > 0) {
            this.recordDetection(sensitiveItems, entry);
            this.checkAlertThreshold();
        }

        return {
            hasSensitiveData: sensitiveItems.length > 0,
            detectedItems: sensitiveItems,
            riskLevel: this.calculateRiskLevel(sensitiveItems)
        };
    }

    recordDetection(items, entry) {
        const detection = {
            timestamp: Date.now(),
            items,
            source: entry.source || 'unknown',
            level: entry.level || 'info'
        };

        this.recentDetections.push(detection);
        this.cleanupOldDetections();
    }

    cleanupOldDetections() {
        const cutoff = Date.now() - this.detectionWindow;
        this.recentDetections = this.recentDetections.filter(
            detection => detection.timestamp > cutoff
        );
    }

    checkAlertThreshold() {
        if (this.recentDetections.length >= this.alertThreshold) {
            this.triggerSecurityAlert();
        }
    }

    triggerSecurityAlert() {
        const alert = {
            event: 'sensitive_data_exposure_alert',
            severity: 'high',
            detectionCount: this.recentDetections.length,
            timeWindow: this.detectionWindow / 1000 / 60, // minutes
            recentDetections: this.recentDetections.slice(-10), // Last 10
            timestamp: new Date().toISOString(),
            recommendedActions: [
                'Review application code for sensitive data logging',
                'Check log sanitization configuration',
                'Audit recent deployments',
                'Review access logs for potential data exposure'
            ]
        };

        this.protector.logger.error('SECURITY ALERT: Multiple sensitive data detections', alert);
        
        // Reset detection counter after alert
        this.recentDetections = [];
    }

    calculateRiskLevel(items) {
        const riskScores = {
            passwords: 10,
            apiKeys: 8,
            tokens: 7,
            secrets: 9,
            dbCredentials: 10,
            awsKeys: 9,
            sshKeys: 8
        };

        let totalRisk = 0;
        items.forEach(item => {
            totalRisk += (riskScores[item.category] || 5) * item.matches;
        });

        if (totalRisk >= 20) return 'critical';
        if (totalRisk >= 10) return 'high';
        if (totalRisk >= 5) return 'medium';
        return 'low';
    }

    generateSecurityReport() {
        const report = {
            timestamp: new Date().toISOString(),
            timeWindow: this.detectionWindow / 1000 / 60,
            totalDetections: this.recentDetections.length,
            categoryBreakdown: this.getCategoryBreakdown(),
            riskAssessment: this.getRiskAssessment(),
            recommendations: this.getRecommendations()
        };

        return report;
    }

    getCategoryBreakdown() {
        const breakdown = {};
        this.recentDetections.forEach(detection => {
            detection.items.forEach(item => {
                breakdown[item.category] = (breakdown[item.category] || 0) + item.matches;
            });
        });
        return breakdown;
    }

    getRiskAssessment() {
        const recentCount = this.recentDetections.length;
        if (recentCount === 0) return 'none';
        if (recentCount >= 10) return 'critical';
        if (recentCount >= 5) return 'high';
        if (recentCount >= 2) return 'medium';
        return 'low';
    }

    getRecommendations() {
        const breakdown = this.getCategoryBreakdown();
        const recommendations = [];

        if (breakdown.passwords > 0) {
            recommendations.push('Implement password hashing and never log plain passwords');
        }
        if (breakdown.apiKeys > 0) {
            recommendations.push('Use environment variables for API keys and implement key rotation');
        }
        if (breakdown.tokens > 0) {
            recommendations.push('Implement token sanitization and use short-lived tokens');
        }
        if (breakdown.dbCredentials > 0) {
            recommendations.push('Never log database connection strings with credentials');
        }

        return recommendations;
    }
}
```

## Usage Examples

### Basic Implementation

```javascript
// Initialize the sensitive data protector
const protector = new SensitiveDataProtector({
    strictMode: process.env.NODE_ENV === 'production',
    environment: process.env.NODE_ENV,
    replacementStrategies: {
        mask: '[MASKED]',
        redact: '[REDACTED]',
        hash: true,
        partial: process.env.NODE_ENV !== 'production'
    }
});

// Safe logging examples
function handleUserLogin(userData) {
    // ❌ DANGEROUS - This would expose passwords
    // console.log('User login attempt:', userData);
    
    // ✅ SAFE - Sensitive data will be automatically sanitized
    protector.safeInfo('User login attempt', {
        event: 'user_login',
        userId: userData.id,
        username: userData.username,
        timestamp: new Date().toISOString(),
        // Password will be automatically masked
        credentials: userData
    });
}

// Example with API key handling
function makeExternalAPICall(apiConfig) {
    // ❌ DANGEROUS
    // logger.info('Making API call with config:', apiConfig);
    
    // ✅ SAFE
    protector.safeInfo('Making external API call', {
        event: 'external_api_call',
        endpoint: apiConfig.endpoint,
        method: apiConfig.method,
        // API key will be automatically masked
        config: apiConfig
    });
}
```

### Express.js Middleware Integration

```javascript
const express = require('express');
const app = express();

// Initialize protector
const protector = new SensitiveDataProtector({
    strictMode: true,
    environment: 'production'
});

// Initialize real-time detector
const detector = new RealTimeSensitiveDataDetector(protector);

// Middleware to sanitize request/response logging
app.use((req, res, next) => {
    // Capture original end method
    const originalEnd = res.end;
    
    // Override res.end to capture response
    res.end = function(chunk, encoding) {
        // Log request safely
        const requestData = {
            method: req.method,
            url: req.url,
            headers: req.headers,
            body: req.body,
            query: req.query,
            params: req.params
        };

        // Analyze for sensitive data
        const analysis = detector.analyzeLogEntry(requestData);
        
        protector.safeInfo('HTTP Request processed', {
            event: 'http_request',
            request: requestData,
            sensitiveDataDetected: analysis.hasSensitiveData,
            riskLevel: analysis.riskLevel,
            responseStatus: res.statusCode,
            processingTime: Date.now() - req.startTime
        });

        // Call original end method
        originalEnd.call(this, chunk, encoding);
    };

    req.startTime = Date.now();
    next();
});

// Example route with potentially sensitive data
app.post('/api/users', (req, res) => {
    try {
        // Process user creation
        const userData = req.body;
        
        // Safe logging of user creation
        protector.safeInfo('Creating new user', {
            event: 'user_creation',
            userData: userData, // Will be sanitized automatically
            requestId: req.id
        });

        // Simulate user creation
        const newUser = {
            id: Math.random().toString(36),
            username: userData.username,
            email: userData.email,
            createdAt: new Date().toISOString()
        };

        res.json({
            success: true,
            user: newUser
        });

    } catch (error) {
        protector.safeError('User creation failed', {
            event: 'user_creation_error',
            error: error.message,
            requestData: req.body, // Will be sanitized
            requestId: req.id
        });

        res.status(500).json({
            success: false,
            error: 'Internal server error'
        });
    }
});

// Security monitoring endpoint
app.get('/security/report', (req, res) => {
    const report = detector.generateSecurityReport();
    res.json(report);
});
```

### Database Integration Example

```javascript
// Safe database logging
class DatabaseLogger {
    constructor() {
        this.protector = new SensitiveDataProtector({
            strictMode: true
        });
    }

    logQuery(query, params, metadata = {}) {
        this.protector.safeDebug('Database query executed', {
            event: 'db_query',
            query: query, // Will be sanitized for embedded credentials
            paramCount: params ? params.length : 0,
            // Don't log actual parameters as they might contain sensitive data
            duration: metadata.duration,
            rowCount: metadata.rowCount,
            timestamp: new Date().toISOString()
        });
    }

    logConnectionEvent(event, connectionData) {
        this.protector.safeInfo(`Database ${event}`, {
            event: `db_${event}`,
            // Connection string will be sanitized
            connectionInfo: connectionData,
            timestamp: new Date().toISOString()
        });
    }

    logError(error, context = {}) {
        this.protector.safeError('Database error occurred', {
            event: 'db_error',
            error: error.message,
            stack: error.stack,
            // Context might contain sensitive data - will be sanitized
            context: context,
            timestamp: new Date().toISOString()
        });
    }
}

// Usage example
const dbLogger = new DatabaseLogger();

async function createUser(userData) {
    const startTime = Date.now();
    
    try {
        const query = 'INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)';
        const params = [userData.username, userData.email, userData.passwordHash];
        
        // Log query execution (sensitive data will be masked)
        dbLogger.logQuery(query, params, {
            duration: Date.now() - startTime,
            rowCount: 1
        });

        return { success: true };

    } catch (error) {
        dbLogger.logError(error, {
            operation: 'create_user',
            userData: userData // Will be sanitized
        });
        throw error;
    }
}
```

### Testing and Validation

```javascript
// Test suite for sensitive data protection
function runSecurityTests() {
    const protector = new SensitiveDataProtector();
    
    const testCases = [
        {
            name: 'Password in JSON',
            data: { username: 'user', password: 'secret123' },
            expectedMasked: true
        },
        {
            name: 'API Key in string',
            data: 'Making request with api_key=sk_live_abc123def456',
            expectedMasked: true
        },
        {
            name: 'Database connection string',
            data: 'mongodb://user:password@localhost:27017/db',
            expectedMasked: true
        },
        {
            name: 'Safe data',
            data: { userId: 123, username: 'john', status: 'active' },
            expectedMasked: false
        }
    ];

    testCases.forEach(testCase => {
        console.log(`\nTesting: ${testCase.name}`);
        
        const result = protector.testSanitization(testCase.data);
        
        console.log('Security Score:', result.securityScore);
        console.log('Detected Sensitive Data:', result.detectedSensitiveData.length > 0);
        console.log('Expected Masked:', testCase.expectedMasked);
        
        const passed = testCase.expectedMasked === (result.detectedSensitiveData.length > 0);
        console.log('Test Result:', passed ? '✅ PASS' : '❌ FAIL');
        
        if (!passed) {
            console.log('Original:', result.original);
            console.log('Sanitized:', result.sanitized);
        }
    });
}

// Run comprehensive security audit
function performSecurityAudit() {
    const protector = new SensitiveDataProtector();
    const detector = new RealTimeSensitiveDataDetector(protector);
    
    // Test various sensitive data patterns
    const sensitiveTestData = [
        'User logged in with password: mySecretPass123',
        'API call made with Authorization: Bearer abc123def456',
        'Database connection: postgresql://user:pass@db:5432/app',
        'AWS credentials: AKIA1234567890ABCDEF',
        'User registration: {"username":"john","password":"secret","email":"john@example.com"}'
    ];

    console.log('\n=== SECURITY AUDIT ===\n');
    
    sensitiveTestData.forEach((data, index) => {
        console.log(`Test ${index + 1}: ${data.substring(0, 50)}...`);
        
        const analysis = detector.analyzeLogEntry({ message: data });
        console.log(`- Sensitive data detected: ${analysis.hasSensitiveData}`);
        console.log(`- Risk level: ${analysis.riskLevel}`);
        console.log(`- Items found: ${analysis.detectedItems.length}\n`);
    });

    const report = detector.generateSecurityReport();
    console.log('Final Security Report:');
    console.log(JSON.stringify(report, null, 2));
}

// Run tests
runSecurityTests();
performSecurityAudit();
```

## Key Security Benefits

1. **Automatic Detection**: Regex patterns catch various sensitive data formats
2. **Multiple Strategies**: Masking, redacting, hashing, and tokenization options
3. **Environment Awareness**: Different security levels for dev/staging/production
4. **Real-time Monitoring**: Immediate detection and alerting for exposures
5. **Comprehensive Coverage**: Passwords, API keys, tokens, connection strings, cloud credentials
6. **Configurable**: Customizable patterns and replacement strategies
7. **Audit Trail**: Security events and sanitization metadata
8. **Performance Optimized**: Efficient pattern matching and minimal overhead
9. **Compliance Ready**: Supports regulatory requirements (GDPR, HIPAA, PCI DSS)
10. **Production Hardened**: Strict mode for production environments with zero tolerance for exposure

This implementation provides enterprise-grade protection against sensitive data exposure in logs while maintaining operational visibility and debugging capabilities.
