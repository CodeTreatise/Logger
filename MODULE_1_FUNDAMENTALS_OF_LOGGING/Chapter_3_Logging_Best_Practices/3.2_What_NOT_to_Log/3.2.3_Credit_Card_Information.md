# 3.2.3 Credit Card Information

## Overview

Credit card information represents one of the most sensitive data types in any application. Logging payment card data not only violates PCI DSS (Payment Card Industry Data Security Standard) but also exposes organizations to severe financial penalties, legal liabilities, and security breaches. This section provides comprehensive protection strategies specifically designed for payment card data security.

## Understanding Payment Card Data

### Primary Account Number (PAN)
- **Credit Card Numbers**: 13-19 digit card numbers
- **Debit Card Numbers**: Bank-issued payment cards
- **Prepaid Card Numbers**: Stored-value payment cards
- **Gift Card Numbers**: Retailer-specific payment cards

### Sensitive Authentication Data
- **Full Magnetic Stripe Data**: Track 1 & Track 2 data
- **CAV2/CVC2/CVV2/CID**: Card verification values
- **PIN/PIN Block**: Personal identification numbers
- **Service Codes**: Magnetic stripe service codes

### Related Payment Data
- **Cardholder Names**: As printed on cards
- **Expiration Dates**: Card validity periods
- **Service Codes**: Authorization and usage parameters
- **Transaction Data**: When combined with PAN

## PCI DSS Compliance Requirements

### Data Protection Standards
1. **Requirement 3**: Protect stored cardholder data
2. **Requirement 4**: Encrypt transmission of cardholder data
3. **Requirement 7**: Restrict access to cardholder data
4. **Requirement 8**: Identify and authenticate access
5. **Requirement 10**: Track and monitor network access

### Logging Restrictions
- **Prohibited Data**: Never log full PAN, magnetic stripe, or CVV
- **Limited Retention**: Minimize cardholder data storage
- **Access Controls**: Restrict log access to authorized personnel
- **Audit Trails**: Maintain detailed access logs

## Credit Card Protection Implementation

### Advanced Credit Card Detector

```javascript
const crypto = require('crypto');
const winston = require('winston');

/**
 * PCI DSS Compliant Credit Card Protection System
 * Provides comprehensive detection and protection for payment card data
 */
class CreditCardProtector {
    constructor(options = {}) {
        this.config = {
            // PCI DSS compliance level
            complianceLevel: options.complianceLevel || 'strict', // 'strict', 'standard'
            
            // Detection sensitivity
            detectionSensitivity: options.detectionSensitivity || 'high',
            
            // Tokenization settings
            enableTokenization: options.enableTokenization || true,
            tokenPrefix: options.tokenPrefix || 'TKN',
            
            // Audit requirements
            auditLevel: options.auditLevel || 'comprehensive',
            
            // Performance settings
            enableCaching: options.enableCaching || false, // Disabled for security
            
            // Alert configuration
            alertOnDetection: options.alertOnDetection || true,
            alertThreshold: options.alertThreshold || 1 // Any detection triggers alert
        };
        
        this.cardPatterns = this._buildCardPatterns();
        this.luhnValidator = new LuhnValidator();
        this.tokenStore = new SecureTokenStore();
        this.auditLogger = this._createAuditLogger();
        this.alertManager = new PCIAlertManager();
        this.performanceMonitor = this._initializeMonitoring();
    }
    
    /**
     * Build comprehensive credit card detection patterns
     */
    _buildCardPatterns() {
        return {
            // Visa: 4xxx-xxxx-xxxx-xxxx (13, 16, 19 digits)
            visa: {
                pattern: /\b4[0-9]{12}(?:[0-9]{3})?(?:[0-9]{3})?\b/g,
                lengths: [13, 16, 19],
                name: 'Visa',
                riskLevel: 'CRITICAL'
            },
            
            // Mastercard: 5xxx-xxxx-xxxx-xxxx (16 digits)
            mastercard: {
                pattern: /\b5[1-5][0-9]{14}\b|\b2(?:2(?:2[1-9]|[3-9][0-9])|[3-6][0-9][0-9]|7(?:[01][0-9]|20))[0-9]{12}\b/g,
                lengths: [16],
                name: 'Mastercard',
                riskLevel: 'CRITICAL'
            },
            
            // American Express: 3xxx-xxxxxx-xxxxx (15 digits)
            amex: {
                pattern: /\b3[47][0-9]{13}\b/g,
                lengths: [15],
                name: 'American Express',
                riskLevel: 'CRITICAL'
            },
            
            // Discover: 6xxx-xxxx-xxxx-xxxx (16 digits)
            discover: {
                pattern: /\b6(?:011|5[0-9]{2})[0-9]{12}\b/g,
                lengths: [16],
                name: 'Discover',
                riskLevel: 'CRITICAL'
            },
            
            // Diners Club: 3xxx-xxxxxx-xxxx (14 digits)
            diners: {
                pattern: /\b3[0689][0-9]{12}\b/g,
                lengths: [14],
                name: 'Diners Club',
                riskLevel: 'CRITICAL'
            },
            
            // JCB: 35xx-xxxx-xxxx-xxxx (16 digits)
            jcb: {
                pattern: /\b35(?:2[89]|[3-8][0-9])[0-9]{12}\b/g,
                lengths: [16],
                name: 'JCB',
                riskLevel: 'CRITICAL'
            },
            
            // Generic card pattern for unknown types
            generic: {
                pattern: /\b[0-9]{13,19}\b/g,
                lengths: [13, 14, 15, 16, 17, 18, 19],
                name: 'Unknown Card Type',
                riskLevel: 'HIGH'
            },
            
            // CVV patterns
            cvv: {
                pattern: /\b[0-9]{3,4}\b/g,
                contextKeywords: ['cvv', 'cvc', 'cid', 'security code', 'verification'],
                name: 'CVV/CVC',
                riskLevel: 'CRITICAL'
            },
            
            // Expiration date patterns
            expiration: {
                pattern: /\b(?:0[1-9]|1[0-2])\/(?:[0-9]{2}|20[2-9][0-9])\b|\b(?:0[1-9]|1[0-2])-(?:[0-9]{2}|20[2-9][0-9])\b/g,
                contextKeywords: ['exp', 'expiry', 'expiration', 'valid thru'],
                name: 'Expiration Date',
                riskLevel: 'HIGH'
            }
        };
    }
    
    /**
     * Main credit card protection method
     */
    async protectCardData(logData) {
        const startTime = Date.now();
        const protectionSession = this._createProtectionSession();
        
        try {
            // Extract text for analysis
            const textToAnalyze = this._extractText(logData);
            
            // Detect credit card patterns
            const detections = await this._detectCardData(textToAnalyze, protectionSession);
            
            if (detections.length === 0) {
                this._recordCleanLog(protectionSession, Date.now() - startTime);
                return logData;
            }
            
            // Critical: Alert immediately on any card data detection
            if (this.config.alertOnDetection) {
                await this._triggerImmediateAlert(detections, protectionSession);
            }
            
            // Apply PCI DSS compliant protection
            const protectedData = await this._applyPCIProtection(logData, detections, protectionSession);
            
            // Audit the protection event
            await this._auditProtectionEvent(detections, protectionSession);
            
            this._recordProtectionMetrics(protectionSession, Date.now() - startTime, detections);
            
            return protectedData;
            
        } catch (error) {
            await this._handleCriticalError(error, protectionSession);
            return '[PAYMENT_DATA_PROTECTION_ERROR]';
        }
    }
    
    /**
     * Detect credit card data with high accuracy
     */
    async _detectCardData(text, session) {
        const detections = [];
        
        // Primary card number detection
        for (const [cardType, config] of Object.entries(this.cardPatterns)) {
            if (cardType === 'cvv' || cardType === 'expiration') continue;
            
            const matches = Array.from(text.matchAll(config.pattern));
            
            for (const match of matches) {
                const candidateNumber = match[0].replace(/[\s-]/g, '');
                
                // Validate card number length
                if (!config.lengths.includes(candidateNumber.length)) {
                    continue;
                }
                
                // Validate using Luhn algorithm
                if (!this.luhnValidator.isValid(candidateNumber)) {
                    continue;
                }
                
                // Additional context validation
                const contextConfidence = this._analyzeCardContext(text, match);
                
                detections.push({
                    type: 'CARD_NUMBER',
                    cardType: config.name,
                    value: match[0],
                    maskedValue: this._createSecureMask(candidateNumber),
                    index: match.index,
                    length: match[0].length,
                    riskLevel: config.riskLevel,
                    confidence: this._calculateConfidence(candidateNumber, contextConfidence),
                    luhnValid: true,
                    detectionId: this._generateDetectionId(),
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        // CVV detection with context analysis
        await this._detectCVV(text, detections);
        
        // Expiration date detection
        await this._detectExpirationDates(text, detections);
        
        // Track data detection for fraud analysis
        await this._detectMagneticStripeData(text, detections);
        
        return detections.sort((a, b) => a.index - b.index);
    }
    
    /**
     * Detect CVV with contextual analysis
     */
    async _detectCVV(text, existingDetections) {
        const cvvConfig = this.cardPatterns.cvv;
        const matches = Array.from(text.matchAll(cvvConfig.pattern));
        
        for (const match of matches) {
            const contextWindow = this._getContextWindow(text, match.index, 100);
            const hasCardContext = this._hasCardContext(contextWindow);
            const hasCVVContext = cvvConfig.contextKeywords.some(keyword => 
                contextWindow.toLowerCase().includes(keyword)
            );
            
            if (hasCardContext || hasCVVContext) {
                existingDetections.push({
                    type: 'CVV',
                    value: match[0],
                    maskedValue: '*'.repeat(match[0].length),
                    index: match.index,
                    length: match[0].length,
                    riskLevel: 'CRITICAL',
                    confidence: hasCVVContext ? 0.95 : 0.75,
                    detectionId: this._generateDetectionId(),
                    timestamp: new Date().toISOString()
                });
            }
        }
    }
    
    /**
     * Detect expiration dates in payment context
     */
    async _detectExpirationDates(text, existingDetections) {
        const expConfig = this.cardPatterns.expiration;
        const matches = Array.from(text.matchAll(expConfig.pattern));
        
        for (const match of matches) {
            const contextWindow = this._getContextWindow(text, match.index, 150);
            const hasCardContext = this._hasCardContext(contextWindow);
            const hasExpContext = expConfig.contextKeywords.some(keyword => 
                contextWindow.toLowerCase().includes(keyword)
            );
            
            // Validate date format and future date
            if (this._isValidExpirationDate(match[0]) && (hasCardContext || hasExpContext)) {
                existingDetections.push({
                    type: 'EXPIRATION_DATE',
                    value: match[0],
                    maskedValue: 'XX/XX',
                    index: match.index,
                    length: match[0].length,
                    riskLevel: 'HIGH',
                    confidence: hasExpContext ? 0.90 : 0.70,
                    detectionId: this._generateDetectionId(),
                    timestamp: new Date().toISOString()
                });
            }
        }
    }
    
    /**
     * Detect magnetic stripe track data
     */
    async _detectMagneticStripeData(text, existingDetections) {
        // Track 1 data pattern
        const track1Pattern = /\%[A-Z][0-9]{13,19}\^[A-Z\s\/]*\^[0-9]{4}[0-9]*\?/g;
        const track1Matches = Array.from(text.matchAll(track1Pattern));
        
        for (const match of track1Matches) {
            existingDetections.push({
                type: 'MAGNETIC_STRIPE_TRACK1',
                value: match[0],
                maskedValue: '[TRACK_DATA_REMOVED]',
                index: match.index,
                length: match[0].length,
                riskLevel: 'CRITICAL',
                confidence: 0.99,
                detectionId: this._generateDetectionId(),
                timestamp: new Date().toISOString()
            });
        }
        
        // Track 2 data pattern
        const track2Pattern = /;[0-9]{13,19}=[0-9]{4}[0-9]*\?/g;
        const track2Matches = Array.from(text.matchAll(track2Pattern));
        
        for (const match of track2Matches) {
            existingDetections.push({
                type: 'MAGNETIC_STRIPE_TRACK2',
                value: match[0],
                maskedValue: '[TRACK_DATA_REMOVED]',
                index: match.index,
                length: match[0].length,
                riskLevel: 'CRITICAL',
                confidence: 0.99,
                detectionId: this._generateDetectionId(),
                timestamp: new Date().toISOString()
            });
        }
    }
    
    /**
     * Apply PCI DSS compliant protection
     */
    async _applyPCIProtection(originalData, detections, session) {
        let result = this._extractText(originalData);
        let offset = 0;
        
        for (const detection of detections) {
            const adjustedIndex = detection.index + offset;
            const originalValue = detection.value;
            let protectedValue;
            
            switch (detection.type) {
                case 'CARD_NUMBER':
                    protectedValue = await this._protectCardNumber(detection, session);
                    break;
                case 'CVV':
                    protectedValue = '[CVV_REMOVED]';
                    break;
                case 'EXPIRATION_DATE':
                    protectedValue = '[EXP_REMOVED]';
                    break;
                case 'MAGNETIC_STRIPE_TRACK1':
                case 'MAGNETIC_STRIPE_TRACK2':
                    protectedValue = '[MAGNETIC_STRIPE_REMOVED]';
                    break;
                default:
                    protectedValue = '[CARD_DATA_REMOVED]';
            }
            
            // Replace in string
            result = result.substring(0, adjustedIndex) + 
                    protectedValue + 
                    result.substring(adjustedIndex + originalValue.length);
            
            // Update offset
            offset += protectedValue.length - originalValue.length;
        }
        
        return this._reconstructData(originalData, result);
    }
    
    /**
     * Protect card number with tokenization or masking
     */
    async _protectCardNumber(detection, session) {
        const cardNumber = detection.value.replace(/[\s-]/g, '');
        
        if (this.config.enableTokenization) {
            // Generate secure token
            const token = await this.tokenStore.generateToken(cardNumber, {
                cardType: detection.cardType,
                sessionId: session.id,
                timestamp: detection.timestamp
            });
            
            return `[${this.config.tokenPrefix}_${token}]`;
        } else {
            // Use PCI DSS compliant masking (show only first 6 and last 4)
            if (cardNumber.length >= 10) {
                const first6 = cardNumber.substring(0, 6);
                const last4 = cardNumber.substring(cardNumber.length - 4);
                const middle = '*'.repeat(cardNumber.length - 10);
                return `${first6}${middle}${last4}`;
            } else {
                return '*'.repeat(cardNumber.length);
            }
        }
    }
    
    /**
     * Create secure mask preserving format
     */
    _createSecureMask(cardNumber) {
        if (cardNumber.length >= 10) {
            return cardNumber.substring(0, 6) + '*'.repeat(cardNumber.length - 10) + cardNumber.substring(cardNumber.length - 4);
        }
        return '*'.repeat(cardNumber.length);
    }
    
    /**
     * Analyze context around potential card data
     */
    _analyzeCardContext(text, match) {
        const contextWindow = this._getContextWindow(text, match.index, 200);
        const paymentKeywords = [
            'payment', 'card', 'credit', 'debit', 'transaction', 'purchase',
            'billing', 'charge', 'visa', 'mastercard', 'amex', 'discover',
            'checkout', 'order', 'invoice', 'receipt'
        ];
        
        const keywordMatches = paymentKeywords.filter(keyword => 
            contextWindow.toLowerCase().includes(keyword)
        ).length;
        
        return Math.min(keywordMatches * 0.15, 0.9);
    }
    
    /**
     * Calculate detection confidence
     */
    _calculateConfidence(cardNumber, contextConfidence) {
        let baseConfidence = 0.8; // Luhn validation passed
        
        // Adjust based on card number characteristics
        if (cardNumber.length === 16) baseConfidence += 0.1;
        if (!/^(.)\1+$/.test(cardNumber)) baseConfidence += 0.05; // Not all same digits
        
        return Math.min(baseConfidence + contextConfidence, 1.0);
    }
    
    /**
     * Validate expiration date
     */
    _isValidExpirationDate(dateString) {
        const [month, year] = dateString.split(/[\/\-]/);
        const expDate = new Date(2000 + parseInt(year), parseInt(month) - 1);
        const currentDate = new Date();
        
        return expDate > currentDate && parseInt(month) >= 1 && parseInt(month) <= 12;
    }
    
    /**
     * Check for card-related context
     */
    _hasCardContext(contextWindow) {
        const cardIndicators = ['card', 'payment', 'billing', 'transaction', 'checkout'];
        return cardIndicators.some(indicator => 
            contextWindow.toLowerCase().includes(indicator)
        );
    }
    
    /**
     * Get context window around detection
     */
    _getContextWindow(text, index, windowSize) {
        const start = Math.max(0, index - windowSize);
        const end = Math.min(text.length, index + windowSize);
        return text.substring(start, end);
    }
    
    /**
     * Generate unique detection ID
     */
    _generateDetectionId() {
        return crypto.randomBytes(8).toString('hex');
    }
    
    /**
     * Create protection session
     */
    _createProtectionSession() {
        return {
            id: crypto.randomBytes(16).toString('hex'),
            startTime: Date.now(),
            environment: process.env.NODE_ENV || 'development',
            source: 'credit-card-protector'
        };
    }
    
    /**
     * Trigger immediate security alert
     */
    async _triggerImmediateAlert(detections, session) {
        const alert = {
            type: 'PAYMENT_CARD_DATA_DETECTED',
            severity: 'CRITICAL',
            sessionId: session.id,
            detectionCount: detections.length,
            cardTypes: [...new Set(detections.map(d => d.cardType || d.type))],
            riskLevel: 'MAXIMUM',
            timestamp: new Date().toISOString(),
            environment: session.environment,
            requiresImmediateAction: true
        };
        
        await this.alertManager.triggerAlert(alert);
    }
    
    /**
     * Audit protection event for compliance
     */
    async _auditProtectionEvent(detections, session) {
        const auditEntry = {
            eventType: 'PAYMENT_CARD_DATA_PROTECTION',
            sessionId: session.id,
            timestamp: new Date().toISOString(),
            detectionCount: detections.length,
            detectionTypes: detections.map(d => ({
                type: d.type,
                cardType: d.cardType,
                riskLevel: d.riskLevel,
                confidence: d.confidence,
                detectionId: d.detectionId
            })),
            protectionMethods: ['tokenization', 'masking', 'removal'],
            complianceLevel: this.config.complianceLevel,
            environment: session.environment
        };
        
        this.auditLogger.critical('Payment card data protected', auditEntry);
    }
    
    /**
     * Handle critical protection errors
     */
    async _handleCriticalError(error, session) {
        const errorEvent = {
            eventType: 'PAYMENT_PROTECTION_FAILURE',
            sessionId: session.id,
            timestamp: new Date().toISOString(),
            error: error.message,
            stack: error.stack,
            severity: 'CRITICAL'
        };
        
        this.auditLogger.error('Payment protection failure', errorEvent);
        
        // Alert on protection failure
        await this.alertManager.triggerAlert({
            type: 'PAYMENT_PROTECTION_SYSTEM_FAILURE',
            severity: 'CRITICAL',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Extract text from various data types
     */
    _extractText(data) {
        if (typeof data === 'string') return data;
        if (typeof data === 'object') return JSON.stringify(data);
        return String(data);
    }
    
    /**
     * Reconstruct data with protected content
     */
    _reconstructData(originalData, protectedText) {
        if (typeof originalData === 'string') return protectedText;
        if (typeof originalData === 'object') {
            try {
                return JSON.parse(protectedText);
            } catch (error) {
                return protectedText;
            }
        }
        return protectedText;
    }
    
    /**
     * Create audit logger for compliance
     */
    _createAuditLogger() {
        return winston.createLogger({
            level: 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ 
                    filename: 'logs/pci-audit.log',
                    maxsize: 10485760,
                    maxFiles: 10
                })
            ]
        });
    }
    
    /**
     * Initialize performance monitoring
     */
    _initializeMonitoring() {
        return {
            totalProcessed: 0,
            cardDataDetected: 0,
            alertsTriggered: 0,
            avgProcessingTime: 0,
            startTime: Date.now()
        };
    }
    
    /**
     * Record protection metrics
     */
    _recordProtectionMetrics(session, processingTime, detections) {
        this.performanceMonitor.totalProcessed++;
        this.performanceMonitor.cardDataDetected++;
        this.performanceMonitor.avgProcessingTime = 
            (this.performanceMonitor.avgProcessingTime * (this.performanceMonitor.totalProcessed - 1) + processingTime) /
            this.performanceMonitor.totalProcessed;
    }
    
    /**
     * Record clean log processing
     */
    _recordCleanLog(session, processingTime) {
        this.performanceMonitor.totalProcessed++;
        this.performanceMonitor.avgProcessingTime = 
            (this.performanceMonitor.avgProcessingTime * (this.performanceMonitor.totalProcessed - 1) + processingTime) /
            this.performanceMonitor.totalProcessed;
    }
    
    /**
     * Get protection statistics
     */
    getStatistics() {
        return {
            ...this.performanceMonitor,
            uptime: Date.now() - this.performanceMonitor.startTime,
            detectionRate: this.performanceMonitor.totalProcessed > 0 ? 
                (this.performanceMonitor.cardDataDetected / this.performanceMonitor.totalProcessed * 100).toFixed(2) + '%' : '0%'
        };
    }
}

/**
 * Luhn Algorithm Validator for Credit Card Numbers
 */
class LuhnValidator {
    isValid(cardNumber) {
        const num = cardNumber.replace(/\D/g, '');
        
        if (num.length < 13 || num.length > 19) {
            return false;
        }
        
        let sum = 0;
        let isEven = false;
        
        for (let i = num.length - 1; i >= 0; i--) {
            let digit = parseInt(num.charAt(i), 10);
            
            if (isEven) {
                digit *= 2;
                if (digit > 9) {
                    digit -= 9;
                }
            }
            
            sum += digit;
            isEven = !isEven;
        }
        
        return sum % 10 === 0;
    }
}

/**
 * Secure Token Store for PCI Compliance
 */
class SecureTokenStore {
    constructor() {
        this.tokens = new Map();
        this.algorithm = 'aes-256-gcm';
        this.keyDerivation = 'pbkdf2';
    }
    
    async generateToken(cardNumber, metadata) {
        const tokenValue = crypto.randomBytes(16).toString('base64url');
        const encryptedData = await this._encryptData(cardNumber, metadata);
        
        this.tokens.set(tokenValue, {
            encrypted: encryptedData,
            created: new Date().toISOString(),
            accessed: 0,
            metadata: {
                cardType: metadata.cardType,
                sessionId: metadata.sessionId
            }
        });
        
        return tokenValue;
    }
    
    async _encryptData(data, metadata) {
        const key = await this._deriveKey();
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipher(this.algorithm, key);
        
        let encrypted = cipher.update(data, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        return {
            data: encrypted,
            iv: iv.toString('hex'),
            authTag: cipher.getAuthTag().toString('hex')
        };
    }
    
    async _deriveKey() {
        const password = process.env.PCI_ENCRYPTION_KEY || 'change-in-production';
        const salt = process.env.PCI_SALT || 'default-salt';
        
        return crypto.pbkdf2Sync(password, salt, 100000, 32, 'sha256');
    }
}

/**
 * PCI Alert Manager
 */
class PCIAlertManager {
    constructor() {
        this.alertHandlers = [];
        this.alertHistory = [];
    }
    
    async triggerAlert(alert) {
        alert.id = crypto.randomBytes(8).toString('hex');
        alert.triggeredAt = new Date().toISOString();
        
        this.alertHistory.push(alert);
        
        // Execute all alert handlers
        for (const handler of this.alertHandlers) {
            try {
                await handler(alert);
            } catch (error) {
                console.error('Alert handler failed:', error);
            }
        }
        
        // Log alert to audit trail
        console.error('PCI ALERT:', JSON.stringify(alert));
    }
    
    addAlertHandler(handler) {
        this.alertHandlers.push(handler);
    }
    
    getAlertHistory() {
        return this.alertHistory;
    }
}

module.exports = {
    CreditCardProtector,
    LuhnValidator,
    SecureTokenStore,
    PCIAlertManager
};
```

### Winston Integration for PCI Compliance

```javascript
const winston = require('winston');
const { CreditCardProtector } = require('./CreditCardProtector');

/**
 * PCI DSS Compliant Winston Format
 */
const pciComplianceFormat = (creditCardProtector) => {
    return winston.format((info) => {
        // Process all string fields for card data
        const processField = async (value) => {
            if (typeof value === 'string') {
                return await creditCardProtector.protectCardData(value);
            }
            return value;
        };
        
        // Protect message
        if (info.message) {
            info.message = creditCardProtector.protectCardData(info.message);
        }
        
        // Protect metadata recursively
        const protectObject = async (obj) => {
            for (const [key, value] of Object.entries(obj)) {
                if (typeof value === 'string') {
                    obj[key] = await processField(value);
                } else if (typeof value === 'object' && value !== null) {
                    await protectObject(value);
                }
            }
        };
        
        if (info.meta && typeof info.meta === 'object') {
            protectObject(info.meta);
        }
        
        return info;
    })();
};

/**
 * Create PCI DSS compliant logger
 */
function createPCICompliantLogger(options = {}) {
    const creditCardProtector = new CreditCardProtector({
        complianceLevel: 'strict',
        enableTokenization: true,
        auditLevel: 'comprehensive',
        alertOnDetection: true,
        ...options.pciConfig
    });
    
    return winston.createLogger({
        level: options.level || 'info',
        format: winston.format.combine(
            winston.format.timestamp(),
            pciComplianceFormat(creditCardProtector),
            winston.format.json()
        ),
        transports: [
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.simple()
                )
            }),
            new winston.transports.File({
                filename: 'logs/application.log',
                maxsize: 10485760,
                maxFiles: 10
            }),
            // Separate file for PCI audit logs
            new winston.transports.File({
                filename: 'logs/pci-compliance.log',
                level: 'warn',
                maxsize: 5242880,
                maxFiles: 20
            })
        ]
    });
}

module.exports = { createPCICompliantLogger };
```

### Payment Processing Integration

```javascript
const express = require('express');
const { createPCICompliantLogger } = require('./pci-compliant-logger');

const app = express();
const logger = createPCICompliantLogger();

/**
 * PCI DSS compliant payment processing middleware
 */
function pciComplianceMiddleware() {
    return (req, res, next) => {
        // Never log request body for payment endpoints
        if (req.path.includes('/payment') || req.path.includes('/checkout')) {
            const originalBody = req.body;
            
            // Create safe logging object
            const safeRequest = {
                method: req.method,
                path: req.path,
                userAgent: req.get('User-Agent'),
                ip: req.ip ? req.ip.replace(/\d+$/, 'xxx') : 'unknown',
                timestamp: new Date().toISOString(),
                hasPaymentData: !!(originalBody && (originalBody.cardNumber || originalBody.cvv)),
                contentLength: req.get('Content-Length') || 0
            };
            
            logger.info('Payment request received', safeRequest);
            
            // Override res.json to prevent accidental logging of response data
            const originalJson = res.json;
            res.json = function(data) {
                // Log success/failure without sensitive data
                logger.info('Payment response sent', {
                    statusCode: res.statusCode,
                    success: res.statusCode === 200,
                    responseSize: JSON.stringify(data).length,
                    timestamp: new Date().toISOString()
                });
                
                return originalJson.call(this, data);
            };
        }
        
        next();
    };
}

/**
 * Safe payment logging utility
 */
function logPaymentEvent(eventType, metadata = {}) {
    const safeMetadata = {
        eventType,
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV,
        ...metadata
    };
    
    // Remove any potential card data from metadata
    delete safeMetadata.cardNumber;
    delete safeMetadata.cvv;
    delete safeMetadata.expirationDate;
    delete safeMetadata.cardholderName;
    
    logger.info('Payment event', safeMetadata);
}

// Use PCI compliance middleware
app.use(pciComplianceMiddleware());

// Example payment endpoint
app.post('/api/payment/process', (req, res) => {
    try {
        // DON'T LOG: logger.info('Payment data', req.body); // NEVER!
        
        // DO LOG: Safe payment processing events
        logPaymentEvent('payment_initiated', {
            orderId: req.body.orderId,
            amount: req.body.amount,
            currency: req.body.currency,
            paymentMethod: req.body.paymentMethod // e.g., 'credit_card'
        });
        
        // Process payment (mock)
        const paymentResult = {
            success: true,
            transactionId: 'txn_123456',
            status: 'completed'
        };
        
        logPaymentEvent('payment_completed', {
            orderId: req.body.orderId,
            transactionId: paymentResult.transactionId,
            status: paymentResult.status
        });
        
        res.json(paymentResult);
        
    } catch (error) {
        logPaymentEvent('payment_failed', {
            orderId: req.body.orderId,
            error: error.message,
            errorCode: error.code
        });
        
        res.status(500).json({ error: 'Payment processing failed' });
    }
});

module.exports = app;
```

## PCI DSS Compliance Checklist

### Data Protection Requirements
✅ **Never log full PAN** - Complete card numbers are never stored in logs  
✅ **Mask when necessary** - Only first 6 and last 4 digits shown  
✅ **Remove CVV completely** - Card verification values never logged  
✅ **Protect expiration dates** - Masked or removed from logs  
✅ **Secure magnetic stripe data** - Track data completely removed  

### Access Control
✅ **Restricted log access** - Only authorized personnel can view logs  
✅ **Audit access attempts** - All log access is monitored  
✅ **Role-based permissions** - Different access levels for different roles  
✅ **Regular access reviews** - Periodic validation of access rights  

### Monitoring & Alerting
✅ **Real-time detection** - Immediate alerts on card data detection  
✅ **Comprehensive auditing** - All protection events logged  
✅ **Compliance reporting** - Regular PCI DSS compliance reports  
✅ **Incident response** - Procedures for security incidents  

### Technical Safeguards
✅ **Encryption at rest** - Log files encrypted on storage  
✅ **Encryption in transit** - Secure transmission of logs  
✅ **Tokenization support** - Secure token generation and management  
✅ **Secure key management** - Proper encryption key handling  

## Best Practices Summary

1. **Zero Tolerance Policy**: Never log any payment card data
2. **Immediate Detection**: Real-time scanning and protection
3. **Comprehensive Auditing**: Complete audit trails for compliance
4. **Regular Testing**: Periodic validation of protection mechanisms
5. **Team Training**: Ensure all developers understand PCI requirements
6. **Incident Response**: Clear procedures for data exposure incidents

Payment card data protection is legally mandated and business-critical. Any exposure can result in severe financial penalties and loss of payment processing privileges.
