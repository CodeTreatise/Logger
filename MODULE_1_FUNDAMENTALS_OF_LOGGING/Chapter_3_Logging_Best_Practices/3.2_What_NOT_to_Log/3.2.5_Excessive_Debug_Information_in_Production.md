# 3.2.5 Excessive Debug Information in Production

## Overview

Excessive debug information in production environments represents one of the most common yet overlooked logging anti-patterns. While debug logs are invaluable during development, they can severely impact production performance, expose sensitive internal details, consume massive storage, and make troubleshooting more difficult by burying critical information in noise. This section provides comprehensive strategies for managing debug information across different environments.

## Understanding Debug Information Challenges

### Performance Impact
- **CPU Overhead**: Debug logging consumes significant processing power
- **Memory Pressure**: Verbose logging increases memory usage and garbage collection
- **I/O Bottlenecks**: Excessive writes slow down disk and network operations
- **Serialization Costs**: Converting complex objects to log format is expensive
- **Network Latency**: Large log volumes saturate network bandwidth

### Storage and Cost Issues
- **Exponential Growth**: Debug logs can grow from MB to TB rapidly
- **Storage Costs**: Cloud storage costs increase dramatically with volume
- **Retention Complexity**: Managing retention policies becomes challenging
- **Backup Overhead**: Large log volumes slow backup and recovery operations
- **Index Performance**: Search and analysis tools struggle with excessive data

### Security and Privacy Risks
- **Internal Exposure**: Debug logs often contain implementation details
- **Data Leakage**: Verbose logging may accidentally expose sensitive data
- **Attack Surface**: Detailed logs provide information to potential attackers
- **Compliance Issues**: Excessive logging may violate data protection regulations
- **Audit Complexity**: Finding relevant information becomes difficult

## Production Debug Management System

### Intelligent Debug Filter

```javascript
const winston = require('winston');
const crypto = require('crypto');

/**
 * Production-Optimized Debug Management System
 * Provides intelligent filtering, sampling, and environment-aware debug logging
 */
class ProductionDebugManager {
    constructor(options = {}) {
        this.config = {
            // Environment settings
            environment: options.environment || process.env.NODE_ENV || 'development',
            
            // Debug control
            productionDebugEnabled: options.productionDebugEnabled || false,
            debugSamplingRate: options.debugSamplingRate || 0.01, // 1% sampling
            emergencyDebugMode: options.emergencyDebugMode || false,
            
            // Performance thresholds
            maxDebugEntriesPerMinute: options.maxDebugEntriesPerMinute || 100,
            maxDebugMessageSize: options.maxDebugMessageSize || 1000,
            performanceThreshold: options.performanceThreshold || 10, // ms
            
            // Content filtering
            enableIntelligentFiltering: options.enableIntelligentFiltering || true,
            sensitiveDataPatterns: options.sensitiveDataPatterns || [],
            allowedDebugCategories: options.allowedDebugCategories || [],
            blockedDebugCategories: options.blockedDebugCategories || [],
            
            // Storage optimization
            enableCompression: options.enableCompression || true,
            enableBatching: options.enableBatching || true,
            batchSize: options.batchSize || 50,
            
            // Monitoring
            enableMetrics: options.enableMetrics || true,
            alertOnExcessiveDebug: options.alertOnExcessiveDebug || true
        };
        
        this.debugPatterns = this._buildDebugPatterns();
        this.rateLimiter = new DebugRateLimiter(this.config);
        this.contentAnalyzer = new DebugContentAnalyzer(this.config);
        this.performanceMonitor = new DebugPerformanceMonitor();
        this.metrics = this._initializeMetrics();
        this.emergencyModeTimeout = null;
    }
    
    /**
     * Build patterns for debug content classification
     */
    _buildDebugPatterns() {
        return {
            // High-value debug information
            highValue: {
                patterns: [
                    /error/i, /exception/i, /failure/i, /timeout/i,
                    /retry/i, /fallback/i, /circuit\s*breaker/i,
                    /rate\s*limit/i, /throttle/i, /quota/i
                ],
                priority: 'HIGH',
                productionRelevance: 0.9
            },
            
            // Medium-value debug information
            mediumValue: {
                patterns: [
                    /performance/i, /slow/i, /latency/i,
                    /cache/i, /optimization/i, /memory/i,
                    /connection/i, /pool/i, /queue/i
                ],
                priority: 'MEDIUM',
                productionRelevance: 0.6
            },
            
            // Low-value debug information
            lowValue: {
                patterns: [
                    /step/i, /entering/i, /leaving/i, /processing/i,
                    /iteration/i, /loop/i, /counter/i,
                    /variable/i, /parameter/i, /argument/i
                ],
                priority: 'LOW',
                productionRelevance: 0.2
            },
            
            // Development-only patterns
            developmentOnly: {
                patterns: [
                    /todo/i, /fixme/i, /hack/i, /temp/i,
                    /debug\s*print/i, /console\.log/i, /trace/i,
                    /dump/i, /inspect/i, /dev\s*mode/i
                ],
                priority: 'DEV_ONLY',
                productionRelevance: 0.0
            },
            
            // Potentially sensitive patterns
            sensitive: {
                patterns: [
                    /password/i, /token/i, /key/i, /secret/i,
                    /credential/i, /auth/i, /session/i,
                    /private/i, /internal/i, /config/i
                ],
                priority: 'SENSITIVE',
                productionRelevance: 0.0,
                action: 'BLOCK'
            }
        };
    }
    
    /**
     * Main debug processing method
     */
    async processDebugLog(logInfo) {
        const startTime = Date.now();
        
        try {
            // Quick environment check
            if (!this._shouldProcessDebug(logInfo)) {
                this._recordFilteredLog('ENVIRONMENT_FILTER');
                return null; // Filtered out
            }
            
            // Rate limiting check
            if (!this.rateLimiter.allowDebugLog()) {
                this._recordFilteredLog('RATE_LIMITED');
                return null;
            }
            
            // Content analysis
            const analysis = await this.contentAnalyzer.analyzeDebugContent(logInfo);
            
            // Apply filtering rules
            const filterDecision = this._applyFilteringRules(analysis);
            
            if (filterDecision.action === 'BLOCK') {
                this._recordFilteredLog('CONTENT_BLOCKED', filterDecision.reason);
                return null;
            }
            
            // Apply optimizations
            const optimizedLog = await this._optimizeDebugLog(logInfo, analysis, filterDecision);
            
            // Record processing metrics
            this._recordProcessingMetrics(startTime, analysis, filterDecision);
            
            return optimizedLog;
            
        } catch (error) {
            this._handleProcessingError(error, logInfo);
            return null;
        }
    }
    
    /**
     * Determine if debug log should be processed
     */
    _shouldProcessDebug(logInfo) {
        // Always allow in development
        if (this.config.environment === 'development') {
            return true;
        }
        
        // Emergency debug mode overrides everything
        if (this.config.emergencyDebugMode) {
            return true;
        }
        
        // Production debug explicitly enabled
        if (this.config.productionDebugEnabled) {
            // Apply sampling
            return Math.random() < this.config.debugSamplingRate;
        }
        
        // Default: block debug in production
        return false;
    }
    
    /**
     * Apply content-based filtering rules
     */
    _applyFilteringRules(analysis) {
        const decision = {
            action: 'ALLOW',
            reason: null,
            optimizations: [],
            priority: analysis.priority
        };
        
        // Block sensitive content
        if (analysis.containsSensitiveData) {
            decision.action = 'BLOCK';
            decision.reason = 'SENSITIVE_DATA_DETECTED';
            return decision;
        }
        
        // Block development-only content in production
        if (this.config.environment === 'production' && 
            analysis.category === 'developmentOnly') {
            decision.action = 'BLOCK';
            decision.reason = 'DEVELOPMENT_ONLY_CONTENT';
            return decision;
        }
        
        // Block low-value content in production unless emergency mode
        if (this.config.environment === 'production' && 
            !this.config.emergencyDebugMode &&
            analysis.priority === 'LOW') {
            decision.action = 'BLOCK';
            decision.reason = 'LOW_PRIORITY_IN_PRODUCTION';
            return decision;
        }
        
        // Apply category filtering
        if (this.config.allowedDebugCategories.length > 0 &&
            !this.config.allowedDebugCategories.includes(analysis.category)) {
            decision.action = 'BLOCK';
            decision.reason = 'CATEGORY_NOT_ALLOWED';
            return decision;
        }
        
        if (this.config.blockedDebugCategories.includes(analysis.category)) {
            decision.action = 'BLOCK';
            decision.reason = 'CATEGORY_BLOCKED';
            return decision;
        }
        
        // Suggest optimizations based on content
        this._suggestOptimizations(analysis, decision);
        
        return decision;
    }
    
    /**
     * Suggest optimizations for allowed debug logs
     */
    _suggestOptimizations(analysis, decision) {
        // Compress large messages
        if (analysis.messageSize > this.config.maxDebugMessageSize) {
            decision.optimizations.push('COMPRESS');
        }
        
        // Batch low-priority messages
        if (analysis.priority === 'LOW' || analysis.priority === 'MEDIUM') {
            decision.optimizations.push('BATCH');
        }
        
        // Truncate verbose object dumps
        if (analysis.hasLargeObjects) {
            decision.optimizations.push('TRUNCATE_OBJECTS');
        }
        
        // Sample repetitive messages
        if (analysis.isRepetitive) {
            decision.optimizations.push('SAMPLE');
        }
    }
    
    /**
     * Optimize debug log based on analysis and decision
     */
    async _optimizeDebugLog(logInfo, analysis, decision) {
        let optimizedLog = { ...logInfo };
        
        for (const optimization of decision.optimizations) {
            switch (optimization) {
                case 'COMPRESS':
                    optimizedLog = await this._compressDebugLog(optimizedLog);
                    break;
                case 'TRUNCATE_OBJECTS':
                    optimizedLog = this._truncateObjects(optimizedLog);
                    break;
                case 'SAMPLE':
                    if (!this._shouldSampleMessage(optimizedLog)) {
                        return null; // Skip this instance
                    }
                    break;
                case 'BATCH':
                    // Batching would be handled at transport level
                    optimizedLog._batchable = true;
                    break;
            }
        }
        
        // Add debug metadata
        optimizedLog._debugInfo = {
            filtered: true,
            priority: analysis.priority,
            category: analysis.category,
            optimizations: decision.optimizations,
            environment: this.config.environment,
            timestamp: new Date().toISOString()
        };
        
        return optimizedLog;
    }
    
    /**
     * Compress debug log content
     */
    async _compressDebugLog(logInfo) {
        if (!this.config.enableCompression) return logInfo;
        
        const compressed = { ...logInfo };
        
        if (typeof compressed.message === 'string' && compressed.message.length > 500) {
            const originalLength = compressed.message.length;
            compressed.message = compressed.message.substring(0, 200) + 
                               '...[TRUNCATED]...' + 
                               compressed.message.substring(compressed.message.length - 100);
            compressed._truncated = {
                original: originalLength,
                current: compressed.message.length
            };
        }
        
        return compressed;
    }
    
    /**
     * Truncate large objects in debug logs
     */
    _truncateObjects(logInfo) {
        const truncated = { ...logInfo };
        
        const truncateObject = (obj, depth = 0, maxDepth = 3) => {
            if (depth > maxDepth) return '[MAX_DEPTH_REACHED]';
            if (obj === null || typeof obj !== 'object') return obj;
            if (Array.isArray(obj)) {
                return obj.length > 10 ? 
                    [...obj.slice(0, 10), `[...${obj.length - 10} more items]`] : 
                    obj.map(item => truncateObject(item, depth + 1, maxDepth));
            }
            
            const result = {};
            const keys = Object.keys(obj);
            
            if (keys.length > 20) {
                // Truncate to first 20 keys
                for (let i = 0; i < 20; i++) {
                    result[keys[i]] = truncateObject(obj[keys[i]], depth + 1, maxDepth);
                }
                result['...'] = `[${keys.length - 20} more properties]`;
            } else {
                for (const key of keys) {
                    result[key] = truncateObject(obj[key], depth + 1, maxDepth);
                }
            }
            
            return result;
        };
        
        if (truncated.meta && typeof truncated.meta === 'object') {
            truncated.meta = truncateObject(truncated.meta);
        }
        
        return truncated;
    }
    
    /**
     * Determine if repetitive message should be sampled
     */
    _shouldSampleMessage(logInfo) {
        const messageHash = crypto.createHash('md5')
            .update(logInfo.message || '')
            .digest('hex');
        
        // Simple sampling based on hash
        return parseInt(messageHash.substring(0, 2), 16) < 25; // ~10% sampling
    }
    
    /**
     * Enable emergency debug mode temporarily
     */
    enableEmergencyDebugMode(durationMs = 300000) { // 5 minutes default
        this.config.emergencyDebugMode = true;
        
        console.warn('EMERGENCY DEBUG MODE ENABLED', {
            duration: `${durationMs / 1000}s`,
            timestamp: new Date().toISOString(),
            environment: this.config.environment
        });
        
        // Auto-disable after duration
        if (this.emergencyModeTimeout) {
            clearTimeout(this.emergencyModeTimeout);
        }
        
        this.emergencyModeTimeout = setTimeout(() => {
            this.disableEmergencyDebugMode();
        }, durationMs);
    }
    
    /**
     * Disable emergency debug mode
     */
    disableEmergencyDebugMode() {
        this.config.emergencyDebugMode = false;
        
        if (this.emergencyModeTimeout) {
            clearTimeout(this.emergencyModeTimeout);
            this.emergencyModeTimeout = null;
        }
        
        console.warn('EMERGENCY DEBUG MODE DISABLED', {
            timestamp: new Date().toISOString(),
            environment: this.config.environment
        });
    }
    
    /**
     * Record filtered log metrics
     */
    _recordFilteredLog(reason, details = null) {
        this.metrics.totalFiltered++;
        this.metrics.filterReasons[reason] = (this.metrics.filterReasons[reason] || 0) + 1;
        
        if (details) {
            this.metrics.filterDetails[reason] = details;
        }
    }
    
    /**
     * Record processing metrics
     */
    _recordProcessingMetrics(startTime, analysis, decision) {
        const processingTime = Date.now() - startTime;
        
        this.metrics.totalProcessed++;
        this.metrics.totalAllowed++;
        this.metrics.avgProcessingTime = 
            (this.metrics.avgProcessingTime * (this.metrics.totalProcessed - 1) + processingTime) /
            this.metrics.totalProcessed;
        
        // Track by priority
        this.metrics.byPriority[analysis.priority] = 
            (this.metrics.byPriority[analysis.priority] || 0) + 1;
        
        // Track optimizations
        decision.optimizations.forEach(opt => {
            this.metrics.optimizations[opt] = (this.metrics.optimizations[opt] || 0) + 1;
        });
    }
    
    /**
     * Handle processing errors
     */
    _handleProcessingError(error, logInfo) {
        this.metrics.processingErrors++;
        
        console.error('Debug processing error:', {
            error: error.message,
            logLevel: logInfo.level,
            environment: this.config.environment,
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Initialize metrics tracking
     */
    _initializeMetrics() {
        return {
            totalProcessed: 0,
            totalFiltered: 0,
            totalAllowed: 0,
            processingErrors: 0,
            avgProcessingTime: 0,
            filterReasons: {},
            filterDetails: {},
            byPriority: {},
            optimizations: {},
            startTime: Date.now()
        };
    }
    
    /**
     * Get comprehensive statistics
     */
    getStatistics() {
        const uptime = Date.now() - this.metrics.startTime;
        const total = this.metrics.totalProcessed + this.metrics.totalFiltered;
        
        return {
            ...this.metrics,
            uptime: `${Math.round(uptime / 1000)}s`,
            filterRate: total > 0 ? `${(this.metrics.totalFiltered / total * 100).toFixed(2)}%` : '0%',
            allowRate: total > 0 ? `${(this.metrics.totalAllowed / total * 100).toFixed(2)}%` : '0%',
            emergencyMode: this.config.emergencyDebugMode,
            environment: this.config.environment,
            debugEnabled: this.config.productionDebugEnabled,
            samplingRate: `${(this.config.debugSamplingRate * 100).toFixed(2)}%`
        };
    }
}

/**
 * Rate limiter for debug logs
 */
class DebugRateLimiter {
    constructor(config) {
        this.config = config;
        this.windowStart = Date.now();
        this.windowCount = 0;
        this.windowDuration = 60000; // 1 minute
    }
    
    allowDebugLog() {
        const now = Date.now();
        
        // Reset window if expired
        if (now - this.windowStart > this.windowDuration) {
            this.windowStart = now;
            this.windowCount = 0;
        }
        
        // Check if under limit
        if (this.windowCount < this.config.maxDebugEntriesPerMinute) {
            this.windowCount++;
            return true;
        }
        
        return false;
    }
}

/**
 * Content analyzer for debug messages
 */
class DebugContentAnalyzer {
    constructor(config) {
        this.config = config;
        this.patterns = this._buildPatterns();
    }
    
    _buildPatterns() {
        return {
            sensitive: /password|token|key|secret|credential|auth|session|private/i,
            performance: /slow|latency|timeout|performance|memory|cpu/i,
            error: /error|exception|failure|crash|panic/i,
            repetitive: /step|iteration|loop|counter|processing/i,
            largeObject: /\{[\s\S]{500,}\}|\[[\s\S]{500,}\]/
        };
    }
    
    async analyzeDebugContent(logInfo) {
        const message = logInfo.message || '';
        const messageSize = message.length;
        
        const analysis = {
            messageSize,
            containsSensitiveData: this.patterns.sensitive.test(message),
            hasPerformanceInfo: this.patterns.performance.test(message),
            hasErrorInfo: this.patterns.error.test(message),
            isRepetitive: this.patterns.repetitive.test(message),
            hasLargeObjects: this.patterns.largeObject.test(message),
            category: 'general',
            priority: 'MEDIUM'
        };
        
        // Determine category and priority
        if (analysis.containsSensitiveData) {
            analysis.category = 'sensitive';
            analysis.priority = 'HIGH'; // High priority to block
        } else if (analysis.hasErrorInfo) {
            analysis.category = 'error';
            analysis.priority = 'HIGH';
        } else if (analysis.hasPerformanceInfo) {
            analysis.category = 'performance';
            analysis.priority = 'MEDIUM';
        } else if (analysis.isRepetitive) {
            analysis.category = 'repetitive';
            analysis.priority = 'LOW';
        }
        
        return analysis;
    }
}

/**
 * Performance monitor for debug processing
 */
class DebugPerformanceMonitor {
    constructor() {
        this.measurements = [];
        this.alertThresholds = {
            processingTime: 50, // ms
            memoryIncrease: 10 * 1024 * 1024 // 10MB
        };
    }
    
    recordMeasurement(processingTime, logSize) {
        const measurement = {
            timestamp: Date.now(),
            processingTime,
            logSize,
            memoryUsage: process.memoryUsage().heapUsed
        };
        
        this.measurements.push(measurement);
        
        // Keep only recent measurements
        if (this.measurements.length > 1000) {
            this.measurements = this.measurements.slice(-1000);
        }
        
        this._checkPerformanceAlerts(measurement);
    }
    
    _checkPerformanceAlerts(current) {
        if (current.processingTime > this.alertThresholds.processingTime) {
            console.warn('Slow debug processing detected', {
                processingTime: `${current.processingTime}ms`,
                logSize: current.logSize,
                timestamp: new Date().toISOString()
            });
        }
    }
    
    getPerformanceStats() {
        if (this.measurements.length === 0) return null;
        
        const recent = this.measurements.slice(-100); // Last 100 measurements
        const avgProcessingTime = recent.reduce((sum, m) => sum + m.processingTime, 0) / recent.length;
        const maxProcessingTime = Math.max(...recent.map(m => m.processingTime));
        
        return {
            averageProcessingTime: `${avgProcessingTime.toFixed(2)}ms`,
            maxProcessingTime: `${maxProcessingTime}ms`,
            measurementCount: this.measurements.length
        };
    }
}

module.exports = {
    ProductionDebugManager,
    DebugRateLimiter,
    DebugContentAnalyzer,
    DebugPerformanceMonitor
};
```

### Winston Integration for Production Debug Management

```javascript
const winston = require('winston');
const { ProductionDebugManager } = require('./ProductionDebugManager');

/**
 * Production-aware debug format
 */
const productionDebugFormat = (debugManager) => {
    return winston.format((info) => {
        // Only process debug level logs
        if (info.level !== 'debug') {
            return info;
        }
        
        // Process through debug manager
        const processedLog = debugManager.processDebugLog(info);
        
        // Return null to filter out, or processed log
        return processedLog;
    })();
};

/**
 * Environment-aware logger factory
 */
function createProductionAwareLogger(options = {}) {
    const environment = options.environment || process.env.NODE_ENV || 'development';
    
    const debugManager = new ProductionDebugManager({
        environment,
        productionDebugEnabled: options.productionDebugEnabled || false,
        debugSamplingRate: options.debugSamplingRate || 0.01,
        maxDebugEntriesPerMinute: options.maxDebugEntriesPerMinute || 100,
        enableIntelligentFiltering: true,
        ...options.debugConfig
    });
    
    // Environment-specific log levels
    const logLevel = environment === 'production' ? 'info' : 'debug';
    
    const transports = [];
    
    // Console transport (always present)
    transports.push(new winston.transports.Console({
        level: logLevel,
        format: winston.format.combine(
            winston.format.colorize(),
            winston.format.timestamp(),
            winston.format.printf(({ timestamp, level, message, ...meta }) => {
                const metaStr = Object.keys(meta).length ? JSON.stringify(meta, null, 2) : '';
                return `${timestamp} [${level}]: ${message} ${metaStr}`;
            })
        )
    }));
    
    // File transports based on environment
    if (environment === 'production') {
        // Production: Separate files, no debug file
        transports.push(
            new winston.transports.File({
                filename: 'logs/app.log',
                level: 'info',
                maxsize: 10485760,
                maxFiles: 10,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            }),
            new winston.transports.File({
                filename: 'logs/error.log',
                level: 'error',
                maxsize: 10485760,
                maxFiles: 10,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            })
        );
        
        // Emergency debug file (only when emergency mode is enabled)
        if (options.enableEmergencyDebugFile) {
            transports.push(new winston.transports.File({
                filename: 'logs/emergency-debug.log',
                level: 'debug',
                maxsize: 52428800, // 50MB
                maxFiles: 3,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            }));
        }
    } else {
        // Development: Include debug file
        transports.push(
            new winston.transports.File({
                filename: 'logs/app.log',
                level: 'debug',
                maxsize: 10485760,
                maxFiles: 5,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            }),
            new winston.transports.File({
                filename: 'logs/debug.log',
                level: 'debug',
                maxsize: 10485760,
                maxFiles: 3,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            })
        );
    }
    
    const logger = winston.createLogger({
        level: logLevel,
        format: winston.format.combine(
            winston.format.timestamp(),
            productionDebugFormat(debugManager),
            winston.format.json()
        ),
        transports
    });
    
    // Add debug manager methods to logger
    logger.enableEmergencyDebug = (duration) => debugManager.enableEmergencyDebugMode(duration);
    logger.disableEmergencyDebug = () => debugManager.disableEmergencyDebugMode();
    logger.getDebugStats = () => debugManager.getStatistics();
    
    return logger;
}

module.exports = { createProductionAwareLogger };
```

### Express.js Integration with Smart Debug Management

```javascript
const express = require('express');
const { createProductionAwareLogger } = require('./production-aware-logger');

const app = express();
const logger = createProductionAwareLogger({
    environment: process.env.NODE_ENV,
    productionDebugEnabled: process.env.PRODUCTION_DEBUG_ENABLED === 'true',
    debugSamplingRate: parseFloat(process.env.DEBUG_SAMPLING_RATE) || 0.01
});

/**
 * Smart debug middleware with environment awareness
 */
function smartDebugMiddleware() {
    return (req, res, next) => {
        const isProduction = process.env.NODE_ENV === 'production';
        
        // Development: Full debug logging
        if (!isProduction) {
            logger.debug('Request received', {
                method: req.method,
                url: req.url,
                headers: req.headers,
                query: req.query,
                body: req.body,
                ip: req.ip,
                userAgent: req.get('User-Agent')
            });
        } else {
            // Production: Minimal debug logging
            logger.debug('Request processed', {
                method: req.method,
                path: req.path, // No query params
                statusCode: res.statusCode,
                responseTime: res.responseTime,
                userAgent: req.get('User-Agent')?.substring(0, 50) // Truncated
            });
        }
        
        next();
    };
}

/**
 * Conditional debug logging utility
 */
function conditionalDebug(category, message, metadata = {}) {
    const isProduction = process.env.NODE_ENV === 'production';
    
    // Define production-relevant debug categories
    const productionRelevantCategories = [
        'performance', 'error', 'security', 'business', 'external_service'
    ];
    
    if (!isProduction) {
        // Development: Log everything
        logger.debug(`[${category}] ${message}`, metadata);
    } else if (productionRelevantCategories.includes(category)) {
        // Production: Only log relevant categories
        logger.debug(`[${category}] ${message}`, metadata);
    }
    // Otherwise: Skip debug logging in production
}

/**
 * Performance-aware debug decorator
 */
function debugPerformance(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args) {
        const start = Date.now();
        const isProduction = process.env.NODE_ENV === 'production';
        
        if (!isProduction) {
            logger.debug(`Method ${propertyKey} started`, {
                className: target.constructor.name,
                arguments: args.length,
                timestamp: new Date().toISOString()
            });
        }
        
        try {
            const result = originalMethod.apply(this, args);
            const duration = Date.now() - start;
            
            // Only log performance in production if it's slow
            if (isProduction && duration > 100) {
                logger.debug(`Slow method execution`, {
                    method: propertyKey,
                    duration: `${duration}ms`,
                    threshold: '100ms'
                });
            } else if (!isProduction) {
                logger.debug(`Method ${propertyKey} completed`, {
                    duration: `${duration}ms`,
                    className: target.constructor.name
                });
            }
            
            return result;
        } catch (error) {
            const duration = Date.now() - start;
            
            // Always log errors with context
            logger.debug(`Method ${propertyKey} failed`, {
                error: error.message,
                duration: `${duration}ms`,
                className: target.constructor.name
            });
            
            throw error;
        }
    };
    
    return descriptor;
}

// Use smart debug middleware
app.use(smartDebugMiddleware());

// Example business logic with conditional debug logging
app.get('/api/users/:id', async (req, res) => {
    try {
        conditionalDebug('business', 'User lookup initiated', {
            userId: req.params.id,
            requestId: req.headers['x-request-id']
        });
        
        // Simulate user lookup
        const user = await findUser(req.params.id);
        
        if (!user) {
            conditionalDebug('business', 'User not found', {
                userId: req.params.id,
                searchAttempted: true
            });
            
            return res.status(404).json({ error: 'User not found' });
        }
        
        conditionalDebug('performance', 'User lookup completed', {
            userId: req.params.id,
            userActive: user.active,
            cacheHit: user.fromCache
        });
        
        res.json(user);
        
    } catch (error) {
        conditionalDebug('error', 'User lookup failed', {
            userId: req.params.id,
            error: error.message,
            stack: error.stack
        });
        
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Emergency debug endpoint (admin only)
app.post('/admin/debug/emergency', (req, res) => {
    const { duration = 300000, action } = req.body; // 5 minutes default
    
    if (action === 'enable') {
        logger.enableEmergencyDebug(duration);
        logger.warn('Emergency debug mode enabled via API', {
            duration: `${duration / 1000}s`,
            requester: req.ip,
            timestamp: new Date().toISOString()
        });
        
        res.json({ 
            success: true, 
            message: `Emergency debug enabled for ${duration / 1000}s` 
        });
    } else if (action === 'disable') {
        logger.disableEmergencyDebug();
        logger.warn('Emergency debug mode disabled via API', {
            requester: req.ip,
            timestamp: new Date().toISOString()
        });
        
        res.json({ 
            success: true, 
            message: 'Emergency debug disabled' 
        });
    } else {
        res.status(400).json({ error: 'Invalid action' });
    }
});

// Debug statistics endpoint
app.get('/admin/debug/stats', (req, res) => {
    const stats = logger.getDebugStats();
    res.json(stats);
});

async function findUser(id) {
    // Simulate user lookup with debug information
    conditionalDebug('performance', 'Database query initiated', {
        query: 'SELECT * FROM users WHERE id = ?',
        parameters: [id]
    });
    
    // Simulate async operation
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({
                id,
                name: `User ${id}`,
                active: true,
                fromCache: Math.random() > 0.5
            });
        }, Math.random() * 100);
    });
}

module.exports = app;
```

## Environment-Specific Debug Strategies

### Development Environment
```javascript
// Development: Full debug logging enabled
const developmentConfig = {
    level: 'debug',
    debugCategories: ['all'],
    enableVerboseLogging: true,
    logObjectDepth: 5,
    enableStackTraces: true,
    enablePerformanceLogging: true
};
```

### Staging Environment
```javascript
// Staging: Selective debug logging
const stagingConfig = {
    level: 'info',
    debugCategories: ['performance', 'error', 'business'],
    debugSamplingRate: 0.1, // 10% sampling
    enableVerboseLogging: false,
    logObjectDepth: 2,
    enableStackTraces: true
};
```

### Production Environment
```javascript
// Production: Minimal debug logging
const productionConfig = {
    level: 'warn',
    debugCategories: ['error', 'security'],
    debugSamplingRate: 0.01, // 1% sampling
    enableVerboseLogging: false,
    logObjectDepth: 1,
    enableStackTraces: false,
    emergencyDebugAvailable: true
};
```

## Best Practices Summary

### ✅ **DO: Smart Debug Management**
- **Environment-aware logging**: Different levels per environment
- **Intelligent filtering**: Content-based debug filtering
- **Rate limiting**: Prevent debug log flooding
- **Emergency mode**: Temporary debug enabling in production
- **Performance monitoring**: Track debug logging overhead

### ❌ **DON'T: Debug Anti-patterns**
- **Never** enable full debug logging in production
- **Avoid** logging sensitive data in debug messages
- **Don't** log in tight loops without rate limiting
- **Skip** verbose object dumps in production
- **Prevent** debug information exposure to end users

### 🚀 **Optimization Strategies**
- **Sampling**: Only log subset of debug messages
- **Batching**: Group debug messages for efficiency
- **Compression**: Reduce debug message size
- **Truncation**: Limit object depth and size
- **Categorization**: Filter by debug category relevance

### 📊 **Monitoring & Control**
- **Metrics tracking**: Monitor debug logging volume and performance
- **Dynamic control**: Runtime debug level adjustment
- **Emergency access**: Temporary debug enabling for troubleshooting
- **Cost monitoring**: Track storage and performance costs
- **Automated cleanup**: Remove old debug logs

Production debug management is crucial for maintaining application performance while preserving troubleshooting capabilities when needed.

🎉 **Congratulations!** You have successfully completed **Section 3.2 "What NOT to Log"** with all 5 comprehensive subsections:

1. ✅ **3.2.1 Sensitive Data (Passwords, API Keys)**
2. ✅ **3.2.2 Personal Identifiable Information (PII)**  
3. ✅ **3.2.3 Credit Card Information**
4. ✅ **3.2.4 Large Binary Data**
5. ✅ **3.2.5 Excessive Debug Information in Production**

Each section provides enterprise-grade implementations with security, performance, and compliance considerations!
