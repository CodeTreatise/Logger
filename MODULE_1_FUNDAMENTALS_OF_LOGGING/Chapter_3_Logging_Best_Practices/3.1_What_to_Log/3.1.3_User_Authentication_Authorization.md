# 3.1.3 User Authentication/Authorization

## Understanding Authentication and Authorization Logging

Authentication and authorization events are critical security touchpoints that require comprehensive logging for security monitoring, compliance, fraud detection, and incident investigation. These logs provide essential visibility into who is accessing your system, what they're trying to do, and whether their actions are authorized.

## Why Log Authentication/Authorization Events?

### **Security Benefits**
- **Threat Detection**: Identify suspicious login patterns, brute force attacks, and unauthorized access attempts
- **Incident Response**: Provide detailed audit trails for security incident investigation
- **Fraud Prevention**: Detect account takeovers, credential stuffing, and unusual access patterns
- **Access Monitoring**: Track privileged access and administrative actions
- **Breach Investigation**: Understand the scope and timeline of security incidents

### **Compliance Benefits**
- **Regulatory Requirements**: Meet logging requirements for GDPR, SOX, HIPAA, PCI DSS
- **Audit Trails**: Provide detailed records for internal and external audits
- **Data Protection**: Monitor access to sensitive data and systems
- **Change Tracking**: Log authorization changes and privilege escalations

## Advanced Authentication/Authorization Logger

### 1. **Comprehensive Security Event Logging System**

```javascript
// Advanced authentication and authorization logging system
const { EventEmitter } = require('events');
const crypto = require('crypto');

class AuthenticationAuthorizationLogger extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      applicationName: options.applicationName || process.env.APP_NAME || 'unknown-app',
      version: options.version || process.env.APP_VERSION || '1.0.0',
      environment: options.environment || process.env.NODE_ENV || 'development',
      instanceId: options.instanceId || this.generateInstanceId(),
      
      // Authentication logging options
      logSuccessfulLogins: options.logSuccessfulLogins !== false,
      logFailedLogins: options.logFailedLogins !== false,
      logLogouts: options.logLogouts !== false,
      logPasswordChanges: options.logPasswordChanges !== false,
      logAccountLocking: options.logAccountLocking !== false,
      logMfaEvents: options.logMfaEvents !== false,
      
      // Authorization logging options
      logAccessGranted: options.logAccessGranted !== false,
      logAccessDenied: options.logAccessDenied !== false,
      logPrivilegeEscalation: options.logPrivilegeEscalation !== false,
      logRoleChanges: options.logRoleChanges !== false,
      logPermissionChanges: options.logPermissionChanges !== false,
      
      // Session management
      logSessionCreation: options.logSessionCreation !== false,
      logSessionExpiration: options.logSessionExpiration !== false,
      logSessionTermination: options.logSessionTermination !== false,
      logConcurrentSessions: options.logConcurrentSessions !== false,
      
      // Security features
      trackFailedAttempts: options.trackFailedAttempts !== false,
      failedAttemptThreshold: options.failedAttemptThreshold || 5,
      failedAttemptWindow: options.failedAttemptWindow || 900000, // 15 minutes
      detectAnomalies: options.detectAnomalies !== false,
      
      // Data protection
      hashUserIds: options.hashUserIds !== false,
      maskSensitiveData: options.maskSensitiveData !== false,
      excludePersonalData: options.excludePersonalData !== false,
      
      // Geographic and device tracking
      trackGeoLocation: options.trackGeoLocation !== false,
      trackUserAgent: options.trackUserAgent !== false,
      trackDeviceFingerprint: options.trackDeviceFingerprint !== false,
      
      // Risk analysis
      enableRiskScoring: options.enableRiskScoring !== false,
      riskFactors: options.riskFactors || [
        'unusual_location', 'new_device', 'off_hours', 'multiple_failures',
        'privilege_escalation', 'bulk_access', 'unusual_pattern'
      ],
      
      // Compliance settings
      complianceMode: options.complianceMode || 'none', // 'gdpr', 'hipaa', 'pci', 'sox'
      retentionPeriod: options.retentionPeriod || 2592000000, // 30 days
      
      ...options
    };
    
    this.authAttempts = new Map(); // Track failed attempts
    this.activeSessions = new Map(); // Track active sessions
    this.userRiskProfiles = new Map(); // Track user risk profiles
    this.securityEvents = []; // Store security events
    this.anomalyDetector = this.initializeAnomalyDetector();
    
    this.logger = this.initializeLogger();
    this.riskAnalyzer = this.initializeRiskAnalyzer();
    this.geoLocationService = this.initializeGeoLocation();
    this.deviceAnalyzer = this.initializeDeviceAnalyzer();
    this.complianceEngine = this.initializeComplianceEngine();
    
    this.initialize();
  }
  
  initializeLogger() {
    return {
      info: (message, metadata) => this.logMessage('INFO', message, metadata),
      warn: (message, metadata) => this.logMessage('WARN', message, metadata),
      error: (message, metadata) => this.logMessage('ERROR', message, metadata),
      debug: (message, metadata) => this.logMessage('DEBUG', message, metadata),
      security: (message, metadata) => this.logSecurityEvent('SECURITY', message, metadata)
    };
  }
  
  initializeAnomalyDetector() {
    return {
      patterns: new Map(),
      
      analyzeLoginPattern: (userId, loginData) => {
        const userPattern = this.anomalyDetector.patterns.get(userId) || {
          normalLocations: new Set(),
          normalTimes: [],
          normalDevices: new Set(),
          averageSessionDuration: 0,
          lastLoginTime: null
        };
        
        const anomalies = [];
        
        // Location anomaly
        if (loginData.location && 
            !userPattern.normalLocations.has(loginData.location.country)) {
          anomalies.push({
            type: 'unusual_location',
            severity: 'medium',
            details: `Login from unusual location: ${loginData.location.country}`
          });
        }
        
        // Time anomaly
        const hour = new Date(loginData.timestamp).getHours();
        const isNormalTime = userPattern.normalTimes.some(timeRange => 
          hour >= timeRange.start && hour <= timeRange.end);
        
        if (userPattern.normalTimes.length > 0 && !isNormalTime) {
          anomalies.push({
            type: 'off_hours',
            severity: 'low',
            details: `Login at unusual time: ${hour}:00`
          });
        }
        
        // Device anomaly
        if (loginData.deviceFingerprint && 
            !userPattern.normalDevices.has(loginData.deviceFingerprint)) {
          anomalies.push({
            type: 'new_device',
            severity: 'high',
            details: 'Login from new device'
          });
        }
        
        // Time since last login anomaly
        if (userPattern.lastLoginTime) {
          const timeSinceLastLogin = loginData.timestamp - userPattern.lastLoginTime;
          const daysSinceLastLogin = timeSinceLastLogin / (1000 * 60 * 60 * 24);
          
          if (daysSinceLastLogin > 30) {
            anomalies.push({
              type: 'dormant_account',
              severity: 'medium',
              details: `Account inactive for ${Math.round(daysSinceLastLogin)} days`
            });
          }
        }
        
        return anomalies;
      },
      
      updateUserPattern: (userId, loginData) => {
        const userPattern = this.anomalyDetector.patterns.get(userId) || {
          normalLocations: new Set(),
          normalTimes: [],
          normalDevices: new Set(),
          averageSessionDuration: 0,
          lastLoginTime: null
        };
        
        // Update location pattern
        if (loginData.location) {
          userPattern.normalLocations.add(loginData.location.country);
        }
        
        // Update time pattern
        const hour = new Date(loginData.timestamp).getHours();
        const existingTimeRange = userPattern.normalTimes.find(range => 
          Math.abs(range.start - hour) <= 2 || Math.abs(range.end - hour) <= 2);
        
        if (!existingTimeRange) {
          userPattern.normalTimes.push({ start: hour - 1, end: hour + 1 });
        }
        
        // Update device pattern
        if (loginData.deviceFingerprint) {
          userPattern.normalDevices.add(loginData.deviceFingerprint);
        }
        
        userPattern.lastLoginTime = loginData.timestamp;
        
        this.anomalyDetector.patterns.set(userId, userPattern);
      }
    };
  }
  
  initializeRiskAnalyzer() {
    return {
      calculateRiskScore: (userId, event, context = {}) => {
        let riskScore = 0;
        const riskFactors = [];
        
        // Failed login attempts risk
        const attempts = this.authAttempts.get(userId);
        if (attempts && attempts.count >= 3) {
          riskScore += 30;
          riskFactors.push({
            factor: 'multiple_failures',
            score: 30,
            details: `${attempts.count} failed attempts`
          });
        }
        
        // Location risk
        if (context.location && context.location.isVpn) {
          riskScore += 20;
          riskFactors.push({
            factor: 'vpn_usage',
            score: 20,
            details: 'Login through VPN'
          });
        }
        
        if (context.location && context.location.isTor) {
          riskScore += 40;
          riskFactors.push({
            factor: 'tor_usage',
            score: 40,
            details: 'Login through Tor network'
          });
        }
        
        // Device risk
        if (context.device && context.device.isNew) {
          riskScore += 25;
          riskFactors.push({
            factor: 'new_device',
            score: 25,
            details: 'Login from new device'
          });
        }
        
        // Time-based risk
        const hour = new Date().getHours();
        if (hour < 6 || hour > 22) {
          riskScore += 10;
          riskFactors.push({
            factor: 'off_hours',
            score: 10,
            details: 'Login during off hours'
          });
        }
        
        // Privilege escalation risk
        if (event.type === 'privilege_escalation') {
          riskScore += 50;
          riskFactors.push({
            factor: 'privilege_escalation',
            score: 50,
            details: 'Privilege escalation detected'
          });
        }
        
        // Bulk access risk
        if (context.bulkAccess) {
          riskScore += 35;
          riskFactors.push({
            factor: 'bulk_access',
            score: 35,
            details: 'Bulk data access pattern'
          });
        }
        
        return {
          score: Math.min(riskScore, 100),
          level: this.getRiskLevel(riskScore),
          factors: riskFactors,
          timestamp: Date.now()
        };
      },
      
      getRiskLevel: (score) => {
        if (score >= 80) return 'critical';
        if (score >= 60) return 'high';
        if (score >= 40) return 'medium';
        if (score >= 20) return 'low';
        return 'minimal';
      }
    };
  }
  
  initializeGeoLocation() {
    return {
      getLocationData: (ip) => {
        // Simulated geo-location service
        // In production, use services like MaxMind, IPStack, etc.
        return {
          ip,
          country: 'US',
          region: 'California',
          city: 'San Francisco',
          latitude: 37.7749,
          longitude: -122.4194,
          timezone: 'America/Los_Angeles',
          isp: 'Example ISP',
          isVpn: false,
          isTor: false,
          isProxy: false
        };
      }
    };
  }
  
  initializeDeviceAnalyzer() {
    return {
      analyzeDevice: (userAgent, additionalHeaders = {}) => {
        const deviceId = this.generateDeviceFingerprint(userAgent, additionalHeaders);
        
        return {
          fingerprint: deviceId,
          userAgent,
          browser: this.extractBrowser(userAgent),
          os: this.extractOS(userAgent),
          device: this.extractDevice(userAgent),
          isNew: !this.isKnownDevice(deviceId),
          isMobile: this.isMobileDevice(userAgent),
          isBot: this.isBotUserAgent(userAgent),
          riskLevel: this.assessDeviceRisk(userAgent, additionalHeaders)
        };
      },
      
      generateDeviceFingerprint: (userAgent, headers) => {
        const fingerprint = `${userAgent}-${headers.acceptLanguage || ''}-${headers.acceptEncoding || ''}`;
        return crypto.createHash('sha256').update(fingerprint).digest('hex').substring(0, 16);
      },
      
      extractBrowser: (userAgent) => {
        const browsers = [
          { name: 'Chrome', pattern: /Chrome\/([0-9\.]+)/ },
          { name: 'Firefox', pattern: /Firefox\/([0-9\.]+)/ },
          { name: 'Safari', pattern: /Safari\/([0-9\.]+)/ },
          { name: 'Edge', pattern: /Edge\/([0-9\.]+)/ }
        ];
        
        for (const browser of browsers) {
          const match = userAgent.match(browser.pattern);
          if (match) {
            return { name: browser.name, version: match[1] };
          }
        }
        
        return { name: 'Unknown', version: 'Unknown' };
      },
      
      extractOS: (userAgent) => {
        const oses = [
          { name: 'Windows', pattern: /Windows NT ([0-9\.]+)/ },
          { name: 'macOS', pattern: /Mac OS X ([0-9_\.]+)/ },
          { name: 'Linux', pattern: /Linux/ },
          { name: 'iOS', pattern: /iPhone OS ([0-9_\.]+)/ },
          { name: 'Android', pattern: /Android ([0-9\.]+)/ }
        ];
        
        for (const os of oses) {
          const match = userAgent.match(os.pattern);
          if (match) {
            return { name: os.name, version: match[1] || 'Unknown' };
          }
        }
        
        return { name: 'Unknown', version: 'Unknown' };
      },
      
      extractDevice: (userAgent) => {
        if (/iPhone/.test(userAgent)) return 'iPhone';
        if (/iPad/.test(userAgent)) return 'iPad';
        if (/Android/.test(userAgent)) return 'Android';
        if (/Mobile/.test(userAgent)) return 'Mobile';
        return 'Desktop';
      },
      
      isKnownDevice: (deviceId) => {
        // Check against known device database
        return false; // Simplified for example
      },
      
      isMobileDevice: (userAgent) => {
        return /Mobile|Android|iPhone|iPad/.test(userAgent);
      },
      
      isBotUserAgent: (userAgent) => {
        const botPatterns = [
          /bot/i, /crawler/i, /spider/i, /scraper/i, /curl/i, /wget/i
        ];
        return botPatterns.some(pattern => pattern.test(userAgent));
      },
      
      assessDeviceRisk: (userAgent, headers) => {
        let risk = 'low';
        
        if (this.isBotUserAgent(userAgent)) risk = 'high';
        if (!headers.acceptLanguage) risk = 'medium';
        if (userAgent.length < 20) risk = 'high';
        
        return risk;
      }
    };
  }
  
  initializeComplianceEngine() {
    return {
      gdpr: {
        shouldLog: (event) => {
          // GDPR considerations - minimize personal data logging
          const allowedEvents = [
            'login_success', 'login_failure', 'logout',
            'access_denied', 'privilege_change'
          ];
          return allowedEvents.includes(event.type);
        },
        
        sanitizeData: (data) => {
          const sanitized = { ...data };
          delete sanitized.email;
          delete sanitized.phone;
          delete sanitized.personalDetails;
          return sanitized;
        }
      },
      
      hipaa: {
        shouldLog: (event) => {
          // HIPAA requires comprehensive audit logs
          return true;
        },
        
        sanitizeData: (data) => {
          const sanitized = { ...data };
          // Maintain audit trail but protect PHI
          if (sanitized.patientId) {
            sanitized.patientId = this.hashValue(sanitized.patientId);
          }
          return sanitized;
        }
      },
      
      pci: {
        shouldLog: (event) => {
          // PCI DSS requires specific security event logging
          const requiredEvents = [
            'login_success', 'login_failure', 'access_denied',
            'privilege_escalation', 'admin_action'
          ];
          return requiredEvents.includes(event.type);
        },
        
        sanitizeData: (data) => {
          const sanitized = { ...data };
          // Never log card data
          delete sanitized.cardNumber;
          delete sanitized.cvv;
          delete sanitized.expiryDate;
          return sanitized;
        }
      }
    };
  }
  
  generateInstanceId() {
    const os = require('os');
    const identifier = `${os.hostname()}-${process.pid}-${Date.now()}`;
    return crypto.createHash('md5').update(identifier).digest('hex').substring(0, 8);
  }
  
  hashValue(value) {
    return crypto.createHash('sha256').update(value).digest('hex').substring(0, 16);
  }
  
  hashUserId(userId) {
    if (!this.options.hashUserIds) return userId;
    return this.hashValue(userId.toString());
  }
  
  logMessage(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      category: 'authentication-authorization',
      ...metadata
    };
    
    console.log(JSON.stringify(logEntry));
    this.emit('log', logEntry);
  }
  
  logSecurityEvent(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const securityEvent = {
      timestamp,
      level,
      message,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      category: 'security',
      severity: metadata.severity || 'medium',
      ...metadata
    };
    
    // Apply compliance rules
    const compliance = this.complianceEngine[this.options.complianceMode];
    if (compliance && !compliance.shouldLog(securityEvent)) {
      return; // Skip logging based on compliance rules
    }
    
    if (compliance) {
      Object.assign(securityEvent, compliance.sanitizeData(securityEvent));
    }
    
    console.log(JSON.stringify(securityEvent));
    this.emit('securityEvent', securityEvent);
    
    // Store for analysis
    this.securityEvents.push(securityEvent);
    this.limitSecurityEvents();
  }
  
  limitSecurityEvents() {
    const maxEvents = 10000;
    if (this.securityEvents.length > maxEvents) {
      this.securityEvents = this.securityEvents.slice(-maxEvents);
    }
  }
  
  async initialize() {
    this.logger.info('Authentication/Authorization logger initialized', {
      event: 'auth_logger_initialized',
      trackFailedAttempts: this.options.trackFailedAttempts,
      detectAnomalies: this.options.detectAnomalies,
      enableRiskScoring: this.options.enableRiskScoring,
      complianceMode: this.options.complianceMode
    });
  }
  
  // Authentication Event Logging Methods
  
  async logLoginAttempt(userId, success, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    const timestamp = Date.now();
    
    // Analyze location and device
    const locationData = context.ip ? this.geoLocationService.getLocationData(context.ip) : null;
    const deviceData = context.userAgent ? this.deviceAnalyzer.analyzeDevice(context.userAgent, context.headers) : null;
    
    // Detect anomalies
    let anomalies = [];
    if (this.options.detectAnomalies && success) {
      anomalies = this.anomalyDetector.analyzeLoginPattern(hashedUserId, {
        timestamp,
        location: locationData,
        deviceFingerprint: deviceData?.fingerprint
      });
    }
    
    // Calculate risk score
    let riskAssessment = null;
    if (this.options.enableRiskScoring) {
      riskAssessment = this.riskAnalyzer.calculateRiskScore(hashedUserId, 
        { type: success ? 'login_success' : 'login_failure' },
        { location: locationData, device: deviceData });
    }
    
    const eventData = {
      event: success ? 'login_success' : 'login_failure',
      userId: hashedUserId,
      timestamp: new Date(timestamp).toISOString(),
      ip: context.ip,
      userAgent: this.options.maskSensitiveData ? '[MASKED]' : context.userAgent,
      sessionId: context.sessionId,
      
      location: locationData ? {
        country: locationData.country,
        region: locationData.region,
        city: locationData.city,
        isVpn: locationData.isVpn,
        isTor: locationData.isTor,
        isProxy: locationData.isProxy
      } : undefined,
      
      device: deviceData ? {
        fingerprint: deviceData.fingerprint,
        browser: deviceData.browser,
        os: deviceData.os,
        deviceType: deviceData.device,
        isNew: deviceData.isNew,
        isMobile: deviceData.isMobile,
        isBot: deviceData.isBot,
        riskLevel: deviceData.riskLevel
      } : undefined,
      
      anomalies: anomalies.length > 0 ? anomalies : undefined,
      riskAssessment,
      
      // Additional context
      loginMethod: context.loginMethod || 'password',
      mfaUsed: context.mfaUsed || false,
      rememberMe: context.rememberMe || false,
      
      // Security flags
      suspiciousActivity: anomalies.length > 0 || (riskAssessment && riskAssessment.level === 'high'),
      
      metadata: context.metadata || {}
    };
    
    if (success) {
      if (this.options.logSuccessfulLogins) {
        this.logger.security('User login successful', {
          ...eventData,
          severity: anomalies.length > 0 ? 'medium' : 'low'
        });
      }
      
      // Update user patterns for anomaly detection
      if (this.options.detectAnomalies) {
        this.anomalyDetector.updateUserPattern(hashedUserId, {
          timestamp,
          location: locationData,
          deviceFingerprint: deviceData?.fingerprint
        });
      }
      
      // Track session
      if (context.sessionId) {
        this.trackSession(hashedUserId, context.sessionId, {
          timestamp,
          location: locationData,
          device: deviceData
        });
      }
      
      // Reset failed attempts
      this.authAttempts.delete(hashedUserId);
      
    } else {
      if (this.options.logFailedLogins) {
        this.logger.security('User login failed', {
          ...eventData,
          severity: 'medium',
          reason: context.failureReason || 'invalid_credentials'
        });
      }
      
      // Track failed attempts
      if (this.options.trackFailedAttempts) {
        this.trackFailedAttempt(hashedUserId, timestamp, context);
      }
    }
    
    return eventData;
  }
  
  async logLogout(userId, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logLogouts) {
      this.logger.security('User logout', {
        event: 'logout',
        userId: hashedUserId,
        sessionId: context.sessionId,
        timestamp: new Date().toISOString(),
        logoutType: context.logoutType || 'user_initiated', // 'user_initiated', 'timeout', 'forced'
        sessionDuration: context.sessionDuration,
        ip: context.ip,
        metadata: context.metadata || {}
      });
    }
    
    // Update session tracking
    if (context.sessionId) {
      this.endSession(hashedUserId, context.sessionId, context.logoutType);
    }
  }
  
  async logPasswordChange(userId, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logPasswordChanges) {
      this.logger.security('Password changed', {
        event: 'password_change',
        userId: hashedUserId,
        timestamp: new Date().toISOString(),
        initiatedBy: context.initiatedBy || 'user', // 'user', 'admin', 'system'
        forced: context.forced || false,
        ip: context.ip,
        reason: context.reason,
        metadata: context.metadata || {}
      });
    }
  }
  
  async logAccountLocking(userId, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logAccountLocking) {
      this.logger.security('Account locked', {
        event: 'account_locked',
        userId: hashedUserId,
        timestamp: new Date().toISOString(),
        reason: context.reason || 'failed_attempts',
        lockDuration: context.lockDuration,
        failedAttempts: context.failedAttempts,
        ip: context.ip,
        severity: 'high',
        metadata: context.metadata || {}
      });
    }
  }
  
  async logMfaEvent(userId, eventType, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logMfaEvents) {
      this.logger.security('MFA event', {
        event: 'mfa_event',
        eventType, // 'setup', 'verification_success', 'verification_failure', 'disabled'
        userId: hashedUserId,
        timestamp: new Date().toISOString(),
        mfaMethod: context.mfaMethod, // 'totp', 'sms', 'email', 'hardware_key'
        ip: context.ip,
        severity: eventType === 'disabled' ? 'high' : 'medium',
        metadata: context.metadata || {}
      });
    }
  }
  
  // Authorization Event Logging Methods
  
  async logAccessAttempt(userId, resource, action, granted, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    // Calculate risk for authorization events
    let riskAssessment = null;
    if (this.options.enableRiskScoring) {
      riskAssessment = this.riskAnalyzer.calculateRiskScore(hashedUserId,
        { type: granted ? 'access_granted' : 'access_denied' },
        { bulkAccess: context.bulkAccess });
    }
    
    const eventData = {
      event: granted ? 'access_granted' : 'access_denied',
      userId: hashedUserId,
      resource,
      action,
      timestamp: new Date().toISOString(),
      ip: context.ip,
      sessionId: context.sessionId,
      userRoles: context.userRoles,
      requiredPermissions: context.requiredPermissions,
      riskAssessment,
      metadata: context.metadata || {}
    };
    
    if (granted && this.options.logAccessGranted) {
      this.logger.security('Access granted', {
        ...eventData,
        severity: riskAssessment?.level === 'high' ? 'medium' : 'low'
      });
    } else if (!granted && this.options.logAccessDenied) {
      this.logger.security('Access denied', {
        ...eventData,
        severity: 'medium',
        reason: context.denialReason || 'insufficient_permissions'
      });
    }
    
    return eventData;
  }
  
  async logPrivilegeEscalation(userId, fromRole, toRole, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logPrivilegeEscalation) {
      this.logger.security('Privilege escalation', {
        event: 'privilege_escalation',
        userId: hashedUserId,
        fromRole,
        toRole,
        timestamp: new Date().toISOString(),
        grantedBy: context.grantedBy,
        temporary: context.temporary || false,
        expiresAt: context.expiresAt,
        reason: context.reason,
        ip: context.ip,
        severity: 'high',
        metadata: context.metadata || {}
      });
    }
  }
  
  async logRoleChange(userId, action, role, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logRoleChanges) {
      this.logger.security('Role change', {
        event: 'role_change',
        action, // 'assigned', 'removed', 'modified'
        userId: hashedUserId,
        role,
        timestamp: new Date().toISOString(),
        changedBy: context.changedBy,
        reason: context.reason,
        ip: context.ip,
        severity: action === 'assigned' && role.includes('admin') ? 'high' : 'medium',
        metadata: context.metadata || {}
      });
    }
  }
  
  async logPermissionChange(userId, resource, permissions, action, context = {}) {
    const hashedUserId = this.hashUserId(userId);
    
    if (this.options.logPermissionChanges) {
      this.logger.security('Permission change', {
        event: 'permission_change',
        action, // 'granted', 'revoked', 'modified'
        userId: hashedUserId,
        resource,
        permissions,
        timestamp: new Date().toISOString(),
        changedBy: context.changedBy,
        reason: context.reason,
        ip: context.ip,
        severity: 'medium',
        metadata: context.metadata || {}
      });
    }
  }
  
  // Session Management Methods
  
  trackSession(userId, sessionId, sessionData) {
    if (this.options.logSessionCreation) {
      this.logger.security('Session created', {
        event: 'session_created',
        userId,
        sessionId,
        timestamp: new Date().toISOString(),
        location: sessionData.location,
        device: sessionData.device,
        expiresAt: sessionData.expiresAt
      });
    }
    
    this.activeSessions.set(sessionId, {
      userId,
      createdAt: sessionData.timestamp,
      location: sessionData.location,
      device: sessionData.device,
      lastActivity: sessionData.timestamp
    });
  }
  
  endSession(userId, sessionId, reason) {
    const session = this.activeSessions.get(sessionId);
    
    if (session && this.options.logSessionTermination) {
      const duration = Date.now() - session.createdAt;
      
      this.logger.security('Session ended', {
        event: 'session_ended',
        userId,
        sessionId,
        timestamp: new Date().toISOString(),
        reason,
        duration,
        lastActivity: new Date(session.lastActivity).toISOString()
      });
    }
    
    this.activeSessions.delete(sessionId);
  }
  
  trackFailedAttempt(userId, timestamp, context) {
    const current = this.authAttempts.get(userId) || {
      count: 0,
      firstAttempt: timestamp,
      attempts: []
    };
    
    current.count++;
    current.attempts.push({
      timestamp,
      ip: context.ip,
      reason: context.failureReason
    });
    
    // Clean old attempts outside the window
    const windowStart = timestamp - this.options.failedAttemptWindow;
    current.attempts = current.attempts.filter(attempt => attempt.timestamp >= windowStart);
    current.count = current.attempts.length;
    
    this.authAttempts.set(userId, current);
    
    // Check for threshold breach
    if (current.count >= this.options.failedAttemptThreshold) {
      this.logger.security('Failed attempt threshold exceeded', {
        event: 'failed_attempt_threshold_exceeded',
        userId,
        attemptCount: current.count,
        threshold: this.options.failedAttemptThreshold,
        windowMinutes: this.options.failedAttemptWindow / 60000,
        severity: 'high',
        attempts: current.attempts
      });
      
      this.emit('failedAttemptThreshold', { userId, attempts: current });
    }
  }
  
  // Analysis and Reporting Methods
  
  getSecuritySummary(timeRange = 3600000) { // 1 hour default
    const since = Date.now() - timeRange;
    const recentEvents = this.securityEvents.filter(event => 
      new Date(event.timestamp).getTime() >= since);
    
    const summary = {
      totalEvents: recentEvents.length,
      loginAttempts: {
        successful: recentEvents.filter(e => e.event === 'login_success').length,
        failed: recentEvents.filter(e => e.event === 'login_failure').length
      },
      accessEvents: {
        granted: recentEvents.filter(e => e.event === 'access_granted').length,
        denied: recentEvents.filter(e => e.event === 'access_denied').length
      },
      highRiskEvents: recentEvents.filter(e => e.severity === 'high').length,
      uniqueUsers: new Set(recentEvents.map(e => e.userId)).size,
      topFailureReasons: this.getTopFailureReasons(recentEvents),
      suspiciousIPs: this.getSuspiciousIPs(recentEvents),
      timeRange: {
        from: new Date(since).toISOString(),
        to: new Date().toISOString()
      }
    };
    
    return summary;
  }
  
  getTopFailureReasons(events) {
    const reasons = {};
    events
      .filter(e => e.event === 'login_failure')
      .forEach(e => {
        const reason = e.reason || 'unknown';
        reasons[reason] = (reasons[reason] || 0) + 1;
      });
    
    return Object.entries(reasons)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([reason, count]) => ({ reason, count }));
  }
  
  getSuspiciousIPs(events) {
    const ipStats = {};
    
    events.forEach(e => {
      if (!e.ip) return;
      
      if (!ipStats[e.ip]) {
        ipStats[e.ip] = { failed: 0, successful: 0, accessDenied: 0 };
      }
      
      if (e.event === 'login_failure') ipStats[e.ip].failed++;
      if (e.event === 'login_success') ipStats[e.ip].successful++;
      if (e.event === 'access_denied') ipStats[e.ip].accessDenied++;
    });
    
    return Object.entries(ipStats)
      .filter(([ip, stats]) => stats.failed > 5 || stats.accessDenied > 10)
      .sort(([,a], [,b]) => (b.failed + b.accessDenied) - (a.failed + a.accessDenied))
      .slice(0, 10)
      .map(([ip, stats]) => ({ ip, ...stats }));
  }
  
  getUserRiskProfile(userId) {
    const hashedUserId = this.hashUserId(userId);
    return this.userRiskProfiles.get(hashedUserId) || {
      riskLevel: 'low',
      lastAssessment: null,
      factors: []
    };
  }
  
  // Utility Methods
  
  cleanup() {
    const now = Date.now();
    const retentionCutoff = now - this.options.retentionPeriod;
    
    // Clean up old security events
    this.securityEvents = this.securityEvents.filter(event => 
      new Date(event.timestamp).getTime() >= retentionCutoff);
    
    // Clean up old failed attempts
    for (const [userId, attempts] of this.authAttempts.entries()) {
      attempts.attempts = attempts.attempts.filter(attempt => 
        attempt.timestamp >= retentionCutoff);
      
      if (attempts.attempts.length === 0) {
        this.authAttempts.delete(userId);
      } else {
        attempts.count = attempts.attempts.length;
      }
    }
    
    // Clean up expired sessions
    for (const [sessionId, session] of this.activeSessions.entries()) {
      if (session.lastActivity < retentionCutoff) {
        this.activeSessions.delete(sessionId);
      }
    }
  }
  
  destroy() {
    // Perform final cleanup
    this.cleanup();
    
    // Clear intervals if any
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    
    this.logger.info('Authentication/Authorization logger destroyed', {
      event: 'auth_logger_destroyed',
      eventsLogged: this.securityEvents.length
    });
  }
}
```

## Production Usage Examples

### **Express.js Application with Authentication/Authorization Logging**
```javascript
// Production Express.js app with comprehensive auth logging
const express = require('express');
const session = require('express-session');
const passport = require('passport');
const AuthenticationAuthorizationLogger = require('./AuthenticationAuthorizationLogger');

class SecureWebApplication {
  constructor() {
    this.app = express();
    
    // Initialize auth logger
    this.authLogger = new AuthenticationAuthorizationLogger({
      applicationName: 'secure-web-app',
      version: process.env.APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      
      // Enable comprehensive logging
      logSuccessfulLogins: true,
      logFailedLogins: true,
      logLogouts: true,
      logPasswordChanges: true,
      logAccountLocking: true,
      logMfaEvents: true,
      logAccessGranted: process.env.NODE_ENV === 'production',
      logAccessDenied: true,
      logPrivilegeEscalation: true,
      logRoleChanges: true,
      logPermissionChanges: true,
      
      // Security features
      trackFailedAttempts: true,
      failedAttemptThreshold: 5,
      failedAttemptWindow: 900000, // 15 minutes
      detectAnomalies: true,
      enableRiskScoring: true,
      
      // Privacy and compliance
      hashUserIds: true,
      maskSensitiveData: true,
      complianceMode: process.env.COMPLIANCE_MODE || 'none',
      
      // Geographic and device tracking
      trackGeoLocation: true,
      trackUserAgent: true,
      trackDeviceFingerprint: true
    });
    
    this.setupMiddleware();
    this.setupAuthRoutes();
    this.setupProtectedRoutes();
    this.setupEventHandlers();
  }
  
  setupMiddleware() {
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));
    
    // Session middleware
    this.app.use(session({
      secret: process.env.SESSION_SECRET || 'dev-secret',
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === 'production',
        maxAge: 24 * 60 * 60 * 1000 // 24 hours
      }
    }));
    
    // Passport middleware
    this.app.use(passport.initialize());
    this.app.use(passport.session());
    
    // Security headers
    this.app.use((req, res, next) => {
      res.setHeader('X-Content-Type-Options', 'nosniff');
      res.setHeader('X-Frame-Options', 'DENY');
      res.setHeader('X-XSS-Protection', '1; mode=block');
      next();
    });
  }
  
  setupEventHandlers() {
    // Handle security events
    this.authLogger.on('securityEvent', (event) => {
      if (event.severity === 'high' || event.severity === 'critical') {
        this.handleHighSeverityEvent(event);
      }
    });
    
    // Handle failed attempt thresholds
    this.authLogger.on('failedAttemptThreshold', ({ userId, attempts }) => {
      this.handleFailedAttemptThreshold(userId, attempts);
    });
  }
  
  setupAuthRoutes() {
    // Login endpoint
    this.app.post('/auth/login', async (req, res) => {
      try {
        const { email, password, rememberMe, mfaCode } = req.body;
        const ip = req.ip || req.connection.remoteAddress;
        const userAgent = req.get('User-Agent');
        
        // Simulate user authentication
        const user = await this.authenticateUser(email, password);
        
        if (!user) {
          // Log failed login
          await this.authLogger.logLoginAttempt(email, false, {
            ip,
            userAgent,
            headers: req.headers,
            sessionId: req.sessionID,
            loginMethod: 'password',
            failureReason: 'invalid_credentials',
            metadata: { endpoint: '/auth/login' }
          });
          
          return res.status(401).json({
            success: false,
            message: 'Invalid credentials'
          });
        }
        
        // Check if MFA is required
        if (user.mfaEnabled && !mfaCode) {
          return res.status(200).json({
            success: false,
            mfaRequired: true,
            message: 'MFA code required'
          });
        }
        
        // Verify MFA if provided
        if (user.mfaEnabled && mfaCode) {
          const mfaValid = await this.verifyMfa(user.id, mfaCode);
          
          await this.authLogger.logMfaEvent(user.id, 
            mfaValid ? 'verification_success' : 'verification_failure', {
            ip,
            mfaMethod: user.mfaMethod,
            metadata: { endpoint: '/auth/login' }
          });
          
          if (!mfaValid) {
            return res.status(401).json({
              success: false,
              message: 'Invalid MFA code'
            });
          }
        }
        
        // Successful login
        req.session.userId = user.id;
        req.session.userRoles = user.roles;
        
        await this.authLogger.logLoginAttempt(user.id, true, {
          ip,
          userAgent,
          headers: req.headers,
          sessionId: req.sessionID,
          loginMethod: 'password',
          mfaUsed: user.mfaEnabled,
          rememberMe,
          metadata: { endpoint: '/auth/login' }
        });
        
        res.json({
          success: true,
          user: {
            id: user.id,
            email: user.email,
            roles: user.roles
          }
        });
        
      } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    });
    
    // Logout endpoint
    this.app.post('/auth/logout', this.requireAuth.bind(this), async (req, res) => {
      const userId = req.session.userId;
      const sessionId = req.sessionID;
      const ip = req.ip || req.connection.remoteAddress;
      
      // Calculate session duration
      const sessionStart = req.session.loginTime || Date.now();
      const sessionDuration = Date.now() - sessionStart;
      
      await this.authLogger.logLogout(userId, {
        sessionId,
        ip,
        logoutType: 'user_initiated',
        sessionDuration,
        metadata: { endpoint: '/auth/logout' }
      });
      
      req.session.destroy((err) => {
        if (err) {
          console.error('Session destruction error:', err);
        }
        
        res.json({
          success: true,
          message: 'Logged out successfully'
        });
      });
    });
    
    // Password change endpoint
    this.app.post('/auth/change-password', this.requireAuth.bind(this), async (req, res) => {
      try {
        const { currentPassword, newPassword } = req.body;
        const userId = req.session.userId;
        const ip = req.ip || req.connection.remoteAddress;
        
        // Verify current password
        const user = await this.getUserById(userId);
        const currentPasswordValid = await this.verifyPassword(user, currentPassword);
        
        if (!currentPasswordValid) {
          return res.status(400).json({
            success: false,
            message: 'Current password is incorrect'
          });
        }
        
        // Update password
        await this.updateUserPassword(userId, newPassword);
        
        // Log password change
        await this.authLogger.logPasswordChange(userId, {
          ip,
          initiatedBy: 'user',
          forced: false,
          metadata: { endpoint: '/auth/change-password' }
        });
        
        res.json({
          success: true,
          message: 'Password changed successfully'
        });
        
      } catch (error) {
        console.error('Password change error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    });
  }
  
  setupProtectedRoutes() {
    // Admin users endpoint
    this.app.get('/admin/users', 
      this.requireAuth.bind(this),
      this.requireRole('admin'),
      async (req, res) => {
        const userId = req.session.userId;
        const ip = req.ip || req.connection.remoteAddress;
        
        // Log access attempt
        await this.authLogger.logAccessAttempt(userId, '/admin/users', 'read', true, {
          ip,
          sessionId: req.sessionID,
          userRoles: req.session.userRoles,
          requiredPermissions: ['admin'],
          metadata: { endpoint: '/admin/users' }
        });
        
        const users = await this.getAllUsers();
        res.json({ users });
      }
    );
    
    // User profile endpoint
    this.app.get('/api/profile', this.requireAuth.bind(this), async (req, res) => {
      const userId = req.session.userId;
      const ip = req.ip || req.connection.remoteAddress;
      
      // Log access attempt
      await this.authLogger.logAccessAttempt(userId, '/api/profile', 'read', true, {
        ip,
        sessionId: req.sessionID,
        userRoles: req.session.userRoles,
        metadata: { endpoint: '/api/profile' }
      });
      
      const user = await this.getUserById(userId);
      res.json({ user });
    });
    
    // Admin role assignment
    this.app.post('/admin/users/:targetUserId/roles', 
      this.requireAuth.bind(this),
      this.requireRole('admin'),
      async (req, res) => {
        try {
          const { targetUserId } = req.params;
          const { role, action } = req.body; // action: 'assign' or 'remove'
          const adminUserId = req.session.userId;
          const ip = req.ip || req.connection.remoteAddress;
          
          // Perform role change
          if (action === 'assign') {
            await this.assignRole(targetUserId, role);
          } else if (action === 'remove') {
            await this.removeRole(targetUserId, role);
          }
          
          // Log role change
          await this.authLogger.logRoleChange(targetUserId, action === 'assign' ? 'assigned' : 'removed', role, {
            changedBy: adminUserId,
            ip,
            reason: req.body.reason,
            metadata: { endpoint: '/admin/users/roles' }
          });
          
          // Log privilege escalation if admin role
          if (role.includes('admin') && action === 'assign') {
            await this.authLogger.logPrivilegeEscalation(targetUserId, 'user', role, {
              grantedBy: adminUserId,
              ip,
              reason: req.body.reason,
              metadata: { endpoint: '/admin/users/roles' }
            });
          }
          
          res.json({
            success: true,
            message: `Role ${action}ed successfully`
          });
          
        } catch (error) {
          console.error('Role change error:', error);
          res.status(500).json({
            success: false,
            message: 'Internal server error'
          });
        }
      }
    );
  }
  
  requireAuth(req, res, next) {
    if (!req.session.userId) {
      const ip = req.ip || req.connection.remoteAddress;
      
      // Log unauthorized access attempt
      this.authLogger.logAccessAttempt('anonymous', req.path, req.method.toLowerCase(), false, {
        ip,
        sessionId: req.sessionID,
        denialReason: 'not_authenticated',
        metadata: { endpoint: req.path }
      });
      
      return res.status(401).json({
        success: false,
        message: 'Authentication required'
      });
    }
    
    next();
  }
  
  requireRole(requiredRole) {
    return async (req, res, next) => {
      const userRoles = req.session.userRoles || [];
      const hasRole = userRoles.includes(requiredRole);
      const userId = req.session.userId;
      const ip = req.ip || req.connection.remoteAddress;
      
      if (!hasRole) {
        // Log access denied
        await this.authLogger.logAccessAttempt(userId, req.path, req.method.toLowerCase(), false, {
          ip,
          sessionId: req.sessionID,
          userRoles,
          requiredPermissions: [requiredRole],
          denialReason: 'insufficient_permissions',
          metadata: { endpoint: req.path }
        });
        
        return res.status(403).json({
          success: false,
          message: 'Insufficient permissions'
        });
      }
      
      next();
    };
  }
  
  handleHighSeverityEvent(event) {
    console.warn('HIGH SEVERITY SECURITY EVENT:', {
      event: event.event,
      userId: event.userId,
      severity: event.severity,
      timestamp: event.timestamp
    });
    
    // Send alert to security team
    this.sendSecurityAlert(event);
    
    // If critical, might want to automatically lock account
    if (event.severity === 'critical') {
      this.handleCriticalSecurityEvent(event);
    }
  }
  
  handleFailedAttemptThreshold(userId, attempts) {
    console.warn(`Failed attempt threshold exceeded for user ${userId}`);
    
    // Lock the account
    this.lockAccount(userId, {
      reason: 'failed_attempts',
      lockDuration: 1800000, // 30 minutes
      failedAttempts: attempts.count
    });
    
    // Send security alert
    this.sendSecurityAlert({
      type: 'account_locked',
      userId,
      reason: 'failed_attempts',
      attempts: attempts.count
    });
  }
  
  async lockAccount(userId, context) {
    // Lock account in database
    await this.setAccountLocked(userId, true);
    
    // Log account locking
    await this.authLogger.logAccountLocking(userId, context);
  }
  
  sendSecurityAlert(alert) {
    // Implementation would send to security monitoring system
    console.log('SECURITY ALERT:', alert);
  }
  
  handleCriticalSecurityEvent(event) {
    // Implementation for critical events
    console.error('CRITICAL SECURITY EVENT - IMMEDIATE ATTENTION REQUIRED:', event);
  }
  
  // Mock authentication methods (replace with real implementation)
  async authenticateUser(email, password) {
    // Mock implementation
    if (email === 'admin@example.com' && password === 'admin123') {
      return {
        id: 'user_123',
        email,
        roles: ['admin'],
        mfaEnabled: true,
        mfaMethod: 'totp'
      };
    }
    return null;
  }
  
  async verifyMfa(userId, code) {
    // Mock MFA verification
    return code === '123456';
  }
  
  async verifyPassword(user, password) {
    // Mock password verification
    return true;
  }
  
  async updateUserPassword(userId, newPassword) {
    // Mock password update
    console.log(`Password updated for user ${userId}`);
  }
  
  async getUserById(userId) {
    // Mock user retrieval
    return { id: userId, email: 'user@example.com' };
  }
  
  async getAllUsers() {
    // Mock user list
    return [{ id: 'user_123', email: 'admin@example.com' }];
  }
  
  async assignRole(userId, role) {
    console.log(`Assigned role ${role} to user ${userId}`);
  }
  
  async removeRole(userId, role) {
    console.log(`Removed role ${role} from user ${userId}`);
  }
  
  async setAccountLocked(userId, locked) {
    console.log(`Account ${userId} locked: ${locked}`);
  }
  
  start() {
    const port = process.env.PORT || 3000;
    this.app.listen(port, () => {
      console.log(`Secure app listening on port ${port}`);
    });
  }
}

// Usage
const app = new SecureWebApplication();
app.start();
```

---

## Authentication/Authorization Logging Best Practices

### **Essential Security Events to Log**

1. **Authentication Events**
   - Login attempts (successful and failed)
   - Logout events
   - Password changes
   - Account lockouts
   - Multi-factor authentication events

2. **Authorization Events**
   - Access granted/denied
   - Privilege escalation
   - Role assignments/changes
   - Permission modifications

3. **Session Events**
   - Session creation
   - Session expiration
   - Concurrent sessions
   - Session hijacking attempts

### **Security Considerations**

1. **Data Protection**
   - Hash or mask user identifiers
   - Avoid logging sensitive data
   - Comply with privacy regulations
   - Implement secure log storage

2. **Real-time Monitoring**
   - Track failed attempt patterns
   - Detect unusual access patterns
   - Monitor privilege escalations
   - Alert on suspicious activities

**Next Section**: Ready to continue with **3.1.4 Business Transactions** - logging business-critical operations and transactions!
