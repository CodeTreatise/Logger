# 3.1.4 Business Transactions

## Understanding Business Transaction Logging

Business transaction logging captures the flow and state of critical business processes, providing visibility into business operations, enabling audit trails, and supporting business intelligence. This logging goes beyond technical events to track meaningful business activities and their outcomes.

## Why Log Business Transactions?

### **Business Benefits**
- **Process Visibility**: Track end-to-end business process execution and outcomes
- **Audit Compliance**: Maintain detailed records for regulatory and internal audits
- **Business Intelligence**: Extract insights from business process data for optimization
- **Customer Journey**: Track customer interactions and experience across touchpoints
- **Revenue Tracking**: Monitor financial transactions and revenue-generating activities

### **Operational Benefits**
- **Process Optimization**: Identify bottlenecks and inefficiencies in business workflows
- **Error Recovery**: Enable rollback and compensation for failed business transactions
- **Performance Monitoring**: Track business process performance and SLA compliance
- **Fraud Detection**: Identify suspicious patterns in business transactions
- **Reporting**: Generate business reports and analytics from transaction logs

## Advanced Business Transaction Logger

### 1. **Comprehensive Business Transaction Logging System**

```javascript
// Advanced business transaction logging system
const { EventEmitter } = require('events');
const crypto = require('crypto');

class BusinessTransactionLogger extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      applicationName: options.applicationName || process.env.APP_NAME || 'business-app',
      version: options.version || process.env.APP_VERSION || '1.0.0',
      environment: options.environment || process.env.NODE_ENV || 'development',
      instanceId: options.instanceId || this.generateInstanceId(),
      
      // Transaction tracking options
      trackTransactionSteps: options.trackTransactionSteps !== false,
      trackBusinessEvents: options.trackBusinessEvents !== false,
      trackFinancialTransactions: options.trackFinancialTransactions !== false,
      trackUserActions: options.trackUserActions !== false,
      trackWorkflowStates: options.trackWorkflowStates !== false,
      trackCompensatingActions: options.trackCompensatingActions !== false,
      
      // Business metrics options
      calculateTransactionMetrics: options.calculateTransactionMetrics !== false,
      trackRevenue: options.trackRevenue !== false,
      trackConversions: options.trackConversions !== false,
      trackCustomerLifecycle: options.trackCustomerLifecycle !== false,
      
      // Data options
      includeBusinessContext: options.includeBusinessContext !== false,
      trackRelatedEntities: options.trackRelatedEntities !== false,
      enableBusinessIntelligence: options.enableBusinessIntelligence !== false,
      
      // Security and compliance
      enableDataMasking: options.enableDataMasking !== false,
      complianceMode: options.complianceMode || 'none', // 'sox', 'gdpr', 'pci', 'hipaa'
      auditLevel: options.auditLevel || 'standard', // 'minimal', 'standard', 'comprehensive'
      
      // Performance options
      enableAsyncLogging: options.enableAsyncLogging !== false,
      batchSize: options.batchSize || 100,
      flushInterval: options.flushInterval || 5000, // 5 seconds
      
      // Retention and storage
      retentionPeriod: options.retentionPeriod || 7776000000, // 90 days
      enableArchiving: options.enableArchiving !== false,
      
      ...options
    };
    
    this.transactions = new Map(); // Active transactions
    this.completedTransactions = new Map(); // Completed transactions cache
    this.businessMetrics = new Map(); // Business metrics aggregation
    this.workflowStates = new Map(); // Workflow state tracking
    this.logBuffer = []; // Async logging buffer
    
    this.logger = this.initializeLogger();
    this.metricsCollector = this.initializeMetricsCollector();
    this.workflowEngine = this.initializeWorkflowEngine();
    this.compensationManager = this.initializeCompensationManager();
    this.businessIntelligence = this.initializeBusinessIntelligence();
    this.complianceManager = this.initializeComplianceManager();
    
    this.initialize();
  }
  
  initializeLogger() {
    return {
      info: (message, metadata) => this.logMessage('INFO', message, metadata),
      warn: (message, metadata) => this.logMessage('WARN', message, metadata),
      error: (message, metadata) => this.logMessage('ERROR', message, metadata),
      debug: (message, metadata) => this.logMessage('DEBUG', message, metadata),
      business: (message, metadata) => this.logBusinessEvent('BUSINESS', message, metadata)
    };
  }
  
  initializeMetricsCollector() {
    return {
      transactionCounts: new Map(),
      transactionDurations: new Map(),
      revenueMetrics: new Map(),
      conversionMetrics: new Map(),
      errorRates: new Map(),
      
      recordTransaction: (type, duration, success, revenue = 0) => {
        // Transaction count
        const currentCount = this.metricsCollector.transactionCounts.get(type) || 0;
        this.metricsCollector.transactionCounts.set(type, currentCount + 1);
        
        // Duration tracking
        const durations = this.metricsCollector.transactionDurations.get(type) || [];
        durations.push(duration);
        this.metricsCollector.transactionDurations.set(type, durations);
        
        // Revenue tracking
        if (revenue > 0) {
          const currentRevenue = this.metricsCollector.revenueMetrics.get(type) || 0;
          this.metricsCollector.revenueMetrics.set(type, currentRevenue + revenue);
        }
        
        // Error rate tracking
        const errors = this.metricsCollector.errorRates.get(type) || { total: 0, errors: 0 };
        errors.total++;
        if (!success) errors.errors++;
        this.metricsCollector.errorRates.set(type, errors);
      },
      
      getMetrics: (type) => {
        const count = this.metricsCollector.transactionCounts.get(type) || 0;
        const durations = this.metricsCollector.transactionDurations.get(type) || [];
        const revenue = this.metricsCollector.revenueMetrics.get(type) || 0;
        const errorData = this.metricsCollector.errorRates.get(type) || { total: 0, errors: 0 };
        
        return {
          transactionCount: count,
          averageDuration: durations.length > 0 ? durations.reduce((a, b) => a + b, 0) / durations.length : 0,
          totalRevenue: revenue,
          errorRate: errorData.total > 0 ? (errorData.errors / errorData.total) * 100 : 0,
          successRate: errorData.total > 0 ? ((errorData.total - errorData.errors) / errorData.total) * 100 : 100
        };
      }
    };
  }
  
  initializeWorkflowEngine() {
    return {
      workflows: new Map(),
      
      defineWorkflow: (workflowId, steps) => {
        this.workflowEngine.workflows.set(workflowId, {
          steps,
          instances: new Map()
        });
      },
      
      startWorkflow: (workflowId, instanceId, context = {}) => {
        const workflow = this.workflowEngine.workflows.get(workflowId);
        if (!workflow) {
          throw new Error(`Workflow ${workflowId} not found`);
        }
        
        const instance = {
          workflowId,
          instanceId,
          context,
          currentStep: 0,
          status: 'running',
          startTime: Date.now(),
          steps: workflow.steps.map((step, index) => ({
            ...step,
            index,
            status: index === 0 ? 'pending' : 'waiting',
            startTime: null,
            endTime: null,
            error: null,
            result: null
          }))
        };
        
        workflow.instances.set(instanceId, instance);
        this.workflowStates.set(instanceId, instance);
        
        return instance;
      },
      
      updateWorkflowStep: (instanceId, stepIndex, status, result = null, error = null) => {
        const instance = this.workflowStates.get(instanceId);
        if (!instance) return null;
        
        const step = instance.steps[stepIndex];
        if (!step) return null;
        
        step.status = status;
        step.result = result;
        step.error = error;
        
        if (status === 'running') {
          step.startTime = Date.now();
        } else if (status === 'completed' || status === 'failed') {
          step.endTime = Date.now();
          
          if (status === 'completed' && stepIndex < instance.steps.length - 1) {
            // Move to next step
            instance.currentStep = stepIndex + 1;
            instance.steps[stepIndex + 1].status = 'pending';
          } else if (stepIndex === instance.steps.length - 1 && status === 'completed') {
            // Workflow completed
            instance.status = 'completed';
            instance.endTime = Date.now();
          } else if (status === 'failed') {
            // Workflow failed
            instance.status = 'failed';
            instance.endTime = Date.now();
          }
        }
        
        this.workflowStates.set(instanceId, instance);
        return instance;
      },
      
      getWorkflowStatus: (instanceId) => {
        return this.workflowStates.get(instanceId);
      }
    };
  }
  
  initializeCompensationManager() {
    return {
      compensations: new Map(),
      
      registerCompensation: (transactionId, compensationAction) => {
        const compensations = this.compensationManager.compensations.get(transactionId) || [];
        compensations.push({
          action: compensationAction,
          timestamp: Date.now(),
          executed: false
        });
        this.compensationManager.compensations.set(transactionId, compensations);
      },
      
      executeCompensations: async (transactionId) => {
        const compensations = this.compensationManager.compensations.get(transactionId) || [];
        const results = [];
        
        // Execute compensations in reverse order (LIFO)
        for (let i = compensations.length - 1; i >= 0; i--) {
          const compensation = compensations[i];
          if (!compensation.executed) {
            try {
              const result = await compensation.action();
              compensation.executed = true;
              compensation.result = result;
              results.push({ index: i, success: true, result });
            } catch (error) {
              compensation.error = error;
              results.push({ index: i, success: false, error });
            }
          }
        }
        
        return results;
      }
    };
  }
  
  initializeBusinessIntelligence() {
    return {
      customerMetrics: new Map(),
      productMetrics: new Map(),
      channelMetrics: new Map(),
      
      trackCustomerAction: (customerId, action, value = 0, metadata = {}) => {
        const customer = this.businessIntelligence.customerMetrics.get(customerId) || {
          totalActions: 0,
          totalValue: 0,
          actions: {},
          firstSeen: Date.now(),
          lastSeen: Date.now()
        };
        
        customer.totalActions++;
        customer.totalValue += value;
        customer.actions[action] = (customer.actions[action] || 0) + 1;
        customer.lastSeen = Date.now();
        
        this.businessIntelligence.customerMetrics.set(customerId, customer);
        
        return customer;
      },
      
      trackProductInteraction: (productId, interaction, customerId = null, value = 0) => {
        const product = this.businessIntelligence.productMetrics.get(productId) || {
          views: 0,
          purchases: 0,
          revenue: 0,
          customers: new Set(),
          interactions: {}
        };
        
        product.interactions[interaction] = (product.interactions[interaction] || 0) + 1;
        
        if (interaction === 'view') product.views++;
        if (interaction === 'purchase') {
          product.purchases++;
          product.revenue += value;
        }
        
        if (customerId) {
          product.customers.add(customerId);
        }
        
        this.businessIntelligence.productMetrics.set(productId, product);
        
        return product;
      },
      
      getCustomerInsights: (customerId) => {
        const customer = this.businessIntelligence.customerMetrics.get(customerId);
        if (!customer) return null;
        
        const lifetimeValue = customer.totalValue;
        const averageOrderValue = customer.actions.purchase > 0 ? lifetimeValue / customer.actions.purchase : 0;
        const engagementScore = customer.totalActions / Math.max(1, (Date.now() - customer.firstSeen) / (1000 * 60 * 60 * 24)); // actions per day
        
        return {
          ...customer,
          lifetimeValue,
          averageOrderValue,
          engagementScore,
          customerSegment: this.calculateCustomerSegment(lifetimeValue, engagementScore)
        };
      },
      
      calculateCustomerSegment: (lifetimeValue, engagementScore) => {
        if (lifetimeValue > 1000 && engagementScore > 5) return 'VIP';
        if (lifetimeValue > 500 && engagementScore > 2) return 'HIGH_VALUE';
        if (lifetimeValue > 100 || engagementScore > 1) return 'REGULAR';
        return 'NEW';
      }
    };
  }
  
  initializeComplianceManager() {
    return {
      auditRules: new Map(),
      
      sox: {
        requireApproval: (transactionType, amount) => {
          return amount > 10000 || ['financial_adjustment', 'account_closure'].includes(transactionType);
        },
        
        sanitizeData: (data) => {
          const sanitized = { ...data };
          // Remove or mask sensitive financial data
          if (sanitized.accountNumber) {
            sanitized.accountNumber = this.maskData(sanitized.accountNumber, 'account');
          }
          if (sanitized.ssn) {
            sanitized.ssn = this.maskData(sanitized.ssn, 'ssn');
          }
          return sanitized;
        }
      },
      
      gdpr: {
        requireConsent: (dataType) => {
          return ['personal_data', 'tracking_data', 'marketing_data'].includes(dataType);
        },
        
        sanitizeData: (data) => {
          const sanitized = { ...data };
          // Remove PII according to GDPR
          delete sanitized.email;
          delete sanitized.phone;
          delete sanitized.address;
          if (sanitized.userId) {
            sanitized.userId = this.hashValue(sanitized.userId);
          }
          return sanitized;
        }
      },
      
      pci: {
        requireEncryption: (dataType) => {
          return ['payment_data', 'card_data', 'transaction_data'].includes(dataType);
        },
        
        sanitizeData: (data) => {
          const sanitized = { ...data };
          // Never log card data
          delete sanitized.cardNumber;
          delete sanitized.cvv;
          delete sanitized.expiryDate;
          if (sanitized.transactionId) {
            sanitized.transactionId = this.hashValue(sanitized.transactionId);
          }
          return sanitized;
        }
      }
    };
  }
  
  generateInstanceId() {
    const os = require('os');
    const identifier = `${os.hostname()}-${process.pid}-${Date.now()}`;
    return crypto.createHash('md5').update(identifier).digest('hex').substring(0, 8);
  }
  
  generateTransactionId() {
    return `txn_${Date.now()}_${crypto.randomBytes(8).toString('hex')}`;
  }
  
  hashValue(value) {
    return crypto.createHash('sha256').update(value.toString()).digest('hex').substring(0, 16);
  }
  
  maskData(value, type) {
    if (!value) return value;
    
    switch (type) {
      case 'account':
        return value.replace(/(.{2})(.*)(.{4})/, '$1****$3');
      case 'ssn':
        return value.replace(/(.{3})(.*)(.{4})/, '$1-**-$3');
      case 'email':
        return value.replace(/(.{2})(.*)(@.*)/, '$1****$3');
      case 'phone':
        return value.replace(/(.{3})(.*)(.{4})/, '$1-***-$3');
      default:
        return '****';
    }
  }
  
  logMessage(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      category: 'business-transaction',
      ...metadata
    };
    
    if (this.options.enableAsyncLogging) {
      this.logBuffer.push(logEntry);
      this.flushLogsIfNeeded();
    } else {
      console.log(JSON.stringify(logEntry));
    }
    
    this.emit('log', logEntry);
  }
  
  logBusinessEvent(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const businessEvent = {
      timestamp,
      level,
      message,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      category: 'business-event',
      ...metadata
    };
    
    // Apply compliance rules
    const compliance = this.complianceManager[this.options.complianceMode];
    if (compliance && compliance.sanitizeData) {
      Object.assign(businessEvent, compliance.sanitizeData(businessEvent));
    }
    
    if (this.options.enableAsyncLogging) {
      this.logBuffer.push(businessEvent);
      this.flushLogsIfNeeded();
    } else {
      console.log(JSON.stringify(businessEvent));
    }
    
    this.emit('businessEvent', businessEvent);
  }
  
  flushLogsIfNeeded() {
    if (this.logBuffer.length >= this.options.batchSize) {
      this.flushLogs();
    }
  }
  
  flushLogs() {
    if (this.logBuffer.length === 0) return;
    
    const logs = [...this.logBuffer];
    this.logBuffer = [];
    
    // Process logs (in production, send to log aggregation system)
    logs.forEach(log => console.log(JSON.stringify(log)));
    
    this.emit('logsBatched', logs);
  }
  
  async initialize() {
    this.logger.info('Business Transaction logger initialized', {
      event: 'business_logger_initialized',
      trackTransactionSteps: this.options.trackTransactionSteps,
      trackBusinessEvents: this.options.trackBusinessEvents,
      calculateTransactionMetrics: this.options.calculateTransactionMetrics,
      complianceMode: this.options.complianceMode,
      auditLevel: this.options.auditLevel
    });
    
    // Setup flush interval for async logging
    if (this.options.enableAsyncLogging) {
      this.flushInterval = setInterval(() => {
        this.flushLogs();
      }, this.options.flushInterval);
    }
  }
  
  // Business Transaction Logging Methods
  
  async startTransaction(transactionType, context = {}) {
    const transactionId = this.generateTransactionId();
    const timestamp = Date.now();
    
    const transaction = {
      transactionId,
      transactionType,
      status: 'started',
      startTime: timestamp,
      endTime: null,
      duration: null,
      steps: [],
      context: this.sanitizeContext(context),
      metadata: {
        userId: context.userId,
        sessionId: context.sessionId,
        correlationId: context.correlationId,
        businessUnit: context.businessUnit,
        channel: context.channel,
        region: context.region
      },
      businessData: {
        customerId: context.customerId,
        productIds: context.productIds || [],
        amount: context.amount || 0,
        currency: context.currency || 'USD',
        paymentMethod: context.paymentMethod,
        orderNumber: context.orderNumber
      },
      compensations: [],
      workflows: []
    };
    
    this.transactions.set(transactionId, transaction);
    
    if (this.options.trackBusinessEvents) {
      this.logger.business('Business transaction started', {
        event: 'transaction_started',
        transactionId,
        transactionType,
        timestamp: new Date(timestamp).toISOString(),
        context: transaction.context,
        metadata: transaction.metadata,
        businessData: this.options.enableDataMasking ? this.maskBusinessData(transaction.businessData) : transaction.businessData
      });
    }
    
    // Track customer action if customer is involved
    if (context.customerId) {
      this.businessIntelligence.trackCustomerAction(
        context.customerId,
        `transaction_${transactionType}`,
        context.amount || 0,
        { transactionId, timestamp }
      );
    }
    
    return transaction;
  }
  
  async addTransactionStep(transactionId, stepName, stepData = {}) {
    const transaction = this.transactions.get(transactionId);
    if (!transaction) {
      throw new Error(`Transaction ${transactionId} not found`);
    }
    
    const step = {
      stepName,
      stepIndex: transaction.steps.length,
      status: 'started',
      startTime: Date.now(),
      endTime: null,
      duration: null,
      data: this.sanitizeContext(stepData),
      error: null,
      result: null
    };
    
    transaction.steps.push(step);
    
    if (this.options.trackTransactionSteps) {
      this.logger.business('Transaction step started', {
        event: 'transaction_step_started',
        transactionId,
        stepName,
        stepIndex: step.stepIndex,
        timestamp: new Date(step.startTime).toISOString(),
        stepData: step.data
      });
    }
    
    return step;
  }
  
  async completeTransactionStep(transactionId, stepIndex, result = null, error = null) {
    const transaction = this.transactions.get(transactionId);
    if (!transaction) {
      throw new Error(`Transaction ${transactionId} not found`);
    }
    
    const step = transaction.steps[stepIndex];
    if (!step) {
      throw new Error(`Step ${stepIndex} not found in transaction ${transactionId}`);
    }
    
    step.endTime = Date.now();
    step.duration = step.endTime - step.startTime;
    step.status = error ? 'failed' : 'completed';
    step.result = result;
    step.error = error;
    
    if (this.options.trackTransactionSteps) {
      this.logger.business('Transaction step completed', {
        event: 'transaction_step_completed',
        transactionId,
        stepName: step.stepName,
        stepIndex,
        status: step.status,
        duration: step.duration,
        timestamp: new Date(step.endTime).toISOString(),
        result: result ? this.sanitizeContext(result) : null,
        error: error ? {
          message: error.message,
          code: error.code,
          stack: this.options.environment === 'development' ? error.stack : undefined
        } : null
      });
    }
    
    return step;
  }
  
  async completeTransaction(transactionId, outcome = 'success', finalResult = null, error = null) {
    const transaction = this.transactions.get(transactionId);
    if (!transaction) {
      throw new Error(`Transaction ${transactionId} not found`);
    }
    
    transaction.endTime = Date.now();
    transaction.duration = transaction.endTime - transaction.startTime;
    transaction.status = outcome;
    transaction.result = finalResult;
    transaction.error = error;
    
    // Calculate transaction metrics
    if (this.options.calculateTransactionMetrics) {
      this.metricsCollector.recordTransaction(
        transaction.transactionType,
        transaction.duration,
        outcome === 'success',
        transaction.businessData.amount || 0
      );
    }
    
    if (this.options.trackBusinessEvents) {
      this.logger.business('Business transaction completed', {
        event: 'transaction_completed',
        transactionId,
        transactionType: transaction.transactionType,
        status: transaction.status,
        duration: transaction.duration,
        stepsCount: transaction.steps.length,
        timestamp: new Date(transaction.endTime).toISOString(),
        businessData: this.options.enableDataMasking ? this.maskBusinessData(transaction.businessData) : transaction.businessData,
        result: finalResult ? this.sanitizeContext(finalResult) : null,
        error: error ? {
          message: error.message,
          code: error.code,
          type: error.constructor.name
        } : null
      });
    }
    
    // Handle failure compensation
    if (outcome === 'failure' && this.options.trackCompensatingActions) {
      await this.executeCompensation(transactionId);
    }
    
    // Track product interactions if applicable
    if (transaction.businessData.productIds && transaction.businessData.productIds.length > 0) {
      for (const productId of transaction.businessData.productIds) {
        this.businessIntelligence.trackProductInteraction(
          productId,
          outcome === 'success' ? 'purchase' : 'attempted_purchase',
          transaction.businessData.customerId,
          outcome === 'success' ? transaction.businessData.amount : 0
        );
      }
    }
    
    // Move to completed transactions
    this.completedTransactions.set(transactionId, transaction);
    this.transactions.delete(transactionId);
    
    return transaction;
  }
  
  async executeCompensation(transactionId) {
    const transaction = this.completedTransactions.get(transactionId) || this.transactions.get(transactionId);
    if (!transaction) {
      throw new Error(`Transaction ${transactionId} not found`);
    }
    
    this.logger.business('Starting transaction compensation', {
      event: 'compensation_started',
      transactionId,
      compensationCount: transaction.compensations.length
    });
    
    const results = await this.compensationManager.executeCompensations(transactionId);
    
    this.logger.business('Transaction compensation completed', {
      event: 'compensation_completed',
      transactionId,
      results: results.map(r => ({
        index: r.index,
        success: r.success,
        error: r.error ? r.error.message : null
      }))
    });
    
    return results;
  }
  
  // Workflow Integration Methods
  
  async startBusinessWorkflow(workflowType, context = {}) {
    const workflowId = `workflow_${workflowType}`;
    const instanceId = this.generateTransactionId();
    
    // Define common business workflows
    const workflows = {
      order_processing: [
        { name: 'validate_order', timeout: 30000 },
        { name: 'check_inventory', timeout: 15000 },
        { name: 'process_payment', timeout: 60000 },
        { name: 'fulfill_order', timeout: 300000 },
        { name: 'send_confirmation', timeout: 10000 }
      ],
      customer_onboarding: [
        { name: 'validate_information', timeout: 30000 },
        { name: 'perform_kyc', timeout: 120000 },
        { name: 'create_account', timeout: 15000 },
        { name: 'setup_preferences', timeout: 30000 },
        { name: 'send_welcome', timeout: 10000 }
      ],
      loan_approval: [
        { name: 'collect_documents', timeout: 86400000 }, // 24 hours
        { name: 'credit_check', timeout: 300000 },
        { name: 'risk_assessment', timeout: 600000 },
        { name: 'approval_review', timeout: 1800000 }, // 30 minutes
        { name: 'generate_contract', timeout: 60000 }
      ]
    };
    
    const workflowSteps = workflows[workflowType];
    if (!workflowSteps) {
      throw new Error(`Unknown workflow type: ${workflowType}`);
    }
    
    // Register workflow if not already registered
    if (!this.workflowEngine.workflows.has(workflowId)) {
      this.workflowEngine.defineWorkflow(workflowId, workflowSteps);
    }
    
    const workflowInstance = this.workflowEngine.startWorkflow(workflowId, instanceId, context);
    
    this.logger.business('Business workflow started', {
      event: 'workflow_started',
      workflowType,
      workflowId,
      instanceId,
      stepsCount: workflowSteps.length,
      context: this.sanitizeContext(context)
    });
    
    return workflowInstance;
  }
  
  async updateWorkflowStep(instanceId, stepIndex, status, result = null, error = null) {
    const updatedInstance = this.workflowEngine.updateWorkflowStep(instanceId, stepIndex, status, result, error);
    
    if (this.options.trackWorkflowStates) {
      this.logger.business('Workflow step updated', {
        event: 'workflow_step_updated',
        instanceId,
        stepIndex,
        stepName: updatedInstance.steps[stepIndex].name,
        status,
        workflowStatus: updatedInstance.status,
        result: result ? this.sanitizeContext(result) : null,
        error: error ? {
          message: error.message,
          code: error.code
        } : null
      });
    }
    
    return updatedInstance;
  }
  
  // Business Intelligence Methods
  
  trackBusinessEvent(eventType, eventData = {}) {
    const event = {
      eventType,
      timestamp: Date.now(),
      data: this.sanitizeContext(eventData),
      userId: eventData.userId,
      customerId: eventData.customerId,
      sessionId: eventData.sessionId
    };
    
    this.logger.business('Business event tracked', {
      event: 'business_event_tracked',
      eventType,
      timestamp: new Date(event.timestamp).toISOString(),
      data: event.data
    });
    
    // Update business intelligence metrics
    if (eventData.customerId) {
      this.businessIntelligence.trackCustomerAction(
        eventData.customerId,
        eventType,
        eventData.value || 0,
        eventData
      );
    }
    
    if (eventData.productId) {
      this.businessIntelligence.trackProductInteraction(
        eventData.productId,
        eventType,
        eventData.customerId,
        eventData.value || 0
      );
    }
    
    return event;
  }
  
  // Utility Methods
  
  sanitizeContext(context) {
    if (!this.options.enableDataMasking) return context;
    
    const sanitized = { ...context };
    
    // Mask sensitive data
    if (sanitized.email) sanitized.email = this.maskData(sanitized.email, 'email');
    if (sanitized.phone) sanitized.phone = this.maskData(sanitized.phone, 'phone');
    if (sanitized.ssn) sanitized.ssn = this.maskData(sanitized.ssn, 'ssn');
    if (sanitized.accountNumber) sanitized.accountNumber = this.maskData(sanitized.accountNumber, 'account');
    
    // Remove completely sensitive data
    delete sanitized.password;
    delete sanitized.apiKey;
    delete sanitized.secret;
    delete sanitized.token;
    
    return sanitized;
  }
  
  maskBusinessData(businessData) {
    const masked = { ...businessData };
    
    if (masked.amount && typeof masked.amount === 'number') {
      // Don't mask amount, it's needed for business analysis
    }
    
    if (masked.paymentMethod && typeof masked.paymentMethod === 'string') {
      if (masked.paymentMethod.includes('card')) {
        masked.paymentMethod = 'card_****';
      }
    }
    
    return masked;
  }
  
  getTransactionSummary(timeRange = 3600000) { // 1 hour default
    const since = Date.now() - timeRange;
    const transactions = Array.from(this.completedTransactions.values())
      .filter(t => t.endTime >= since);
    
    const summary = {
      totalTransactions: transactions.length,
      successfulTransactions: transactions.filter(t => t.status === 'success').length,
      failedTransactions: transactions.filter(t => t.status === 'failure').length,
      averageDuration: transactions.length > 0 ? 
        transactions.reduce((sum, t) => sum + t.duration, 0) / transactions.length : 0,
      totalRevenue: transactions
        .filter(t => t.status === 'success')
        .reduce((sum, t) => sum + (t.businessData.amount || 0), 0),
      transactionTypes: {},
      timeRange: {
        from: new Date(since).toISOString(),
        to: new Date().toISOString()
      }
    };
    
    // Group by transaction type
    transactions.forEach(t => {
      const type = t.transactionType;
      if (!summary.transactionTypes[type]) {
        summary.transactionTypes[type] = { count: 0, revenue: 0, avgDuration: 0 };
      }
      summary.transactionTypes[type].count++;
      if (t.status === 'success') {
        summary.transactionTypes[type].revenue += t.businessData.amount || 0;
      }
      summary.transactionTypes[type].avgDuration = 
        (summary.transactionTypes[type].avgDuration * (summary.transactionTypes[type].count - 1) + t.duration) / 
        summary.transactionTypes[type].count;
    });
    
    return summary;
  }
  
  getBusinessMetrics(period = 'today') {
    const metrics = {};
    
    // Get metrics for different transaction types
    for (const [type, data] of this.metricsCollector.transactionCounts.entries()) {
      metrics[type] = this.metricsCollector.getMetrics(type);
    }
    
    return {
      period,
      timestamp: new Date().toISOString(),
      transactionMetrics: metrics,
      totalTransactions: Object.values(metrics).reduce((sum, m) => sum + m.transactionCount, 0),
      totalRevenue: Object.values(metrics).reduce((sum, m) => sum + m.totalRevenue, 0),
      overallSuccessRate: this.calculateOverallSuccessRate(metrics)
    };
  }
  
  calculateOverallSuccessRate(metrics) {
    const rates = Object.values(metrics).map(m => m.successRate);
    return rates.length > 0 ? rates.reduce((sum, rate) => sum + rate, 0) / rates.length : 100;
  }
  
  cleanup() {
    const now = Date.now();
    const retentionCutoff = now - this.options.retentionPeriod;
    
    // Clean up old completed transactions
    for (const [transactionId, transaction] of this.completedTransactions.entries()) {
      if (transaction.endTime < retentionCutoff) {
        this.completedTransactions.delete(transactionId);
      }
    }
    
    // Clean up old workflow states
    for (const [instanceId, instance] of this.workflowStates.entries()) {
      if (instance.endTime && instance.endTime < retentionCutoff) {
        this.workflowStates.delete(instanceId);
      }
    }
  }
  
  destroy() {
    // Flush any remaining logs
    this.flushLogs();
    
    // Clear intervals
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
    }
    
    // Perform final cleanup
    this.cleanup();
    
    this.logger.info('Business Transaction logger destroyed', {
      event: 'business_logger_destroyed',
      transactionsLogged: this.completedTransactions.size
    });
  }
}
```

## Production Usage Examples

### **Express.js E-commerce Application with Business Transaction Logging**
```javascript
// Production E-commerce app with comprehensive business transaction logging
const express = require('express');
const BusinessTransactionLogger = require('./BusinessTransactionLogger');

class EcommerceApplication {
  constructor() {
    this.app = express();
    
    // Initialize business transaction logger
    this.businessLogger = new BusinessTransactionLogger({
      applicationName: 'ecommerce-platform',
      version: process.env.APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      
      // Enable comprehensive tracking
      trackTransactionSteps: true,
      trackBusinessEvents: true,
      trackFinancialTransactions: true,
      trackUserActions: true,
      trackWorkflowStates: true,
      trackCompensatingActions: true,
      
      // Business metrics
      calculateTransactionMetrics: true,
      trackRevenue: true,
      trackConversions: true,
      trackCustomerLifecycle: true,
      
      // Security and compliance
      enableDataMasking: true,
      complianceMode: process.env.COMPLIANCE_MODE || 'pci',
      auditLevel: 'comprehensive',
      
      // Performance
      enableAsyncLogging: true,
      batchSize: 50,
      flushInterval: 3000
    });
    
    this.setupMiddleware();
    this.setupRoutes();
    this.setupEventHandlers();
  }
  
  setupMiddleware() {
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));
    
    // Business event tracking middleware
    this.app.use((req, res, next) => {
      req.businessContext = {
        sessionId: req.sessionID || `session_${Date.now()}`,
        userId: req.user?.id,
        customerId: req.customer?.id,
        correlationId: req.headers['x-correlation-id'] || `corr_${Date.now()}`,
        channel: 'web',
        region: req.headers['x-region'] || 'US'
      };
      
      next();
    });
  }
  
  setupEventHandlers() {
    // Handle business events
    this.businessLogger.on('businessEvent', (event) => {
      if (event.event === 'transaction_completed' && event.status === 'failure') {
        this.handleFailedTransaction(event);
      }
    });
  }
  
  setupRoutes() {
    // Order processing endpoint
    this.app.post('/api/orders', async (req, res) => {
      let transaction = null;
      
      try {
        const { items, shippingAddress, paymentMethod, customerId } = req.body;
        
        // Calculate order total
        const orderTotal = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
        
        // Start business transaction
        transaction = await this.businessLogger.startTransaction('order_processing', {
          ...req.businessContext,
          customerId,
          amount: orderTotal,
          currency: 'USD',
          paymentMethod,
          productIds: items.map(item => item.productId),
          orderNumber: `ORD-${Date.now()}`
        });
        
        // Step 1: Validate order
        await this.businessLogger.addTransactionStep(transaction.transactionId, 'validate_order', {
          itemCount: items.length,
          totalAmount: orderTotal
        });
        
        const validationResult = await this.validateOrder(items, shippingAddress);
        await this.businessLogger.completeTransactionStep(transaction.transactionId, 0, validationResult);
        
        // Step 2: Check inventory
        await this.businessLogger.addTransactionStep(transaction.transactionId, 'check_inventory', {
          productIds: items.map(item => item.productId)
        });
        
        const inventoryResult = await this.checkInventory(items);
        await this.businessLogger.completeTransactionStep(transaction.transactionId, 1, inventoryResult);
        
        if (!inventoryResult.available) {
          throw new Error('Insufficient inventory');
        }
        
        // Step 3: Process payment
        await this.businessLogger.addTransactionStep(transaction.transactionId, 'process_payment', {
          amount: orderTotal,
          paymentMethod,
          customerId
        });
        
        const paymentResult = await this.processPayment(orderTotal, paymentMethod, customerId);
        await this.businessLogger.completeTransactionStep(transaction.transactionId, 2, paymentResult);
        
        // Register compensation for payment
        this.businessLogger.compensationManager.registerCompensation(
          transaction.transactionId,
          () => this.refundPayment(paymentResult.paymentId)
        );
        
        // Step 4: Create order
        await this.businessLogger.addTransactionStep(transaction.transactionId, 'create_order', {
          customerId,
          orderTotal
        });
        
        const order = await this.createOrder({
          customerId,
          items,
          shippingAddress,
          paymentId: paymentResult.paymentId,
          total: orderTotal
        });
        
        await this.businessLogger.completeTransactionStep(transaction.transactionId, 3, { orderId: order.id });
        
        // Step 5: Update inventory
        await this.businessLogger.addTransactionStep(transaction.transactionId, 'update_inventory');
        
        const inventoryUpdate = await this.updateInventory(items);
        await this.businessLogger.completeTransactionStep(transaction.transactionId, 4, inventoryUpdate);
        
        // Register compensation for inventory
        this.businessLogger.compensationManager.registerCompensation(
          transaction.transactionId,
          () => this.restoreInventory(items)
        );
        
        // Complete transaction
        await this.businessLogger.completeTransaction(
          transaction.transactionId,
          'success',
          { orderId: order.id, amount: orderTotal }
        );
        
        // Track business events
        this.businessLogger.trackBusinessEvent('order_placed', {
          customerId,
          orderId: order.id,
          value: orderTotal,
          itemCount: items.length,
          paymentMethod
        });
        
        res.json({
          success: true,
          orderId: order.id,
          transactionId: transaction.transactionId,
          total: orderTotal
        });
        
      } catch (error) {
        console.error('Order processing error:', error);
        
        if (transaction) {
          await this.businessLogger.completeTransaction(
            transaction.transactionId,
            'failure',
            null,
            error
          );
        }
        
        res.status(500).json({
          success: false,
          message: 'Order processing failed',
          transactionId: transaction?.transactionId
        });
      }
    });
    
    // Customer registration endpoint
    this.app.post('/api/customers/register', async (req, res) => {
      let workflow = null;
      
      try {
        const { email, firstName, lastName, phone, address } = req.body;
        
        // Start customer onboarding workflow
        workflow = await this.businessLogger.startBusinessWorkflow('customer_onboarding', {
          ...req.businessContext,
          email,
          firstName,
          lastName,
          registrationChannel: 'web'
        });
        
        // Step 1: Validate information
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 0, 'running');
        
        const validationResult = await this.validateCustomerInfo({ email, firstName, lastName, phone });
        
        if (!validationResult.valid) {
          await this.businessLogger.updateWorkflowStep(
            workflow.instanceId, 0, 'failed', null, new Error('Invalid customer information')
          );
          throw new Error('Invalid customer information');
        }
        
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 0, 'completed', validationResult);
        
        // Step 2: Perform KYC (simplified)
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 1, 'running');
        
        const kycResult = await this.performKYC({ email, firstName, lastName });
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 1, 'completed', kycResult);
        
        // Step 3: Create account
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 2, 'running');
        
        const customer = await this.createCustomerAccount({
          email, firstName, lastName, phone, address
        });
        
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 2, 'completed', { customerId: customer.id });
        
        // Step 4: Setup preferences
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 3, 'running');
        
        const preferences = await this.setupCustomerPreferences(customer.id);
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 3, 'completed', preferences);
        
        // Step 5: Send welcome
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 4, 'running');
        
        await this.sendWelcomeEmail(customer.id, email);
        await this.businessLogger.updateWorkflowStep(workflow.instanceId, 4, 'completed', { emailSent: true });
        
        // Track business event
        this.businessLogger.trackBusinessEvent('customer_registered', {
          customerId: customer.id,
          email,
          registrationChannel: 'web',
          workflowInstanceId: workflow.instanceId
        });
        
        res.json({
          success: true,
          customerId: customer.id,
          workflowInstanceId: workflow.instanceId
        });
        
      } catch (error) {
        console.error('Customer registration error:', error);
        
        if (workflow) {
          const currentStep = workflow.currentStep;
          await this.businessLogger.updateWorkflowStep(
            workflow.instanceId, currentStep, 'failed', null, error
          );
        }
        
        res.status(500).json({
          success: false,
          message: 'Customer registration failed',
          workflowInstanceId: workflow?.instanceId
        });
      }
    });
    
    // Business analytics endpoint
    this.app.get('/api/analytics/business-metrics', async (req, res) => {
      try {
        const { period = 'today' } = req.query;
        
        const metrics = this.businessLogger.getBusinessMetrics(period);
        const transactionSummary = this.businessLogger.getTransactionSummary();
        
        // Track analytics access
        this.businessLogger.trackBusinessEvent('analytics_accessed', {
          ...req.businessContext,
          period,
          metricsRequested: true
        });
        
        res.json({
          metrics,
          transactionSummary,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error('Analytics error:', error);
        res.status(500).json({
          success: false,
          message: 'Failed to retrieve business metrics'
        });
      }
    });
    
    // Customer insights endpoint
    this.app.get('/api/customers/:customerId/insights', async (req, res) => {
      try {
        const { customerId } = req.params;
        
        const insights = this.businessLogger.businessIntelligence.getCustomerInsights(customerId);
        
        if (!insights) {
          return res.status(404).json({
            success: false,
            message: 'Customer not found'
          });
        }
        
        // Track insights access
        this.businessLogger.trackBusinessEvent('customer_insights_accessed', {
          ...req.businessContext,
          targetCustomerId: customerId
        });
        
        res.json({
          customerId,
          insights,
          timestamp: new Date().toISOString()
        });
        
      } catch (error) {
        console.error('Customer insights error:', error);
        res.status(500).json({
          success: false,
          message: 'Failed to retrieve customer insights'
        });
      }
    });
  }
  
  handleFailedTransaction(event) {
    console.warn('Failed business transaction detected:', {
      transactionId: event.transactionId,
      transactionType: event.transactionType,
      error: event.error
    });
    
    // Send alert to business team
    this.sendBusinessAlert({
      type: 'transaction_failure',
      transactionId: event.transactionId,
      transactionType: event.transactionType,
      error: event.error,
      impact: this.assessTransactionFailureImpact(event)
    });
  }
  
  assessTransactionFailureImpact(event) {
    const amount = event.businessData?.amount || 0;
    
    if (amount > 1000) return 'high';
    if (amount > 100) return 'medium';
    return 'low';
  }
  
  sendBusinessAlert(alert) {
    console.log('BUSINESS ALERT:', alert);
    // Implementation would send to business monitoring system
  }
  
  // Mock business operations (replace with real implementations)
  async validateOrder(items, shippingAddress) {
    // Simulate order validation
    await new Promise(resolve => setTimeout(resolve, 100));
    return { valid: true, checkedItems: items.length };
  }
  
  async checkInventory(items) {
    // Simulate inventory check
    await new Promise(resolve => setTimeout(resolve, 200));
    return { available: true, reservedItems: items.length };
  }
  
  async processPayment(amount, paymentMethod, customerId) {
    // Simulate payment processing
    await new Promise(resolve => setTimeout(resolve, 1000));
    return { 
      paymentId: `pay_${Date.now()}`,
      amount,
      status: 'completed',
      transactionFee: amount * 0.029
    };
  }
  
  async createOrder(orderData) {
    // Simulate order creation
    await new Promise(resolve => setTimeout(resolve, 300));
    return { 
      id: `order_${Date.now()}`,
      ...orderData,
      status: 'confirmed',
      createdAt: new Date().toISOString()
    };
  }
  
  async updateInventory(items) {
    // Simulate inventory update
    await new Promise(resolve => setTimeout(resolve, 150));
    return { updatedItems: items.length };
  }
  
  async refundPayment(paymentId) {
    console.log(`Refunding payment ${paymentId}`);
    return { refundId: `ref_${Date.now()}`, status: 'completed' };
  }
  
  async restoreInventory(items) {
    console.log(`Restoring inventory for ${items.length} items`);
    return { restoredItems: items.length };
  }
  
  async validateCustomerInfo(customerInfo) {
    await new Promise(resolve => setTimeout(resolve, 100));
    return { valid: true, score: 95 };
  }
  
  async performKYC(customerInfo) {
    await new Promise(resolve => setTimeout(resolve, 500));
    return { passed: true, riskScore: 'low', verificationId: `kyc_${Date.now()}` };
  }
  
  async createCustomerAccount(customerData) {
    await new Promise(resolve => setTimeout(resolve, 200));
    return { 
      id: `cust_${Date.now()}`,
      ...customerData,
      status: 'active',
      createdAt: new Date().toISOString()
    };
  }
  
  async setupCustomerPreferences(customerId) {
    await new Promise(resolve => setTimeout(resolve, 100));
    return { preferences: ['email_notifications', 'sms_alerts'], customerId };
  }
  
  async sendWelcomeEmail(customerId, email) {
    await new Promise(resolve => setTimeout(resolve, 200));
    console.log(`Welcome email sent to ${email} for customer ${customerId}`);
    return { emailId: `email_${Date.now()}`, sent: true };
  }
  
  start() {
    const port = process.env.PORT || 3000;
    this.app.listen(port, () => {
      console.log(`E-commerce application listening on port ${port}`);
    });
  }
}

// Usage
const app = new EcommerceApplication();
app.start();
```

---

## Business Transaction Logging Best Practices

### **Essential Business Events to Log**

1. **Transaction Lifecycle**
   - Transaction initiation and completion
   - Step-by-step process tracking
   - Success/failure outcomes
   - Compensation actions

2. **Business Process Flows**
   - Workflow state changes
   - Approval processes
   - Business rule evaluations
   - Process timeouts and escalations

3. **Financial Transactions**
   - Payment processing events
   - Revenue recognition
   - Refunds and adjustments
   - Financial reconciliation

### **Key Considerations**

1. **Business Context**
   - Include relevant business metadata
   - Track customer journey touchpoints
   - Maintain transaction correlation
   - Enable business intelligence extraction

2. **Compliance & Audit**
   - Ensure audit trail completeness
   - Implement data retention policies
   - Support regulatory requirements
   - Enable transaction reconstruction

**Next Section**: Ready to continue with **3.1.5 External Service Calls** - logging integration with external APIs and services!
