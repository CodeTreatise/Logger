# 3.1.1 Application Start/Stop Events

## Understanding Application Lifecycle Logging

Application start/stop events are critical logging points that provide visibility into application lifecycle, system health, configuration validation, and operational readiness. Proper lifecycle logging enables effective monitoring, debugging, and operational management.

## Why Log Application Start/Stop Events?

### **Operational Benefits**
- **Health Monitoring**: Verify application startup success and graceful shutdown
- **Performance Tracking**: Monitor startup times and resource initialization
- **Configuration Validation**: Confirm proper configuration loading and environment setup
- **Dependency Verification**: Validate external service connections and resource availability
- **Audit Trail**: Maintain records of application deployments and restarts
- **Troubleshooting**: Identify startup failures and shutdown issues

### **Business Benefits**
- **Service Availability**: Track service uptime and availability metrics
- **Deployment Monitoring**: Monitor deployment success rates
- **Capacity Planning**: Analyze startup patterns and resource requirements
- **Compliance**: Maintain audit logs for regulatory requirements

## Advanced Application Lifecycle Logger

### 1. **Comprehensive Lifecycle Logging Implementation**

```javascript
// Advanced application lifecycle logging system
const { EventEmitter } = require('events');

class ApplicationLifecycleLogger extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      applicationName: options.applicationName || process.env.APP_NAME || 'unknown-app',
      version: options.version || process.env.APP_VERSION || '1.0.0',
      environment: options.environment || process.env.NODE_ENV || 'development',
      instanceId: options.instanceId || this.generateInstanceId(),
      
      // Logging configuration
      logStartupMetrics: options.logStartupMetrics !== false,
      logShutdownMetrics: options.logShutdownMetrics !== false,
      logConfigurationDetails: options.logConfigurationDetails !== false,
      logDependencyChecks: options.logDependencyChecks !== false,
      logResourceUsage: options.logResourceUsage !== false,
      
      // Startup phases to track
      startupPhases: options.startupPhases || [
        'initialization',
        'configuration',
        'dependencies',
        'resources',
        'services',
        'ready'
      ],
      
      // Dependency checks
      dependencies: options.dependencies || [],
      
      // Health checks
      healthChecks: options.healthChecks || [],
      
      // Graceful shutdown timeout
      shutdownTimeout: options.shutdownTimeout || 30000,
      
      // Metrics collection
      collectMetrics: options.collectMetrics !== false,
      metricsInterval: options.metricsInterval || 60000,
      
      ...options
    };
    
    this.lifecycle = {
      startTime: null,
      readyTime: null,
      shutdownStartTime: null,
      shutdownEndTime: null,
      phase: 'not-started',
      phases: {},
      gracefulShutdown: false,
      exitCode: null,
      shutdownReason: null
    };
    
    this.metrics = this.initializeMetrics();
    this.logger = this.initializeLogger();
    this.phaseTimers = new Map();
    this.dependencyStatus = new Map();
    this.healthCheckStatus = new Map();
    this.resourceMonitor = this.initializeResourceMonitor();
    
    this.setupProcessEventHandlers();
  }
  
  initializeMetrics() {
    return {
      startupDuration: 0,
      shutdownDuration: 0,
      memoryUsageAtStart: 0,
      memoryUsageAtReady: 0,
      memoryUsageAtShutdown: 0,
      cpuUsageAtStart: 0,
      dependenciesChecked: 0,
      dependenciesHealthy: 0,
      healthChecksPassed: 0,
      configurationItemsLoaded: 0,
      resourcesInitialized: 0,
      servicesStarted: 0,
      restartCount: this.getRestartCount(),
      previousCrashes: this.getCrashHistory(),
      uptime: 0
    };
  }
  
  initializeLogger() {
    // Initialize your preferred logger here
    // For this example, we'll use console with structured logging
    return {
      info: (message, metadata) => this.logMessage('INFO', message, metadata),
      warn: (message, metadata) => this.logMessage('WARN', message, metadata),
      error: (message, metadata) => this.logMessage('ERROR', message, metadata),
      debug: (message, metadata) => this.logMessage('DEBUG', message, metadata)
    };
  }
  
  initializeResourceMonitor() {
    return {
      startTime: Date.now(),
      
      getMemoryUsage: () => {
        const usage = process.memoryUsage();
        return {
          rss: Math.round(usage.rss / 1024 / 1024 * 100) / 100, // MB
          heapTotal: Math.round(usage.heapTotal / 1024 / 1024 * 100) / 100,
          heapUsed: Math.round(usage.heapUsed / 1024 / 1024 * 100) / 100,
          external: Math.round(usage.external / 1024 / 1024 * 100) / 100
        };
      },
      
      getCpuUsage: () => {
        const usage = process.cpuUsage();
        return {
          user: usage.user,
          system: usage.system,
          userPercent: Math.round((usage.user / 1000000) * 100) / 100,
          systemPercent: Math.round((usage.system / 1000000) * 100) / 100
        };
      },
      
      getSystemInfo: () => {
        const os = require('os');
        return {
          hostname: os.hostname(),
          platform: os.platform(),
          arch: os.arch(),
          nodeVersion: process.version,
          pid: process.pid,
          ppid: process.ppid,
          uptime: process.uptime(),
          loadAverage: os.loadavg(),
          totalMemory: Math.round(os.totalmem() / 1024 / 1024),
          freeMemory: Math.round(os.freemem() / 1024 / 1024),
          cpuCount: os.cpus().length
        };
      }
    };
  }
  
  setupProcessEventHandlers() {
    // Graceful shutdown handlers
    process.on('SIGTERM', () => this.initiateShutdown('SIGTERM'));
    process.on('SIGINT', () => this.initiateShutdown('SIGINT'));
    process.on('SIGHUP', () => this.initiateShutdown('SIGHUP'));
    
    // Error handlers
    process.on('uncaughtException', (error) => this.handleCriticalError('uncaughtException', error));
    process.on('unhandledRejection', (reason, promise) => this.handleCriticalError('unhandledRejection', { reason, promise }));
    
    // Warning handler
    process.on('warning', (warning) => this.handleWarning(warning));
    
    // Exit handler
    process.on('exit', (code) => this.handleExit(code));
  }
  
  generateInstanceId() {
    const os = require('os');
    const crypto = require('crypto');
    
    const identifier = `${os.hostname()}-${process.pid}-${Date.now()}`;
    return crypto.createHash('md5').update(identifier).digest('hex').substring(0, 8);
  }
  
  getRestartCount() {
    // In a real implementation, this would read from persistent storage
    // For now, we'll check environment variables or default to 0
    return parseInt(process.env.APP_RESTART_COUNT || '0', 10);
  }
  
  getCrashHistory() {
    // In a real implementation, this would read crash history from persistent storage
    return [];
  }
  
  logMessage(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      lifecycle: {
        phase: this.lifecycle.phase,
        uptime: this.lifecycle.startTime ? Date.now() - this.lifecycle.startTime : 0
      },
      ...metadata
    };
    
    // In a real implementation, this would use your preferred logging library
    console.log(JSON.stringify(logEntry));
    
    this.emit('log', logEntry);
  }
  
  async startApplication() {
    try {
      this.lifecycle.startTime = Date.now();
      this.lifecycle.phase = 'starting';
      
      this.logApplicationStart();
      
      // Execute startup phases
      for (const phase of this.options.startupPhases) {
        await this.executeStartupPhase(phase);
      }
      
      this.lifecycle.readyTime = Date.now();
      this.lifecycle.phase = 'ready';
      this.metrics.startupDuration = this.lifecycle.readyTime - this.lifecycle.startTime;
      
      this.logApplicationReady();
      this.startMetricsCollection();
      
      return true;
      
    } catch (error) {
      this.lifecycle.phase = 'failed';
      this.logStartupFailure(error);
      throw error;
    }
  }
  
  logApplicationStart() {
    const systemInfo = this.resourceMonitor.getSystemInfo();
    const memoryUsage = this.resourceMonitor.getMemoryUsage();
    const cpuUsage = this.resourceMonitor.getCpuUsage();
    
    this.metrics.memoryUsageAtStart = memoryUsage.heapUsed;
    this.metrics.cpuUsageAtStart = cpuUsage.userPercent + cpuUsage.systemPercent;
    
    this.logger.info('Application startup initiated', {
      event: 'application_start',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      startTime: new Date(this.lifecycle.startTime).toISOString(),
      restartCount: this.metrics.restartCount,
      
      system: systemInfo,
      resources: {
        memory: memoryUsage,
        cpu: cpuUsage
      },
      
      configuration: this.options.logConfigurationDetails ? {
        nodeVersion: process.version,
        nodeFlags: process.execArgv,
        arguments: process.argv,
        workingDirectory: process.cwd(),
        environmentVariables: this.getSafeEnvironmentVariables()
      } : undefined,
      
      dependencies: {
        count: this.options.dependencies.length,
        list: this.options.dependencies.map(dep => ({
          name: dep.name,
          type: dep.type,
          critical: dep.critical !== false
        }))
      }
    });
  }
  
  async executeStartupPhase(phaseName) {
    const phaseStartTime = Date.now();
    this.lifecycle.phase = phaseName;
    this.phaseTimers.set(phaseName, phaseStartTime);
    
    this.logger.info(`Startup phase: ${phaseName}`, {
      event: 'startup_phase_start',
      phase: phaseName,
      phaseStartTime: new Date(phaseStartTime).toISOString()
    });
    
    try {
      switch (phaseName) {
        case 'initialization':
          await this.executeInitializationPhase();
          break;
        case 'configuration':
          await this.executeConfigurationPhase();
          break;
        case 'dependencies':
          await this.executeDependenciesPhase();
          break;
        case 'resources':
          await this.executeResourcesPhase();
          break;
        case 'services':
          await this.executeServicesPhase();
          break;
        case 'ready':
          await this.executeReadinessPhase();
          break;
        default:
          await this.executeCustomPhase(phaseName);
      }
      
      const phaseEndTime = Date.now();
      const phaseDuration = phaseEndTime - phaseStartTime;
      
      this.lifecycle.phases[phaseName] = {
        startTime: phaseStartTime,
        endTime: phaseEndTime,
        duration: phaseDuration,
        success: true
      };
      
      this.logger.info(`Startup phase completed: ${phaseName}`, {
        event: 'startup_phase_complete',
        phase: phaseName,
        duration: phaseDuration,
        phaseEndTime: new Date(phaseEndTime).toISOString()
      });
      
    } catch (error) {
      const phaseEndTime = Date.now();
      const phaseDuration = phaseEndTime - phaseStartTime;
      
      this.lifecycle.phases[phaseName] = {
        startTime: phaseStartTime,
        endTime: phaseEndTime,
        duration: phaseDuration,
        success: false,
        error: error.message
      };
      
      this.logger.error(`Startup phase failed: ${phaseName}`, {
        event: 'startup_phase_failed',
        phase: phaseName,
        duration: phaseDuration,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name
        }
      });
      
      throw error;
    }
  }
  
  async executeInitializationPhase() {
    // Basic initialization logic
    this.logger.debug('Initializing application core components');
    
    // Simulate initialization work
    await new Promise(resolve => setTimeout(resolve, 100));
    
    this.emit('phase:initialization:complete');
  }
  
  async executeConfigurationPhase() {
    this.logger.debug('Loading application configuration');
    
    // Simulate configuration loading
    const configItems = [
      'database_url', 'redis_url', 'api_keys', 'feature_flags',
      'rate_limits', 'timeouts', 'logging_config'
    ];
    
    for (const item of configItems) {
      // Simulate config loading time
      await new Promise(resolve => setTimeout(resolve, 50));
      this.metrics.configurationItemsLoaded++;
      
      this.logger.debug(`Configuration loaded: ${item}`, {
        event: 'configuration_item_loaded',
        item,
        source: 'environment' // or 'file', 'service', etc.
      });
    }
    
    if (this.options.logConfigurationDetails) {
      this.logger.info('Configuration summary', {
        event: 'configuration_summary',
        itemsLoaded: this.metrics.configurationItemsLoaded,
        environment: this.options.environment
      });
    }
    
    this.emit('phase:configuration:complete');
  }
  
  async executeDependenciesPhase() {
    this.logger.debug('Checking application dependencies');
    
    for (const dependency of this.options.dependencies) {
      await this.checkDependency(dependency);
    }
    
    const healthyDependencies = Array.from(this.dependencyStatus.values())
      .filter(status => status.healthy).length;
    
    this.metrics.dependenciesChecked = this.options.dependencies.length;
    this.metrics.dependenciesHealthy = healthyDependencies;
    
    if (healthyDependencies < this.options.dependencies.length) {
      const unhealthyDeps = Array.from(this.dependencyStatus.entries())
        .filter(([_, status]) => !status.healthy)
        .map(([name, status]) => ({ name, error: status.error }));
      
      this.logger.warn('Some dependencies are unhealthy', {
        event: 'dependencies_check_warning',
        unhealthyDependencies: unhealthyDeps,
        healthyCount: healthyDependencies,
        totalCount: this.options.dependencies.length
      });
    } else {
      this.logger.info('All dependencies are healthy', {
        event: 'dependencies_check_success',
        dependencyCount: this.options.dependencies.length
      });
    }
    
    this.emit('phase:dependencies:complete');
  }
  
  async checkDependency(dependency) {
    const startTime = Date.now();
    
    try {
      // Simulate dependency check
      switch (dependency.type) {
        case 'database':
          await this.checkDatabaseDependency(dependency);
          break;
        case 'redis':
          await this.checkRedisDependency(dependency);
          break;
        case 'service':
          await this.checkServiceDependency(dependency);
          break;
        case 'file':
          await this.checkFileDependency(dependency);
          break;
        default:
          await this.checkGenericDependency(dependency);
      }
      
      const duration = Date.now() - startTime;
      
      this.dependencyStatus.set(dependency.name, {
        healthy: true,
        duration,
        lastChecked: new Date().toISOString()
      });
      
      this.logger.info(`Dependency check passed: ${dependency.name}`, {
        event: 'dependency_check_success',
        dependency: dependency.name,
        type: dependency.type,
        duration,
        critical: dependency.critical
      });
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      this.dependencyStatus.set(dependency.name, {
        healthy: false,
        duration,
        error: error.message,
        lastChecked: new Date().toISOString()
      });
      
      const logLevel = dependency.critical !== false ? 'error' : 'warn';
      
      this.logger[logLevel](`Dependency check failed: ${dependency.name}`, {
        event: 'dependency_check_failed',
        dependency: dependency.name,
        type: dependency.type,
        duration,
        critical: dependency.critical,
        error: {
          message: error.message,
          name: error.name
        }
      });
      
      if (dependency.critical !== false) {
        throw new Error(`Critical dependency failed: ${dependency.name} - ${error.message}`);
      }
    }
  }
  
  async checkDatabaseDependency(dependency) {
    // Simulate database connection check
    await new Promise(resolve => setTimeout(resolve, 200));
    
    // In real implementation, you would actually connect to the database
    if (Math.random() < 0.9) { // 90% success rate simulation
      return true;
    }
    
    throw new Error('Database connection timeout');
  }
  
  async checkRedisDependency(dependency) {
    // Simulate Redis connection check
    await new Promise(resolve => setTimeout(resolve, 100));
    
    if (Math.random() < 0.95) { // 95% success rate simulation
      return true;
    }
    
    throw new Error('Redis connection failed');
  }
  
  async checkServiceDependency(dependency) {
    // Simulate external service check
    await new Promise(resolve => setTimeout(resolve, 300));
    
    if (Math.random() < 0.85) { // 85% success rate simulation
      return true;
    }
    
    throw new Error('Service health check failed');
  }
  
  async checkFileDependency(dependency) {
    // Simulate file system check
    const fs = require('fs').promises;
    
    try {
      await fs.access(dependency.path || '/tmp');
      return true;
    } catch (error) {
      throw new Error(`File/directory not accessible: ${dependency.path}`);
    }
  }
  
  async checkGenericDependency(dependency) {
    // Generic dependency check
    await new Promise(resolve => setTimeout(resolve, 150));
    return true;
  }
  
  async executeResourcesPhase() {
    this.logger.debug('Initializing application resources');
    
    const resources = [
      'thread_pool', 'connection_pool', 'cache_manager',
      'event_dispatcher', 'metrics_collector', 'health_monitor'
    ];
    
    for (const resource of resources) {
      // Simulate resource initialization
      await new Promise(resolve => setTimeout(resolve, 100));
      this.metrics.resourcesInitialized++;
      
      this.logger.debug(`Resource initialized: ${resource}`, {
        event: 'resource_initialized',
        resource
      });
    }
    
    this.logger.info('Resources initialization completed', {
      event: 'resources_phase_complete',
      resourcesInitialized: this.metrics.resourcesInitialized
    });
    
    this.emit('phase:resources:complete');
  }
  
  async executeServicesPhase() {
    this.logger.debug('Starting application services');
    
    const services = [
      'http_server', 'background_workers', 'scheduler',
      'metrics_exporter', 'health_endpoint', 'admin_interface'
    ];
    
    for (const service of services) {
      // Simulate service startup
      await new Promise(resolve => setTimeout(resolve, 200));
      this.metrics.servicesStarted++;
      
      this.logger.info(`Service started: ${service}`, {
        event: 'service_started',
        service
      });
    }
    
    this.logger.info('Services startup completed', {
      event: 'services_phase_complete',
      servicesStarted: this.metrics.servicesStarted
    });
    
    this.emit('phase:services:complete');
  }
  
  async executeReadinessPhase() {
    this.logger.debug('Performing readiness checks');
    
    // Execute health checks
    for (const healthCheck of this.options.healthChecks) {
      await this.performHealthCheck(healthCheck);
    }
    
    // Final resource check
    const memoryUsage = this.resourceMonitor.getMemoryUsage();
    this.metrics.memoryUsageAtReady = memoryUsage.heapUsed;
    
    this.logger.info('Readiness checks completed', {
      event: 'readiness_phase_complete',
      healthChecksPassed: this.metrics.healthChecksPassed,
      memoryUsage
    });
    
    this.emit('phase:ready:complete');
  }
  
  async executeCustomPhase(phaseName) {
    this.logger.debug(`Executing custom phase: ${phaseName}`);
    
    // Emit event for custom phase handling
    this.emit(`phase:${phaseName}:start`);
    
    // Allow custom phase implementation through events
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Custom phase ${phaseName} timed out`));
      }, 30000);
      
      this.once(`phase:${phaseName}:complete`, () => {
        clearTimeout(timeout);
        resolve();
      });
      
      this.once(`phase:${phaseName}:error`, (error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }
  
  async performHealthCheck(healthCheck) {
    const startTime = Date.now();
    
    try {
      // Simulate health check execution
      await new Promise(resolve => setTimeout(resolve, 100));
      
      const duration = Date.now() - startTime;
      this.metrics.healthChecksPassed++;
      
      this.healthCheckStatus.set(healthCheck.name, {
        healthy: true,
        duration,
        lastChecked: new Date().toISOString()
      });
      
      this.logger.debug(`Health check passed: ${healthCheck.name}`, {
        event: 'health_check_success',
        healthCheck: healthCheck.name,
        duration
      });
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      this.healthCheckStatus.set(healthCheck.name, {
        healthy: false,
        duration,
        error: error.message,
        lastChecked: new Date().toISOString()
      });
      
      this.logger.error(`Health check failed: ${healthCheck.name}`, {
        event: 'health_check_failed',
        healthCheck: healthCheck.name,
        duration,
        error: {
          message: error.message,
          name: error.name
        }
      });
      
      throw error;
    }
  }
  
  logApplicationReady() {
    const memoryUsage = this.resourceMonitor.getMemoryUsage();
    const systemInfo = this.resourceMonitor.getSystemInfo();
    
    this.logger.info('Application startup completed successfully', {
      event: 'application_ready',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      timing: {
        startTime: new Date(this.lifecycle.startTime).toISOString(),
        readyTime: new Date(this.lifecycle.readyTime).toISOString(),
        startupDuration: this.metrics.startupDuration,
        phases: this.lifecycle.phases
      },
      
      metrics: {
        dependenciesChecked: this.metrics.dependenciesChecked,
        dependenciesHealthy: this.metrics.dependenciesHealthy,
        resourcesInitialized: this.metrics.resourcesInitialized,
        servicesStarted: this.metrics.servicesStarted,
        healthChecksPassed: this.metrics.healthChecksPassed,
        configurationItemsLoaded: this.metrics.configurationItemsLoaded
      },
      
      resources: {
        memory: memoryUsage,
        system: {
          hostname: systemInfo.hostname,
          pid: systemInfo.pid,
          nodeVersion: systemInfo.nodeVersion,
          uptime: systemInfo.uptime
        }
      },
      
      dependencies: Object.fromEntries(this.dependencyStatus),
      healthChecks: Object.fromEntries(this.healthCheckStatus)
    });
    
    // Emit ready event
    this.emit('application:ready', {
      startupDuration: this.metrics.startupDuration,
      metrics: this.metrics
    });
  }
  
  logStartupFailure(error) {
    const failureTime = Date.now();
    const startupDuration = this.lifecycle.startTime ? 
      failureTime - this.lifecycle.startTime : 0;
    
    this.logger.error('Application startup failed', {
      event: 'application_startup_failed',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      timing: {
        startTime: this.lifecycle.startTime ? 
          new Date(this.lifecycle.startTime).toISOString() : null,
        failureTime: new Date(failureTime).toISOString(),
        startupDuration
      },
      
      failure: {
        phase: this.lifecycle.phase,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name
        }
      },
      
      phases: this.lifecycle.phases,
      dependencies: Object.fromEntries(this.dependencyStatus),
      resources: this.resourceMonitor.getMemoryUsage()
    });
    
    this.emit('application:startup:failed', { error, phase: this.lifecycle.phase });
  }
  
  async initiateShutdown(signal) {
    if (this.lifecycle.shutdownStartTime) {
      this.logger.warn('Shutdown already in progress', {
        event: 'shutdown_already_in_progress',
        signal,
        existingShutdownReason: this.lifecycle.shutdownReason
      });
      return;
    }
    
    this.lifecycle.shutdownStartTime = Date.now();
    this.lifecycle.shutdownReason = signal;
    this.lifecycle.phase = 'shutting-down';
    this.lifecycle.gracefulShutdown = true;
    
    this.logShutdownStart(signal);
    
    try {
      // Set shutdown timeout
      const shutdownTimeout = setTimeout(() => {
        this.logger.error('Graceful shutdown timeout exceeded', {
          event: 'shutdown_timeout',
          timeout: this.options.shutdownTimeout,
          forcingExit: true
        });
        
        this.lifecycle.gracefulShutdown = false;
        process.exit(1);
      }, this.options.shutdownTimeout);
      
      // Execute shutdown sequence
      await this.executeShutdownSequence();
      
      clearTimeout(shutdownTimeout);
      
      this.lifecycle.shutdownEndTime = Date.now();
      this.metrics.shutdownDuration = 
        this.lifecycle.shutdownEndTime - this.lifecycle.shutdownStartTime;
      
      this.logShutdownComplete();
      
      // Exit gracefully
      process.exit(0);
      
    } catch (error) {
      this.lifecycle.gracefulShutdown = false;
      this.logShutdownFailure(error);
      process.exit(1);
    }
  }
  
  logShutdownStart(signal) {
    const memoryUsage = this.resourceMonitor.getMemoryUsage();
    const uptime = this.lifecycle.startTime ? 
      Date.now() - this.lifecycle.startTime : 0;
    
    this.metrics.uptime = uptime;
    this.metrics.memoryUsageAtShutdown = memoryUsage.heapUsed;
    
    this.logger.info('Application shutdown initiated', {
      event: 'application_shutdown_start',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      shutdown: {
        signal,
        shutdownStartTime: new Date(this.lifecycle.shutdownStartTime).toISOString(),
        reason: signal,
        graceful: true
      },
      
      runtime: {
        uptime,
        startTime: this.lifecycle.startTime ? 
          new Date(this.lifecycle.startTime).toISOString() : null,
        readyTime: this.lifecycle.readyTime ? 
          new Date(this.lifecycle.readyTime).toISOString() : null
      },
      
      resources: {
        memory: memoryUsage,
        system: this.resourceMonitor.getSystemInfo()
      }
    });
  }
  
  async executeShutdownSequence() {
    const shutdownPhases = [
      'stop-accepting-requests',
      'drain-connections',
      'stop-background-workers',
      'cleanup-resources',
      'close-databases',
      'final-cleanup'
    ];
    
    for (const phase of shutdownPhases) {
      await this.executeShutdownPhase(phase);
    }
  }
  
  async executeShutdownPhase(phaseName) {
    const phaseStartTime = Date.now();
    
    this.logger.info(`Shutdown phase: ${phaseName}`, {
      event: 'shutdown_phase_start',
      phase: phaseName,
      phaseStartTime: new Date(phaseStartTime).toISOString()
    });
    
    try {
      // Simulate shutdown phase execution
      switch (phaseName) {
        case 'stop-accepting-requests':
          await this.stopAcceptingRequests();
          break;
        case 'drain-connections':
          await this.drainConnections();
          break;
        case 'stop-background-workers':
          await this.stopBackgroundWorkers();
          break;
        case 'cleanup-resources':
          await this.cleanupResources();
          break;
        case 'close-databases':
          await this.closeDatabases();
          break;
        case 'final-cleanup':
          await this.finalCleanup();
          break;
        default:
          await this.executeCustomShutdownPhase(phaseName);
      }
      
      const phaseEndTime = Date.now();
      const phaseDuration = phaseEndTime - phaseStartTime;
      
      this.logger.info(`Shutdown phase completed: ${phaseName}`, {
        event: 'shutdown_phase_complete',
        phase: phaseName,
        duration: phaseDuration,
        phaseEndTime: new Date(phaseEndTime).toISOString()
      });
      
    } catch (error) {
      const phaseEndTime = Date.now();
      const phaseDuration = phaseEndTime - phaseStartTime;
      
      this.logger.error(`Shutdown phase failed: ${phaseName}`, {
        event: 'shutdown_phase_failed',
        phase: phaseName,
        duration: phaseDuration,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name
        }
      });
      
      // Continue with shutdown even if phase fails
    }
  }
  
  async stopAcceptingRequests() {
    // Simulate stopping HTTP server
    await new Promise(resolve => setTimeout(resolve, 500));
    this.emit('shutdown:stop-accepting-requests:complete');
  }
  
  async drainConnections() {
    // Simulate draining existing connections
    await new Promise(resolve => setTimeout(resolve, 2000));
    this.emit('shutdown:drain-connections:complete');
  }
  
  async stopBackgroundWorkers() {
    // Simulate stopping background workers
    await new Promise(resolve => setTimeout(resolve, 1000));
    this.emit('shutdown:stop-background-workers:complete');
  }
  
  async cleanupResources() {
    // Simulate resource cleanup
    await new Promise(resolve => setTimeout(resolve, 500));
    this.emit('shutdown:cleanup-resources:complete');
  }
  
  async closeDatabases() {
    // Simulate database connection closure
    await new Promise(resolve => setTimeout(resolve, 1000));
    this.emit('shutdown:close-databases:complete');
  }
  
  async finalCleanup() {
    // Final cleanup tasks
    await new Promise(resolve => setTimeout(resolve, 200));
    this.emit('shutdown:final-cleanup:complete');
  }
  
  async executeCustomShutdownPhase(phaseName) {
    this.logger.debug(`Executing custom shutdown phase: ${phaseName}`);
    
    this.emit(`shutdown:${phaseName}:start`);
    
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error(`Custom shutdown phase ${phaseName} timed out`));
      }, 10000);
      
      this.once(`shutdown:${phaseName}:complete`, () => {
        clearTimeout(timeout);
        resolve();
      });
      
      this.once(`shutdown:${phaseName}:error`, (error) => {
        clearTimeout(timeout);
        reject(error);
      });
    });
  }
  
  logShutdownComplete() {
    const finalMemoryUsage = this.resourceMonitor.getMemoryUsage();
    
    this.logger.info('Application shutdown completed successfully', {
      event: 'application_shutdown_complete',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      shutdown: {
        reason: this.lifecycle.shutdownReason,
        graceful: this.lifecycle.gracefulShutdown,
        startTime: new Date(this.lifecycle.shutdownStartTime).toISOString(),
        endTime: new Date(this.lifecycle.shutdownEndTime).toISOString(),
        duration: this.metrics.shutdownDuration
      },
      
      runtime: {
        totalUptime: this.metrics.uptime,
        startTime: this.lifecycle.startTime ? 
          new Date(this.lifecycle.startTime).toISOString() : null,
        readyTime: this.lifecycle.readyTime ? 
          new Date(this.lifecycle.readyTime).toISOString() : null
      },
      
      metrics: {
        startupDuration: this.metrics.startupDuration,
        shutdownDuration: this.metrics.shutdownDuration,
        memoryUsage: {
          atStart: this.metrics.memoryUsageAtStart,
          atReady: this.metrics.memoryUsageAtReady,
          atShutdown: this.metrics.memoryUsageAtShutdown,
          final: finalMemoryUsage.heapUsed
        }
      }
    });
    
    this.emit('application:shutdown:complete', {
      graceful: this.lifecycle.gracefulShutdown,
      duration: this.metrics.shutdownDuration
    });
  }
  
  logShutdownFailure(error) {
    this.logger.error('Application shutdown failed', {
      event: 'application_shutdown_failed',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      shutdown: {
        reason: this.lifecycle.shutdownReason,
        graceful: false,
        startTime: new Date(this.lifecycle.shutdownStartTime).toISOString(),
        duration: Date.now() - this.lifecycle.shutdownStartTime
      },
      
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name
      }
    });
    
    this.emit('application:shutdown:failed', { error });
  }
  
  handleCriticalError(type, errorInfo) {
    this.logger.error(`Critical error: ${type}`, {
      event: 'critical_error',
      errorType: type,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      error: errorInfo.reason ? {
        reason: errorInfo.reason,
        promise: errorInfo.promise?.toString()
      } : {
        message: errorInfo.message,
        stack: errorInfo.stack,
        name: errorInfo.name
      },
      
      runtime: {
        uptime: this.lifecycle.startTime ? 
          Date.now() - this.lifecycle.startTime : 0,
        phase: this.lifecycle.phase
      },
      
      resources: this.resourceMonitor.getMemoryUsage()
    });
    
    // Initiate emergency shutdown
    this.initiateShutdown(`critical-error-${type}`);
  }
  
  handleWarning(warning) {
    this.logger.warn('Process warning', {
      event: 'process_warning',
      warning: {
        name: warning.name,
        message: warning.message,
        stack: warning.stack
      },
      application: this.options.applicationName,
      instanceId: this.options.instanceId
    });
  }
  
  handleExit(code) {
    this.lifecycle.exitCode = code;
    
    const exitTime = Date.now();
    const totalUptime = this.lifecycle.startTime ? 
      exitTime - this.lifecycle.startTime : 0;
    
    this.logger.info('Application process exiting', {
      event: 'application_exit',
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      
      exit: {
        code,
        time: new Date(exitTime).toISOString(),
        graceful: this.lifecycle.gracefulShutdown,
        reason: this.lifecycle.shutdownReason || 'unknown'
      },
      
      runtime: {
        totalUptime,
        startTime: this.lifecycle.startTime ? 
          new Date(this.lifecycle.startTime).toISOString() : null,
        readyTime: this.lifecycle.readyTime ? 
          new Date(this.lifecycle.readyTime).toISOString() : null
      }
    });
  }
  
  startMetricsCollection() {
    if (!this.options.collectMetrics) return;
    
    this.metricsInterval = setInterval(() => {
      this.collectRuntimeMetrics();
    }, this.options.metricsInterval);
  }
  
  collectRuntimeMetrics() {
    const memoryUsage = this.resourceMonitor.getMemoryUsage();
    const cpuUsage = this.resourceMonitor.getCpuUsage();
    const uptime = this.lifecycle.startTime ? 
      Date.now() - this.lifecycle.startTime : 0;
    
    this.logger.debug('Runtime metrics', {
      event: 'runtime_metrics',
      application: this.options.applicationName,
      instanceId: this.options.instanceId,
      
      metrics: {
        uptime,
        memory: memoryUsage,
        cpu: cpuUsage,
        phase: this.lifecycle.phase
      },
      
      dependencies: Object.fromEntries(
        Array.from(this.dependencyStatus.entries())
          .map(([name, status]) => [name, { healthy: status.healthy }])
      )
    });
    
    this.emit('metrics:runtime', {
      uptime,
      memory: memoryUsage,
      cpu: cpuUsage,
      dependencies: this.dependencyStatus
    });
  }
  
  getSafeEnvironmentVariables() {
    const env = { ...process.env };
    const sensitiveKeys = [
      'password', 'secret', 'key', 'token', 'auth',
      'credentials', 'private', 'api_key'
    ];
    
    Object.keys(env).forEach(key => {
      const lowerKey = key.toLowerCase();
      if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {
        env[key] = '[REDACTED]';
      }
    });
    
    return env;
  }
  
  // Public API methods
  getLifecycleStatus() {
    return {
      phase: this.lifecycle.phase,
      startTime: this.lifecycle.startTime,
      readyTime: this.lifecycle.readyTime,
      uptime: this.lifecycle.startTime ? 
        Date.now() - this.lifecycle.startTime : 0,
      gracefulShutdown: this.lifecycle.gracefulShutdown
    };
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
  
  getDependencyStatus() {
    return Object.fromEntries(this.dependencyStatus);
  }
  
  getHealthStatus() {
    return Object.fromEntries(this.healthCheckStatus);
  }
  
  async stop() {
    await this.initiateShutdown('programmatic');
  }
  
  // Cleanup
  destroy() {
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
    }
    
    this.removeAllListeners();
  }
}
```

## Production Usage Examples

### **Basic Application Lifecycle Logging**
```javascript
// Basic Express.js application with lifecycle logging
const express = require('express');
const ApplicationLifecycleLogger = require('./ApplicationLifecycleLogger');

class WebApplication {
  constructor() {
    this.app = express();
    this.server = null;
    
    // Initialize lifecycle logger
    this.lifecycleLogger = new ApplicationLifecycleLogger({
      applicationName: 'web-api',
      version: process.env.APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      
      dependencies: [
        {
          name: 'postgresql',
          type: 'database',
          critical: true
        },
        {
          name: 'redis',
          type: 'redis',
          critical: false
        },
        {
          name: 'external-api',
          type: 'service',
          critical: true
        }
      ],
      
      healthChecks: [
        { name: 'database-health' },
        { name: 'memory-usage' },
        { name: 'response-time' }
      ]
    });
    
    this.setupEventHandlers();
  }
  
  setupEventHandlers() {
    // Listen for lifecycle events
    this.lifecycleLogger.on('application:ready', () => {
      console.log('Application is ready to serve requests');
    });
    
    this.lifecycleLogger.on('application:startup:failed', ({ error }) => {
      console.error('Application startup failed:', error.message);
      process.exit(1);
    });
    
    // Custom phase handlers
    this.lifecycleLogger.on('phase:services:start', async () => {
      await this.startHttpServer();
      this.lifecycleLogger.emit('phase:services:complete');
    });
    
    this.lifecycleLogger.on('shutdown:stop-accepting-requests:start', async () => {
      if (this.server) {
        this.server.close();
      }
      this.lifecycleLogger.emit('shutdown:stop-accepting-requests:complete');
    });
  }
  
  async startHttpServer() {
    const port = process.env.PORT || 3000;
    
    this.app.use(express.json());
    
    // Health endpoint
    this.app.get('/health', (req, res) => {
      const status = this.lifecycleLogger.getLifecycleStatus();
      const dependencies = this.lifecycleLogger.getDependencyStatus();
      
      res.json({
        status: status.phase === 'ready' ? 'healthy' : 'starting',
        uptime: status.uptime,
        dependencies
      });
    });
    
    // API endpoints
    this.app.get('/api/users', (req, res) => {
      res.json({ message: 'Users endpoint' });
    });
    
    this.server = this.app.listen(port, () => {
      console.log(`HTTP server listening on port ${port}`);
    });
  }
  
  async start() {
    try {
      await this.lifecycleLogger.startApplication();
      console.log('Application started successfully');
    } catch (error) {
      console.error('Failed to start application:', error);
      process.exit(1);
    }
  }
}

// Start the application
const app = new WebApplication();
app.start();
```

### **Microservice with Advanced Lifecycle Logging**
```javascript
// Advanced microservice with comprehensive lifecycle logging
class MicroserviceApp {
  constructor() {
    this.lifecycleLogger = new ApplicationLifecycleLogger({
      applicationName: 'user-service',
      version: process.env.APP_VERSION,
      environment: process.env.NODE_ENV,
      
      startupPhases: [
        'initialization',
        'configuration',
        'dependencies',
        'database-migration',
        'cache-warmup',
        'message-queues',
        'services',
        'ready'
      ],
      
      dependencies: [
        {
          name: 'postgresql',
          type: 'database',
          critical: true,
          config: {
            host: process.env.DB_HOST,
            port: process.env.DB_PORT
          }
        },
        {
          name: 'redis-cluster',
          type: 'redis',
          critical: true,
          config: {
            nodes: process.env.REDIS_NODES?.split(',')
          }
        },
        {
          name: 'auth-service',
          type: 'service',
          critical: true,
          config: {
            url: process.env.AUTH_SERVICE_URL
          }
        },
        {
          name: 'notification-queue',
          type: 'queue',
          critical: false,
          config: {
            url: process.env.RABBITMQ_URL
          }
        }
      ],
      
      healthChecks: [
        { name: 'database-connectivity' },
        { name: 'cache-connectivity' },
        { name: 'external-services' },
        { name: 'memory-pressure' },
        { name: 'disk-space' }
      ],
      
      // Enhanced logging options
      logStartupMetrics: true,
      logShutdownMetrics: true,
      logConfigurationDetails: true,
      logDependencyChecks: true,
      logResourceUsage: true,
      
      // Metrics collection
      collectMetrics: true,
      metricsInterval: 30000, // 30 seconds
      
      // Graceful shutdown
      shutdownTimeout: 45000 // 45 seconds
    });
    
    this.setupAdvancedEventHandlers();
  }
  
  setupAdvancedEventHandlers() {
    // Startup phase handlers
    this.lifecycleLogger.on('phase:database-migration:start', async () => {
      try {
        await this.runDatabaseMigrations();
        this.lifecycleLogger.emit('phase:database-migration:complete');
      } catch (error) {
        this.lifecycleLogger.emit('phase:database-migration:error', error);
      }
    });
    
    this.lifecycleLogger.on('phase:cache-warmup:start', async () => {
      try {
        await this.warmupCache();
        this.lifecycleLogger.emit('phase:cache-warmup:complete');
      } catch (error) {
        this.lifecycleLogger.emit('phase:cache-warmup:error', error);
      }
    });
    
    this.lifecycleLogger.on('phase:message-queues:start', async () => {
      try {
        await this.setupMessageQueues();
        this.lifecycleLogger.emit('phase:message-queues:complete');
      } catch (error) {
        this.lifecycleLogger.emit('phase:message-queues:error', error);
      }
    });
    
    // Shutdown phase handlers
    this.lifecycleLogger.on('shutdown:drain-connections:start', async () => {
      try {
        await this.drainActiveConnections();
        this.lifecycleLogger.emit('shutdown:drain-connections:complete');
      } catch (error) {
        this.lifecycleLogger.emit('shutdown:drain-connections:error', error);
      }
    });
    
    // Metrics handlers
    this.lifecycleLogger.on('metrics:runtime', (metrics) => {
      this.handleRuntimeMetrics(metrics);
    });
    
    // Error handlers
    this.lifecycleLogger.on('application:startup:failed', ({ error, phase }) => {
      this.handleStartupFailure(error, phase);
    });
    
    this.lifecycleLogger.on('application:shutdown:failed', ({ error }) => {
      this.handleShutdownFailure(error);
    });
  }
  
  async runDatabaseMigrations() {
    console.log('Running database migrations...');
    // Simulate migration execution
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log('Database migrations completed');
  }
  
  async warmupCache() {
    console.log('Warming up cache...');
    // Simulate cache warmup
    await new Promise(resolve => setTimeout(resolve, 1500));
    console.log('Cache warmup completed');
  }
  
  async setupMessageQueues() {
    console.log('Setting up message queues...');
    // Simulate queue setup
    await new Promise(resolve => setTimeout(resolve, 1000));
    console.log('Message queues setup completed');
  }
  
  async drainActiveConnections() {
    console.log('Draining active connections...');
    // Simulate connection draining
    await new Promise(resolve => setTimeout(resolve, 3000));
    console.log('Active connections drained');
  }
  
  handleRuntimeMetrics(metrics) {
    // Send metrics to monitoring system
    if (metrics.memory.heapUsed > 500) { // 500MB threshold
      console.warn('High memory usage detected:', metrics.memory);
    }
    
    if (metrics.cpu.userPercent > 80) {
      console.warn('High CPU usage detected:', metrics.cpu);
    }
  }
  
  handleStartupFailure(error, phase) {
    console.error(`Startup failed in phase ${phase}:`, error.message);
    
    // Send alert to monitoring system
    this.sendAlertToMonitoring({
      type: 'startup-failure',
      phase,
      error: error.message,
      severity: 'critical'
    });
  }
  
  handleShutdownFailure(error) {
    console.error('Shutdown failed:', error.message);
    
    // Send alert to monitoring system
    this.sendAlertToMonitoring({
      type: 'shutdown-failure',
      error: error.message,
      severity: 'high'
    });
  }
  
  sendAlertToMonitoring(alert) {
    // Implementation would send to your monitoring/alerting system
    console.log('ALERT:', alert);
  }
  
  async start() {
    try {
      await this.lifecycleLogger.startApplication();
      
      // Application-specific startup complete
      console.log('Microservice is ready and serving requests');
      
      // Start background tasks
      this.startBackgroundTasks();
      
    } catch (error) {
      console.error('Failed to start microservice:', error);
      process.exit(1);
    }
  }
  
  startBackgroundTasks() {
    // Start periodic tasks after application is ready
    setInterval(() => {
      this.performHealthCheck();
    }, 60000); // Every minute
    
    setInterval(() => {
      this.cleanupExpiredData();
    }, 300000); // Every 5 minutes
  }
  
  async performHealthCheck() {
    const status = this.lifecycleLogger.getLifecycleStatus();
    const dependencies = this.lifecycleLogger.getDependencyStatus();
    
    // Log health status
    console.log('Health check:', {
      status: status.phase,
      uptime: status.uptime,
      healthyDependencies: Object.values(dependencies)
        .filter(dep => dep.healthy).length,
      totalDependencies: Object.keys(dependencies).length
    });
  }
  
  async cleanupExpiredData() {
    console.log('Performing expired data cleanup...');
    // Simulate cleanup
    await new Promise(resolve => setTimeout(resolve, 500));
    console.log('Expired data cleanup completed');
  }
}

// Start the microservice
const microservice = new MicroserviceApp();
microservice.start();
```

---

## Application Start/Stop Best Practices

### **Essential Logging Points**

1. **Application Start Events**
   - Process initialization
   - Configuration loading
   - Dependency checks
   - Resource allocation
   - Service startup
   - Readiness confirmation

2. **Application Stop Events**
   - Shutdown signal received
   - Graceful shutdown phases
   - Resource cleanup
   - Final status report

### **Key Metrics to Track**

1. **Startup Metrics**
   - Total startup time
   - Phase-by-phase timing
   - Memory usage progression
   - Dependency check results
   - Configuration validation

2. **Shutdown Metrics**
   - Shutdown trigger reason
   - Graceful vs forced shutdown
   - Cleanup duration
   - Resource release status

### **Production Considerations**

1. **Performance Impact**
   - Minimize startup logging overhead
   - Use asynchronous logging for non-critical events
   - Batch related log entries

2. **Monitoring Integration**
   - Export metrics to monitoring systems
   - Set up alerting for startup failures
   - Track startup time trends

3. **Security**
   - Sanitize sensitive configuration data
   - Mask credentials and secrets
   - Audit startup/shutdown events

**Next Section**: Ready to continue with **3.1.2 Configuration Changes** - tracking configuration updates and environment changes during runtime!
