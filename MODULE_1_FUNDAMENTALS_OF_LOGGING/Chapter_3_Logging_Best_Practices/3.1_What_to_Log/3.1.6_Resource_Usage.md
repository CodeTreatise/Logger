# 3.1.6 Resource Usage

## Overview
Resource usage logging is essential for monitoring system performance, capacity planning, detecting bottlenecks, and optimizing application efficiency. This comprehensive logging system tracks CPU, memory, disk, network, and application-specific resources to provide complete visibility into system health and performance.

## Core Implementation

```javascript
const os = require('os');
const fs = require('fs').promises;
const path = require('path');
const { performance } = require('perf_hooks');
const winston = require('winston');

class ResourceUsageLogger {
    constructor(options = {}) {
        this.logger = winston.createLogger({
            level: options.level || 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ 
                    filename: 'logs/resource-usage.log',
                    maxsize: 10485760, // 10MB
                    maxFiles: 10
                }),
                new winston.transports.Console({
                    format: winston.format.combine(
                        winston.format.colorize(),
                        winston.format.simple()
                    )
                })
            ]
        });

        this.config = {
            monitoringInterval: options.monitoringInterval || 30000, // 30 seconds
            detailedInterval: options.detailedInterval || 300000, // 5 minutes
            alertThresholds: {
                cpuUsage: options.cpuThreshold || 80,
                memoryUsage: options.memoryThreshold || 85,
                diskUsage: options.diskThreshold || 90,
                networkErrors: options.networkErrorThreshold || 10
            },
            retentionPeriod: options.retentionPeriod || 7 * 24 * 60 * 60 * 1000, // 7 days
            enableGC: options.enableGC || true,
            enableNetwork: options.enableNetwork || true,
            enableDisk: options.enableDisk || true,
            ...options
        };

        this.metrics = {
            baseline: null,
            history: [],
            trends: new Map(),
            alerts: new Map()
        };

        this.networkStats = {
            previous: null,
            current: null
        };

        this.gcStats = {
            collections: 0,
            totalTime: 0,
            lastCollection: null
        };

        this.setupMonitoring();
        this.setupGCMonitoring();
        this.captureBaseline();
    }

    // Main monitoring setup
    setupMonitoring() {
        // Regular monitoring
        this.monitoringTimer = setInterval(() => {
            this.collectAndLogMetrics();
        }, this.config.monitoringInterval);

        // Detailed monitoring
        this.detailedTimer = setInterval(() => {
            this.collectDetailedMetrics();
        }, this.config.detailedInterval);

        // Cleanup old metrics
        this.cleanupTimer = setInterval(() => {
            this.cleanupOldMetrics();
        }, 60 * 60 * 1000); // Every hour
    }

    // Collect comprehensive system metrics
    async collectAndLogMetrics() {
        try {
            const timestamp = new Date().toISOString();
            const metrics = await this.gatherAllMetrics();

            // Log current metrics
            this.logger.info('System resource metrics collected', {
                event: 'resource_metrics_snapshot',
                timestamp,
                metrics
            });

            // Check for alerts
            this.checkAlertThresholds(metrics);

            // Store for trend analysis
            this.storeMetricsHistory(metrics);

            // Update trends
            this.updateTrends(metrics);

        } catch (error) {
            this.logger.error('Failed to collect resource metrics', {
                event: 'resource_monitoring_error',
                error: error.message,
                stack: error.stack
            });
        }
    }

    // Gather all system metrics
    async gatherAllMetrics() {
        const [
            cpuMetrics,
            memoryMetrics,
            diskMetrics,
            networkMetrics,
            processMetrics,
            nodeMetrics
        ] = await Promise.all([
            this.getCPUMetrics(),
            this.getMemoryMetrics(),
            this.getDiskMetrics(),
            this.getNetworkMetrics(),
            this.getProcessMetrics(),
            this.getNodeJSMetrics()
        ]);

        return {
            timestamp: Date.now(),
            cpu: cpuMetrics,
            memory: memoryMetrics,
            disk: diskMetrics,
            network: networkMetrics,
            process: processMetrics,
            nodejs: nodeMetrics,
            system: this.getSystemInfo()
        };
    }

    // CPU metrics collection
    async getCPUMetrics() {
        const cpus = os.cpus();
        const loadAvg = os.loadavg();
        
        // Calculate CPU usage over a small interval
        const startUsage = process.cpuUsage();
        const startTime = performance.now();
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const endUsage = process.cpuUsage(startUsage);
        const endTime = performance.now();
        const timeDiff = endTime - startTime;
        
        const cpuPercent = ((endUsage.user + endUsage.system) / 1000) / timeDiff * 100;

        return {
            usage: {
                user: endUsage.user,
                system: endUsage.system,
                percentage: Math.min(cpuPercent, 100)
            },
            loadAverage: {
                '1min': loadAvg[0],
                '5min': loadAvg[1],
                '15min': loadAvg[2]
            },
            cores: {
                count: cpus.length,
                model: cpus[0]?.model || 'Unknown',
                speeds: cpus.map(cpu => cpu.speed)
            },
            architecture: os.arch(),
            platform: os.platform()
        };
    }

    // Memory metrics collection
    getMemoryMetrics() {
        const totalMemory = os.totalmem();
        const freeMemory = os.freemem();
        const usedMemory = totalMemory - freeMemory;
        const memoryUsage = process.memoryUsage();

        return {
            system: {
                total: totalMemory,
                used: usedMemory,
                free: freeMemory,
                percentage: (usedMemory / totalMemory) * 100
            },
            process: {
                rss: memoryUsage.rss,
                heapTotal: memoryUsage.heapTotal,
                heapUsed: memoryUsage.heapUsed,
                external: memoryUsage.external,
                arrayBuffers: memoryUsage.arrayBuffers || 0,
                heapPercentage: (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100
            },
            formatted: {
                systemTotal: this.formatBytes(totalMemory),
                systemUsed: this.formatBytes(usedMemory),
                systemFree: this.formatBytes(freeMemory),
                processRSS: this.formatBytes(memoryUsage.rss),
                processHeap: this.formatBytes(memoryUsage.heapUsed)
            }
        };
    }

    // Disk metrics collection
    async getDiskMetrics() {
        if (!this.config.enableDisk) {
            return { enabled: false };
        }

        try {
            const diskUsage = await this.getDiskUsage('/');
            const diskIO = await this.getDiskIOStats();

            return {
                usage: diskUsage,
                io: diskIO,
                enabled: true
            };
        } catch (error) {
            this.logger.warn('Failed to collect disk metrics', {
                error: error.message
            });
            return { enabled: false, error: error.message };
        }
    }

    // Network metrics collection
    async getNetworkMetrics() {
        if (!this.config.enableNetwork) {
            return { enabled: false };
        }

        try {
            const interfaces = os.networkInterfaces();
            const currentStats = await this.getNetworkStats();
            
            let metrics = {
                interfaces: this.formatNetworkInterfaces(interfaces),
                stats: currentStats,
                enabled: true
            };

            // Calculate deltas if we have previous stats
            if (this.networkStats.previous) {
                metrics.deltas = this.calculateNetworkDeltas(
                    this.networkStats.previous,
                    currentStats
                );
            }

            this.networkStats.previous = currentStats;
            return metrics;

        } catch (error) {
            this.logger.warn('Failed to collect network metrics', {
                error: error.message
            });
            return { enabled: false, error: error.message };
        }
    }

    // Process metrics collection
    getProcessMetrics() {
        return {
            pid: process.pid,
            ppid: process.ppid,
            uptime: process.uptime(),
            version: process.version,
            platform: process.platform,
            arch: process.arch,
            title: process.title,
            env: {
                nodeEnv: process.env.NODE_ENV || 'development',
                timezone: process.env.TZ || Intl.DateTimeFormat().resolvedOptions().timeZone
            },
            arguments: process.argv.length,
            workingDirectory: process.cwd(),
            execPath: process.execPath,
            resourceUsage: process.resourceUsage ? process.resourceUsage() : null
        };
    }

    // Node.js specific metrics
    getNodeJSMetrics() {
        const metrics = {
            version: process.version,
            v8: process.versions.v8,
            eventLoop: this.getEventLoopMetrics(),
            gc: { ...this.gcStats }
        };

        // Add active handles and requests if available
        if (process._getActiveHandles) {
            metrics.activeHandles = process._getActiveHandles().length;
        }
        if (process._getActiveRequests) {
            metrics.activeRequests = process._getActiveRequests().length;
        }

        return metrics;
    }

    // Event loop metrics
    getEventLoopMetrics() {
        const start = performance.now();
        return new Promise((resolve) => {
            setImmediate(() => {
                const lag = performance.now() - start;
                resolve({
                    lag: lag,
                    timestamp: Date.now()
                });
            });
        });
    }

    // System information
    getSystemInfo() {
        return {
            hostname: os.hostname(),
            type: os.type(),
            release: os.release(),
            uptime: os.uptime(),
            endianness: os.endianness(),
            tmpdir: os.tmpdir(),
            homedir: os.homedir(),
            constants: {
                maxStringLength: Buffer.constants.MAX_STRING_LENGTH,
                maxBufferLength: Buffer.constants.MAX_LENGTH
            }
        };
    }

    // Detailed metrics collection
    async collectDetailedMetrics() {
        try {
            const detailedMetrics = {
                timestamp: new Date().toISOString(),
                detailed: true,
                performance: await this.getPerformanceMetrics(),
                security: await this.getSecurityMetrics(),
                application: await this.getApplicationMetrics(),
                trends: this.getTrendAnalysis()
            };

            this.logger.info('Detailed system analysis completed', {
                event: 'detailed_resource_analysis',
                ...detailedMetrics
            });

        } catch (error) {
            this.logger.error('Failed to collect detailed metrics', {
                event: 'detailed_metrics_error',
                error: error.message
            });
        }
    }

    // Performance metrics
    async getPerformanceMetrics() {
        const marks = performance.getEntriesByType('mark');
        const measures = performance.getEntriesByType('measure');
        
        return {
            marks: marks.length,
            measures: measures.length,
            timing: {
                nodeStart: performance.timeOrigin,
                now: performance.now()
            },
            observers: performance.getEntriesByType('navigation').length
        };
    }

    // Security metrics
    async getSecurityMetrics() {
        return {
            processPrivileges: {
                uid: process.getuid ? process.getuid() : null,
                gid: process.getgid ? process.getgid() : null,
                groups: process.getgroups ? process.getgroups() : null
            },
            environmentVariables: Object.keys(process.env).length,
            securityFeatures: {
                tlsSupport: process.versions.openssl ? true : false,
                cryptoConstants: typeof require('crypto').constants !== 'undefined'
            }
        };
    }

    // Application-specific metrics
    async getApplicationMetrics() {
        return {
            modules: {
                loaded: Object.keys(require.cache).length,
                native: process.moduleLoadList ? process.moduleLoadList.length : 0
            },
            features: {
                worker_threads: typeof require('worker_threads') !== 'undefined',
                async_hooks: typeof require('async_hooks') !== 'undefined',
                inspector: typeof require('inspector') !== 'undefined'
            },
            debugging: {
                inspectorActive: process.debugPort ? true : false,
                tracing: process.tracing ? process.tracing.enabled : false
            }
        };
    }

    // GC monitoring setup
    setupGCMonitoring() {
        if (!this.config.enableGC) return;

        try {
            const v8 = require('v8');
            
            // Monitor GC events if possible
            if (typeof v8.getHeapStatistics === 'function') {
                setInterval(() => {
                    const heapStats = v8.getHeapStatistics();
                    this.logGCMetrics(heapStats);
                }, 60000); // Every minute
            }

        } catch (error) {
            this.logger.debug('GC monitoring not available', {
                error: error.message
            });
        }
    }

    // Log GC metrics
    logGCMetrics(heapStats) {
        this.logger.debug('Garbage collection metrics', {
            event: 'gc_metrics',
            heap: {
                totalHeapSize: heapStats.total_heap_size,
                totalHeapSizeExecutable: heapStats.total_heap_size_executable,
                totalPhysicalSize: heapStats.total_physical_size,
                totalAvailableSize: heapStats.total_available_size,
                usedHeapSize: heapStats.used_heap_size,
                heapSizeLimit: heapStats.heap_size_limit,
                mallocedMemory: heapStats.malloced_memory,
                peakMallocedMemory: heapStats.peak_malloced_memory,
                doesZapGarbage: heapStats.does_zap_garbage
            },
            formatted: {
                totalHeap: this.formatBytes(heapStats.total_heap_size),
                usedHeap: this.formatBytes(heapStats.used_heap_size),
                heapLimit: this.formatBytes(heapStats.heap_size_limit)
            }
        });
    }

    // Alert threshold checking
    checkAlertThresholds(metrics) {
        const alerts = [];

        // CPU alerts
        if (metrics.cpu.usage.percentage > this.config.alertThresholds.cpuUsage) {
            alerts.push({
                type: 'cpu_high',
                severity: 'warning',
                current: metrics.cpu.usage.percentage,
                threshold: this.config.alertThresholds.cpuUsage,
                message: `CPU usage is ${metrics.cpu.usage.percentage.toFixed(2)}%, exceeding threshold of ${this.config.alertThresholds.cpuUsage}%`
            });
        }

        // Memory alerts
        if (metrics.memory.system.percentage > this.config.alertThresholds.memoryUsage) {
            alerts.push({
                type: 'memory_high',
                severity: 'warning',
                current: metrics.memory.system.percentage,
                threshold: this.config.alertThresholds.memoryUsage,
                message: `Memory usage is ${metrics.memory.system.percentage.toFixed(2)}%, exceeding threshold of ${this.config.alertThresholds.memoryUsage}%`
            });
        }

        // Disk alerts
        if (metrics.disk.enabled && metrics.disk.usage && 
            metrics.disk.usage.percentage > this.config.alertThresholds.diskUsage) {
            alerts.push({
                type: 'disk_high',
                severity: 'critical',
                current: metrics.disk.usage.percentage,
                threshold: this.config.alertThresholds.diskUsage,
                message: `Disk usage is ${metrics.disk.usage.percentage.toFixed(2)}%, exceeding threshold of ${this.config.alertThresholds.diskUsage}%`
            });
        }

        // Log alerts
        if (alerts.length > 0) {
            alerts.forEach(alert => {
                this.logger.warn('Resource usage alert triggered', {
                    event: 'resource_alert',
                    alert,
                    timestamp: new Date().toISOString()
                });
            });
        }

        return alerts;
    }

    // Trend analysis
    updateTrends(metrics) {
        const now = Date.now();
        const categories = ['cpu', 'memory', 'disk', 'network'];

        categories.forEach(category => {
            if (!this.metrics.trends.has(category)) {
                this.metrics.trends.set(category, []);
            }

            const trend = this.metrics.trends.get(category);
            
            // Add current data point
            let value;
            switch (category) {
                case 'cpu':
                    value = metrics.cpu.usage.percentage;
                    break;
                case 'memory':
                    value = metrics.memory.system.percentage;
                    break;
                case 'disk':
                    value = metrics.disk.enabled ? metrics.disk.usage?.percentage || 0 : 0;
                    break;
                case 'network':
                    value = metrics.network.enabled ? 
                        (metrics.network.deltas?.bytesPerSecond || 0) : 0;
                    break;
            }

            trend.push({ timestamp: now, value });

            // Keep only last 100 data points
            if (trend.length > 100) {
                trend.shift();
            }
        });
    }

    // Get trend analysis
    getTrendAnalysis() {
        const analysis = {};

        for (const [category, trend] of this.metrics.trends) {
            if (trend.length < 2) continue;

            const values = trend.map(point => point.value);
            const recent = values.slice(-10); // Last 10 readings
            const older = values.slice(-20, -10); // Previous 10 readings

            analysis[category] = {
                current: values[values.length - 1],
                average: this.calculateAverage(values),
                recentAverage: this.calculateAverage(recent),
                previousAverage: this.calculateAverage(older),
                trend: this.calculateTrend(recent, older),
                volatility: this.calculateVolatility(values),
                dataPoints: trend.length
            };
        }

        return analysis;
    }

    // Utility methods
    async getDiskUsage(path) {
        try {
            const stats = await fs.statfs(path);
            const total = stats.bavail * stats.bsize;
            const free = stats.bfree * stats.bsize;
            const used = total - free;

            return {
                path,
                total,
                used,
                free,
                percentage: (used / total) * 100,
                formatted: {
                    total: this.formatBytes(total),
                    used: this.formatBytes(used),
                    free: this.formatBytes(free)
                }
            };
        } catch (error) {
            // Fallback for systems without statfs
            return {
                path,
                total: 0,
                used: 0,
                free: 0,
                percentage: 0,
                error: 'Unable to determine disk usage'
            };
        }
    }

    async getDiskIOStats() {
        // Platform-specific disk I/O stats would go here
        // This is a simplified implementation
        return {
            reads: 0,
            writes: 0,
            readBytes: 0,
            writeBytes: 0,
            note: 'Disk I/O statistics require platform-specific implementation'
        };
    }

    async getNetworkStats() {
        // Platform-specific network stats would go here
        // This is a simplified implementation
        return {
            bytesReceived: 0,
            bytesSent: 0,
            packetsReceived: 0,
            packetsSent: 0,
            errors: 0,
            dropped: 0,
            timestamp: Date.now()
        };
    }

    formatNetworkInterfaces(interfaces) {
        const formatted = {};
        
        for (const [name, addresses] of Object.entries(interfaces)) {
            formatted[name] = addresses.map(addr => ({
                address: addr.address,
                netmask: addr.netmask,
                family: addr.family,
                mac: addr.mac,
                internal: addr.internal,
                cidr: addr.cidr
            }));
        }

        return formatted;
    }

    calculateNetworkDeltas(previous, current) {
        const timeDelta = (current.timestamp - previous.timestamp) / 1000; // seconds
        
        return {
            bytesPerSecond: {
                received: (current.bytesReceived - previous.bytesReceived) / timeDelta,
                sent: (current.bytesSent - previous.bytesSent) / timeDelta
            },
            packetsPerSecond: {
                received: (current.packetsReceived - previous.packetsReceived) / timeDelta,
                sent: (current.packetsSent - previous.packetsSent) / timeDelta
            },
            timeDelta
        };
    }

    formatBytes(bytes) {
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) return '0 Bytes';
        
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    }

    calculateAverage(values) {
        if (values.length === 0) return 0;
        return values.reduce((sum, val) => sum + val, 0) / values.length;
    }

    calculateTrend(recent, previous) {
        const recentAvg = this.calculateAverage(recent);
        const previousAvg = this.calculateAverage(previous);
        
        if (previousAvg === 0) return 'stable';
        
        const change = ((recentAvg - previousAvg) / previousAvg) * 100;
        
        if (change > 10) return 'increasing';
        if (change < -10) return 'decreasing';
        return 'stable';
    }

    calculateVolatility(values) {
        if (values.length < 2) return 0;
        
        const avg = this.calculateAverage(values);
        const variance = values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
        return Math.sqrt(variance);
    }

    // Store metrics in history
    storeMetricsHistory(metrics) {
        this.metrics.history.push({
            timestamp: Date.now(),
            metrics: JSON.parse(JSON.stringify(metrics)) // Deep copy
        });

        // Keep only recent history
        const cutoff = Date.now() - this.config.retentionPeriod;
        this.metrics.history = this.metrics.history.filter(
            entry => entry.timestamp > cutoff
        );
    }

    // Capture baseline metrics
    async captureBaseline() {
        try {
            this.metrics.baseline = await this.gatherAllMetrics();
            
            this.logger.info('Baseline metrics captured', {
                event: 'baseline_captured',
                timestamp: new Date().toISOString(),
                baseline: this.metrics.baseline
            });
        } catch (error) {
            this.logger.error('Failed to capture baseline metrics', {
                error: error.message
            });
        }
    }

    // Cleanup old metrics
    cleanupOldMetrics() {
        const cutoff = Date.now() - this.config.retentionPeriod;
        
        // Clean history
        this.metrics.history = this.metrics.history.filter(
            entry => entry.timestamp > cutoff
        );

        // Clean trends
        for (const [category, trend] of this.metrics.trends) {
            const filtered = trend.filter(point => point.timestamp > cutoff);
            this.metrics.trends.set(category, filtered);
        }

        this.logger.debug('Old metrics cleaned up', {
            event: 'metrics_cleanup',
            cutoff: new Date(cutoff).toISOString()
        });
    }

    // Get current resource summary
    async getResourceSummary() {
        const metrics = await this.gatherAllMetrics();
        
        return {
            timestamp: new Date().toISOString(),
            summary: {
                cpu: {
                    usage: `${metrics.cpu.usage.percentage.toFixed(1)}%`,
                    cores: metrics.cpu.cores.count,
                    loadAvg: metrics.cpu.loadAverage['1min'].toFixed(2)
                },
                memory: {
                    system: `${metrics.memory.system.percentage.toFixed(1)}%`,
                    process: metrics.memory.formatted.processRSS,
                    heap: `${metrics.memory.process.heapPercentage.toFixed(1)}%`
                },
                disk: metrics.disk.enabled ? {
                    usage: `${metrics.disk.usage.percentage.toFixed(1)}%`,
                    free: metrics.disk.usage.formatted.free
                } : { enabled: false },
                uptime: {
                    system: `${(metrics.system.uptime / 3600).toFixed(1)} hours`,
                    process: `${(metrics.process.uptime / 3600).toFixed(1)} hours`
                }
            },
            health: this.assessSystemHealth(metrics)
        };
    }

    // Assess overall system health
    assessSystemHealth(metrics) {
        const issues = [];
        let overallHealth = 'excellent';

        // Check CPU
        if (metrics.cpu.usage.percentage > 90) {
            issues.push('Critical CPU usage');
            overallHealth = 'critical';
        } else if (metrics.cpu.usage.percentage > 70) {
            issues.push('High CPU usage');
            if (overallHealth === 'excellent') overallHealth = 'warning';
        }

        // Check Memory
        if (metrics.memory.system.percentage > 95) {
            issues.push('Critical memory usage');
            overallHealth = 'critical';
        } else if (metrics.memory.system.percentage > 80) {
            issues.push('High memory usage');
            if (overallHealth === 'excellent') overallHealth = 'warning';
        }

        // Check Disk
        if (metrics.disk.enabled && metrics.disk.usage.percentage > 95) {
            issues.push('Critical disk usage');
            overallHealth = 'critical';
        } else if (metrics.disk.enabled && metrics.disk.usage.percentage > 85) {
            issues.push('High disk usage');
            if (overallHealth === 'excellent') overallHealth = 'warning';
        }

        return {
            status: overallHealth,
            issues,
            score: this.calculateHealthScore(metrics)
        };
    }

    calculateHealthScore(metrics) {
        let score = 100;
        
        // Deduct points for high resource usage
        score -= Math.max(0, metrics.cpu.usage.percentage - 70) * 0.5;
        score -= Math.max(0, metrics.memory.system.percentage - 70) * 0.3;
        
        if (metrics.disk.enabled) {
            score -= Math.max(0, metrics.disk.usage.percentage - 80) * 0.2;
        }

        return Math.max(0, Math.round(score));
    }

    // Shutdown monitoring
    shutdown() {
        if (this.monitoringTimer) {
            clearInterval(this.monitoringTimer);
        }
        if (this.detailedTimer) {
            clearInterval(this.detailedTimer);
        }
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }

        this.logger.info('Resource monitoring stopped', {
            event: 'monitoring_shutdown',
            timestamp: new Date().toISOString()
        });
    }
}
```

## Advanced Resource Monitoring Components

### Performance Profiler

```javascript
class PerformanceProfiler {
    constructor(resourceLogger) {
        this.resourceLogger = resourceLogger;
        this.profiles = new Map();
        this.activeProfiles = new Map();
    }

    startProfiling(operationName, context = {}) {
        const profileId = `${operationName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const profile = {
            id: profileId,
            operationName,
            context,
            startTime: performance.now(),
            startMemory: process.memoryUsage(),
            startCPU: process.cpuUsage(),
            events: []
        };

        this.activeProfiles.set(profileId, profile);

        this.resourceLogger.logger.debug('Performance profiling started', {
            event: 'profiling_started',
            profileId,
            operationName,
            context
        });

        return profileId;
    }

    addEvent(profileId, eventName, data = {}) {
        const profile = this.activeProfiles.get(profileId);
        if (!profile) return;

        profile.events.push({
            name: eventName,
            timestamp: performance.now(),
            memory: process.memoryUsage(),
            data
        });
    }

    endProfiling(profileId) {
        const profile = this.activeProfiles.get(profileId);
        if (!profile) return null;

        const endTime = performance.now();
        const endMemory = process.memoryUsage();
        const endCPU = process.cpuUsage(profile.startCPU);

        const results = {
            ...profile,
            endTime,
            endMemory,
            endCPU,
            duration: endTime - profile.startTime,
            memoryDelta: {
                rss: endMemory.rss - profile.startMemory.rss,
                heapTotal: endMemory.heapTotal - profile.startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - profile.startMemory.heapUsed,
                external: endMemory.external - profile.startMemory.external
            },
            cpuUsage: {
                user: endCPU.user,
                system: endCPU.system,
                total: endCPU.user + endCPU.system
            }
        };

        this.activeProfiles.delete(profileId);
        this.profiles.set(profileId, results);

        this.resourceLogger.logger.info('Performance profiling completed', {
            event: 'profiling_completed',
            profileId: results.id,
            operationName: results.operationName,
            duration: results.duration,
            memoryDelta: results.memoryDelta,
            cpuUsage: results.cpuUsage,
            eventCount: results.events.length
        });

        return results;
    }

    getProfile(profileId) {
        return this.profiles.get(profileId);
    }

    getAllProfiles() {
        return Array.from(this.profiles.values());
    }

    clearProfiles() {
        this.profiles.clear();
        this.resourceLogger.logger.debug('Performance profiles cleared');
    }
}
```

### Memory Leak Detector

```javascript
class MemoryLeakDetector {
    constructor(resourceLogger, options = {}) {
        this.resourceLogger = resourceLogger;
        this.config = {
            checkInterval: options.checkInterval || 60000, // 1 minute
            growthThreshold: options.growthThreshold || 10, // MB
            sampleSize: options.sampleSize || 10,
            ...options
        };

        this.memoryHistory = [];
        this.setupMonitoring();
    }

    setupMonitoring() {
        this.monitoringTimer = setInterval(() => {
            this.checkMemoryLeaks();
        }, this.config.checkInterval);
    }

    checkMemoryLeaks() {
        const currentMemory = process.memoryUsage();
        const timestamp = Date.now();

        this.memoryHistory.push({
            timestamp,
            memory: currentMemory
        });

        // Keep only recent samples
        if (this.memoryHistory.length > this.config.sampleSize) {
            this.memoryHistory.shift();
        }

        // Analyze for leaks if we have enough samples
        if (this.memoryHistory.length >= this.config.sampleSize) {
            this.analyzeMemoryTrend();
        }
    }

    analyzeMemoryTrend() {
        const samples = this.memoryHistory;
        const first = samples[0];
        const last = samples[samples.length - 1];

        const growth = {
            rss: (last.memory.rss - first.memory.rss) / (1024 * 1024), // MB
            heapUsed: (last.memory.heapUsed - first.memory.heapUsed) / (1024 * 1024),
            heapTotal: (last.memory.heapTotal - first.memory.heapTotal) / (1024 * 1024),
            external: (last.memory.external - first.memory.external) / (1024 * 1024)
        };

        const timePeriod = (last.timestamp - first.timestamp) / 1000 / 60; // minutes

        // Check for potential leaks
        const leakIndicators = [];

        if (growth.rss > this.config.growthThreshold) {
            leakIndicators.push({
                type: 'rss_growth',
                growth: growth.rss,
                rate: growth.rss / timePeriod,
                severity: growth.rss > 50 ? 'critical' : 'warning'
            });
        }

        if (growth.heapUsed > this.config.growthThreshold) {
            leakIndicators.push({
                type: 'heap_growth',
                growth: growth.heapUsed,
                rate: growth.heapUsed / timePeriod,
                severity: growth.heapUsed > 30 ? 'critical' : 'warning'
            });
        }

        if (leakIndicators.length > 0) {
            this.resourceLogger.logger.warn('Potential memory leak detected', {
                event: 'memory_leak_detection',
                indicators: leakIndicators,
                growth,
                timePeriod,
                samples: samples.length,
                currentMemory: last.memory
            });
        }
    }

    generateMemoryReport() {
        const currentMemory = process.memoryUsage();
        
        return {
            timestamp: new Date().toISOString(),
            current: currentMemory,
            formatted: {
                rss: this.resourceLogger.formatBytes(currentMemory.rss),
                heapTotal: this.resourceLogger.formatBytes(currentMemory.heapTotal),
                heapUsed: this.resourceLogger.formatBytes(currentMemory.heapUsed),
                external: this.resourceLogger.formatBytes(currentMemory.external)
            },
            history: this.memoryHistory.length,
            trend: this.memoryHistory.length >= 2 ? 
                this.calculateMemoryTrend() : 'insufficient_data'
        };
    }

    calculateMemoryTrend() {
        if (this.memoryHistory.length < 2) return 'insufficient_data';

        const recent = this.memoryHistory.slice(-3);
        const growth = recent[recent.length - 1].memory.rss - recent[0].memory.rss;

        if (growth > 1024 * 1024) return 'increasing'; // > 1MB growth
        if (growth < -1024 * 1024) return 'decreasing'; // > 1MB reduction
        return 'stable';
    }

    shutdown() {
        if (this.monitoringTimer) {
            clearInterval(this.monitoringTimer);
        }
    }
}
```

## Usage Examples

### Basic Resource Monitoring

```javascript
// Initialize resource monitoring
const resourceLogger = new ResourceUsageLogger({
    monitoringInterval: 30000, // 30 seconds
    detailedInterval: 300000,  // 5 minutes
    cpuThreshold: 80,
    memoryThreshold: 85,
    diskThreshold: 90,
    enableGC: true,
    enableNetwork: true,
    enableDisk: true
});

// Get current resource summary
async function getSystemStatus() {
    try {
        const summary = await resourceLogger.getResourceSummary();
        console.log('System Status:', summary);
        return summary;
    } catch (error) {
        console.error('Failed to get system status:', error);
    }
}

// Performance profiling example
const profiler = new PerformanceProfiler(resourceLogger);

async function processLargeDataset(data) {
    const profileId = profiler.startProfiling('data_processing', {
        dataSize: data.length,
        operation: 'batch_process'
    });

    try {
        profiler.addEvent(profileId, 'validation_start');
        await validateData(data);
        
        profiler.addEvent(profileId, 'processing_start');
        const results = await processData(data);
        
        profiler.addEvent(profileId, 'storage_start');
        await storeResults(results);

        const profile = profiler.endProfiling(profileId);
        
        console.log(`Processing completed in ${profile.duration.toFixed(2)}ms`);
        console.log(`Memory delta: ${(profile.memoryDelta.heapUsed / 1024 / 1024).toFixed(2)}MB`);
        
        return results;

    } catch (error) {
        profiler.endProfiling(profileId);
        throw error;
    }
}
```

### Memory Leak Detection

```javascript
// Initialize memory leak detector
const memoryDetector = new MemoryLeakDetector(resourceLogger, {
    checkInterval: 30000, // 30 seconds
    growthThreshold: 5,   // 5MB threshold
    sampleSize: 20        // 20 samples for analysis
});

// Generate memory report
function generateMemoryReport() {
    const report = memoryDetector.generateMemoryReport();
    
    resourceLogger.logger.info('Memory usage report generated', {
        event: 'memory_report',
        report
    });
    
    return report;
}

// Manual memory check
function forceMemoryCheck() {
    memoryDetector.checkMemoryLeaks();
    
    const report = generateMemoryReport();
    console.log('Memory Report:', report);
    
    return report;
}
```

### Production Application Integration

```javascript
// Express.js application with resource monitoring
const express = require('express');
const app = express();

// Initialize monitoring
const resourceLogger = new ResourceUsageLogger({
    monitoringInterval: 60000,  // 1 minute
    detailedInterval: 600000,   // 10 minutes
});

const profiler = new PerformanceProfiler(resourceLogger);
const memoryDetector = new MemoryLeakDetector(resourceLogger);

// Middleware for request profiling
app.use((req, res, next) => {
    const profileId = profiler.startProfiling('http_request', {
        method: req.method,
        url: req.url,
        userAgent: req.get('User-Agent')
    });

    res.on('finish', () => {
        profiler.addEvent(profileId, 'response_sent', {
            statusCode: res.statusCode,
            responseSize: res.get('Content-Length')
        });
        profiler.endProfiling(profileId);
    });

    req.profileId = profileId;
    next();
});

// Health check endpoint
app.get('/health', async (req, res) => {
    try {
        const summary = await resourceLogger.getResourceSummary();
        const memoryReport = memoryDetector.generateMemoryReport();
        
        res.json({
            status: 'ok',
            timestamp: new Date().toISOString(),
            system: summary,
            memory: memoryReport,
            uptime: process.uptime()
        });
    } catch (error) {
        res.status(500).json({
            status: 'error',
            error: error.message
        });
    }
});

// Resource metrics endpoint
app.get('/metrics', async (req, res) => {
    try {
        const metrics = await resourceLogger.gatherAllMetrics();
        const trends = resourceLogger.getTrendAnalysis();
        
        res.json({
            current: metrics,
            trends,
            profiles: profiler.getAllProfiles().slice(-10) // Last 10 profiles
        });
    } catch (error) {
        res.status(500).json({
            status: 'error',
            error: error.message
        });
    }
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('Shutting down gracefully...');
    
    resourceLogger.shutdown();
    memoryDetector.shutdown();
    
    process.exit(0);
});

const server = app.listen(3000, () => {
    console.log('Server started with resource monitoring enabled');
});
```

### Microservice Resource Monitoring

```javascript
// Microservice with comprehensive resource monitoring
class MicroserviceResourceMonitor {
    constructor(serviceName, options = {}) {
        this.serviceName = serviceName;
        this.resourceLogger = new ResourceUsageLogger(options);
        this.profiler = new PerformanceProfiler(this.resourceLogger);
        this.memoryDetector = new MemoryLeakDetector(this.resourceLogger);
        
        this.setupServiceSpecificMonitoring();
    }

    setupServiceSpecificMonitoring() {
        // Monitor service-specific metrics
        setInterval(() => {
            this.collectServiceMetrics();
        }, 60000); // Every minute
    }

    async collectServiceMetrics() {
        const serviceMetrics = {
            serviceName: this.serviceName,
            timestamp: new Date().toISOString(),
            customMetrics: await this.getCustomMetrics(),
            performance: this.getPerformanceMetrics(),
            health: await this.getServiceHealth()
        };

        this.resourceLogger.logger.info('Service-specific metrics collected', {
            event: 'service_metrics',
            ...serviceMetrics
        });
    }

    async getCustomMetrics() {
        // Override in subclasses for service-specific metrics
        return {
            connections: this.getActiveConnections(),
            requests: this.getRequestMetrics(),
            cache: this.getCacheMetrics(),
            database: await this.getDatabaseMetrics()
        };
    }

    getActiveConnections() {
        // Count active connections (WebSocket, HTTP keep-alive, etc.)
        return 0; // Placeholder
    }

    getRequestMetrics() {
        // Request rate, error rate, etc.
        return {
            rate: 0,
            errorRate: 0,
            averageResponseTime: 0
        };
    }

    getCacheMetrics() {
        // Cache hit rate, size, etc.
        return {
            hitRate: 0,
            size: 0,
            entries: 0
        };
    }

    async getDatabaseMetrics() {
        // Database connection pool, query performance, etc.
        return {
            poolSize: 0,
            activeConnections: 0,
            queryCount: 0,
            averageQueryTime: 0
        };
    }

    async getServiceHealth() {
        const summary = await this.resourceLogger.getResourceSummary();
        const customHealth = await this.checkCustomHealth();
        
        return {
            overall: summary.health.status,
            score: summary.health.score,
            issues: [...summary.health.issues, ...customHealth.issues],
            dependencies: customHealth.dependencies
        };
    }

    async checkCustomHealth() {
        // Override for service-specific health checks
        return {
            issues: [],
            dependencies: []
        };
    }

    shutdown() {
        this.resourceLogger.shutdown();
        this.memoryDetector.shutdown();
    }
}
```

## Key Benefits

1. **Comprehensive Monitoring**: Complete visibility into system resources
2. **Performance Optimization**: Detailed profiling and bottleneck identification
3. **Proactive Alerting**: Early warning system for resource issues
4. **Memory Leak Detection**: Automatic detection of memory leaks
5. **Trend Analysis**: Historical data analysis for capacity planning
6. **Health Assessment**: Overall system health scoring
7. **Production Ready**: Enterprise-grade monitoring for production environments
8. **Customizable**: Configurable thresholds and monitoring intervals
9. **Multi-dimensional**: CPU, memory, disk, network, and application metrics
10. **Integration Friendly**: Easy integration with existing monitoring systems

This resource usage logging implementation provides comprehensive system monitoring with intelligent analysis, making it perfect for production environments requiring detailed performance visibility and proactive issue detection.

ðŸŽ‰ **Section 3.1 "What to Log" is now complete!** We've successfully created all six subsections with enterprise-grade logging implementations covering application lifecycle, configuration management, security, business transactions, external services, and resource usage.
