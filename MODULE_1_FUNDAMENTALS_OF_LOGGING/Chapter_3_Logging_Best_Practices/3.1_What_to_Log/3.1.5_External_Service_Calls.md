# 3.1.5 External Service Calls

## Overview
External service call logging is critical for monitoring API integrations, tracking service dependencies, measuring performance, and diagnosing integration failures. This comprehensive logging system provides visibility into third-party services, internal microservices, and external APIs.

## Core Implementation

```javascript
const crypto = require('crypto');
const axios = require('axios');
const https = require('https');
const winston = require('winston');

class ExternalServiceLogger {
    constructor(options = {}) {
        this.logger = winston.createLogger({
            level: options.level || 'info',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ 
                    filename: 'logs/external-services.log',
                    maxsize: 10485760, // 10MB
                    maxFiles: 10
                }),
                new winston.transports.Console({
                    format: winston.format.combine(
                        winston.format.colorize(),
                        winston.format.simple()
                    )
                })
            ]
        });

        this.config = {
            logHeaders: options.logHeaders || false,
            logRequestBody: options.logRequestBody || false,
            logResponseBody: options.logResponseBody || false,
            maxBodySize: options.maxBodySize || 1024, // 1KB
            sensitiveHeaders: options.sensitiveHeaders || [
                'authorization', 'x-api-key', 'cookie', 'set-cookie'
            ],
            timeout: options.timeout || 30000,
            retryAttempts: options.retryAttempts || 3,
            circuitBreakerThreshold: options.circuitBreakerThreshold || 5,
            ...options
        };

        this.metrics = {
            requests: new Map(),
            services: new Map(),
            circuitBreakers: new Map()
        };

        this.setupPerformanceMonitoring();
        this.setupCircuitBreakers();
    }

    // Main API call wrapper with comprehensive logging
    async makeRequest(serviceName, endpoint, options = {}) {
        const requestId = this.generateRequestId();
        const startTime = Date.now();
        
        const requestContext = {
            requestId,
            serviceName,
            endpoint,
            method: options.method || 'GET',
            timestamp: new Date().toISOString(),
            startTime
        };

        try {
            // Check circuit breaker
            if (this.isCircuitBreakerOpen(serviceName)) {
                throw new Error(`Circuit breaker open for service: ${serviceName}`);
            }

            // Log request initiation
            this.logRequestStart(requestContext, options);

            // Execute request with timeout and retries
            const response = await this.executeWithRetries(
                requestContext, 
                options
            );

            // Log successful response
            this.logRequestSuccess(requestContext, response, startTime);
            
            // Update metrics
            this.updateSuccessMetrics(serviceName, Date.now() - startTime);
            
            return response;

        } catch (error) {
            // Log request failure
            this.logRequestFailure(requestContext, error, startTime);
            
            // Update failure metrics
            this.updateFailureMetrics(serviceName);
            
            throw error;
        }
    }

    // Log request initiation
    logRequestStart(context, options) {
        const logData = {
            event: 'external_service_request_start',
            requestId: context.requestId,
            serviceName: context.serviceName,
            endpoint: context.endpoint,
            method: context.method,
            timestamp: context.timestamp,
            config: {
                timeout: this.config.timeout,
                retryAttempts: this.config.retryAttempts
            }
        };

        // Add headers if configured
        if (this.config.logHeaders && options.headers) {
            logData.headers = this.sanitizeHeaders(options.headers);
        }

        // Add request body if configured
        if (this.config.logRequestBody && options.data) {
            logData.requestBody = this.sanitizeBody(options.data);
        }

        // Add query parameters
        if (options.params) {
            logData.queryParams = options.params;
        }

        this.logger.info('External service request initiated', logData);
    }

    // Log successful response
    logRequestSuccess(context, response, startTime) {
        const duration = Date.now() - startTime;
        const responseSize = this.calculateResponseSize(response);

        const logData = {
            event: 'external_service_request_success',
            requestId: context.requestId,
            serviceName: context.serviceName,
            endpoint: context.endpoint,
            method: context.method,
            statusCode: response.status,
            duration,
            responseSize,
            timestamp: new Date().toISOString()
        };

        // Add response headers if configured
        if (this.config.logHeaders && response.headers) {
            logData.responseHeaders = this.sanitizeHeaders(response.headers);
        }

        // Add response body if configured
        if (this.config.logResponseBody && response.data) {
            logData.responseBody = this.sanitizeBody(response.data);
        }

        // Performance categorization
        logData.performance = this.categorizePerformance(duration);

        this.logger.info('External service request completed successfully', logData);
    }

    // Log request failure
    logRequestFailure(context, error, startTime) {
        const duration = Date.now() - startTime;

        const logData = {
            event: 'external_service_request_failure',
            requestId: context.requestId,
            serviceName: context.serviceName,
            endpoint: context.endpoint,
            method: context.method,
            duration,
            timestamp: new Date().toISOString(),
            error: {
                message: error.message,
                code: error.code,
                name: error.name
            }
        };

        // Add HTTP-specific error details
        if (error.response) {
            logData.error.statusCode = error.response.status;
            logData.error.statusText = error.response.statusText;
            
            if (this.config.logHeaders && error.response.headers) {
                logData.error.responseHeaders = this.sanitizeHeaders(error.response.headers);
            }
            
            if (this.config.logResponseBody && error.response.data) {
                logData.error.responseBody = this.sanitizeBody(error.response.data);
            }
        }

        // Add network-specific error details
        if (error.code) {
            logData.error.networkError = true;
            logData.error.errno = error.errno;
            logData.error.syscall = error.syscall;
            logData.error.hostname = error.hostname;
        }

        // Add timeout information
        if (error.code === 'ECONNABORTED') {
            logData.error.timeout = true;
            logData.error.configuredTimeout = this.config.timeout;
        }

        this.logger.error('External service request failed', logData);
    }

    // Execute request with retry logic
    async executeWithRetries(context, options, attempt = 1) {
        try {
            const axiosConfig = {
                ...options,
                timeout: this.config.timeout,
                validateStatus: (status) => status < 500 // Retry on 5xx errors
            };

            const response = await axios(context.endpoint, axiosConfig);
            
            // Log retry success if this wasn't the first attempt
            if (attempt > 1) {
                this.logger.info('External service request succeeded after retry', {
                    requestId: context.requestId,
                    serviceName: context.serviceName,
                    attempt,
                    statusCode: response.status
                });
            }

            return response;

        } catch (error) {
            // Check if we should retry
            if (attempt < this.config.retryAttempts && this.shouldRetry(error)) {
                this.logger.warn('External service request failed, retrying', {
                    requestId: context.requestId,
                    serviceName: context.serviceName,
                    attempt,
                    maxAttempts: this.config.retryAttempts,
                    error: error.message,
                    retryDelay: this.calculateRetryDelay(attempt)
                });

                // Wait before retry (exponential backoff)
                await this.delay(this.calculateRetryDelay(attempt));
                
                return this.executeWithRetries(context, options, attempt + 1);
            }

            throw error;
        }
    }

    // Determine if request should be retried
    shouldRetry(error) {
        // Retry on network errors
        if (error.code && ['ECONNRESET', 'ENOTFOUND', 'ECONNABORTED'].includes(error.code)) {
            return true;
        }

        // Retry on 5xx server errors
        if (error.response && error.response.status >= 500) {
            return true;
        }

        // Retry on 429 (Too Many Requests)
        if (error.response && error.response.status === 429) {
            return true;
        }

        return false;
    }

    // Calculate retry delay with exponential backoff
    calculateRetryDelay(attempt) {
        const baseDelay = 1000; // 1 second
        const maxDelay = 30000; // 30 seconds
        const delay = baseDelay * Math.pow(2, attempt - 1);
        return Math.min(delay, maxDelay);
    }

    // Service health monitoring
    setupPerformanceMonitoring() {
        setInterval(() => {
            this.generateServiceHealthReport();
        }, 60000); // Every minute
    }

    generateServiceHealthReport() {
        for (const [serviceName, stats] of this.metrics.services) {
            const healthData = {
                event: 'service_health_report',
                serviceName,
                timestamp: new Date().toISOString(),
                metrics: {
                    totalRequests: stats.totalRequests,
                    successfulRequests: stats.successfulRequests,
                    failedRequests: stats.failedRequests,
                    successRate: stats.totalRequests > 0 ? 
                        (stats.successfulRequests / stats.totalRequests * 100).toFixed(2) : 0,
                    averageResponseTime: stats.totalRequests > 0 ? 
                        (stats.totalResponseTime / stats.totalRequests).toFixed(2) : 0,
                    lastFailureTime: stats.lastFailureTime,
                    circuitBreakerStatus: this.getCircuitBreakerStatus(serviceName)
                }
            };

            // Reset counters for next period
            stats.totalRequests = 0;
            stats.successfulRequests = 0;
            stats.failedRequests = 0;
            stats.totalResponseTime = 0;

            this.logger.info('Service health metrics', healthData);
        }
    }

    // Circuit breaker implementation
    setupCircuitBreakers() {
        // Initialize circuit breakers for services
        this.circuitBreakerStates = new Map();
    }

    isCircuitBreakerOpen(serviceName) {
        const breaker = this.circuitBreakerStates.get(serviceName);
        if (!breaker) return false;

        if (breaker.state === 'open') {
            // Check if we should try half-open
            if (Date.now() - breaker.lastFailureTime > 60000) { // 1 minute
                breaker.state = 'half-open';
                this.logger.info('Circuit breaker moved to half-open state', {
                    serviceName,
                    previousState: 'open'
                });
                return false;
            }
            return true;
        }

        return false;
    }

    updateSuccessMetrics(serviceName, responseTime) {
        // Update service metrics
        if (!this.metrics.services.has(serviceName)) {
            this.metrics.services.set(serviceName, {
                totalRequests: 0,
                successfulRequests: 0,
                failedRequests: 0,
                totalResponseTime: 0,
                lastFailureTime: null
            });
        }

        const stats = this.metrics.services.get(serviceName);
        stats.totalRequests++;
        stats.successfulRequests++;
        stats.totalResponseTime += responseTime;

        // Update circuit breaker
        const breaker = this.circuitBreakerStates.get(serviceName);
        if (breaker) {
            breaker.consecutiveFailures = 0;
            if (breaker.state === 'half-open') {
                breaker.state = 'closed';
                this.logger.info('Circuit breaker closed after successful request', {
                    serviceName
                });
            }
        }
    }

    updateFailureMetrics(serviceName) {
        // Update service metrics
        if (!this.metrics.services.has(serviceName)) {
            this.metrics.services.set(serviceName, {
                totalRequests: 0,
                successfulRequests: 0,
                failedRequests: 0,
                totalResponseTime: 0,
                lastFailureTime: null
            });
        }

        const stats = this.metrics.services.get(serviceName);
        stats.totalRequests++;
        stats.failedRequests++;
        stats.lastFailureTime = new Date().toISOString();

        // Update circuit breaker
        if (!this.circuitBreakerStates.has(serviceName)) {
            this.circuitBreakerStates.set(serviceName, {
                state: 'closed',
                consecutiveFailures: 0,
                lastFailureTime: Date.now()
            });
        }

        const breaker = this.circuitBreakerStates.get(serviceName);
        breaker.consecutiveFailures++;
        breaker.lastFailureTime = Date.now();

        // Open circuit breaker if threshold reached
        if (breaker.consecutiveFailures >= this.config.circuitBreakerThreshold) {
            breaker.state = 'open';
            this.logger.error('Circuit breaker opened due to consecutive failures', {
                serviceName,
                consecutiveFailures: breaker.consecutiveFailures,
                threshold: this.config.circuitBreakerThreshold
            });
        }
    }

    // Utility methods
    generateRequestId() {
        return crypto.randomBytes(16).toString('hex');
    }

    sanitizeHeaders(headers) {
        const sanitized = { ...headers };
        this.config.sensitiveHeaders.forEach(header => {
            if (sanitized[header]) {
                sanitized[header] = '[REDACTED]';
            }
        });
        return sanitized;
    }

    sanitizeBody(body) {
        if (typeof body === 'string') {
            return body.length > this.config.maxBodySize ? 
                body.substring(0, this.config.maxBodySize) + '...[TRUNCATED]' : body;
        }
        
        if (typeof body === 'object') {
            const serialized = JSON.stringify(body);
            return serialized.length > this.config.maxBodySize ? 
                serialized.substring(0, this.config.maxBodySize) + '...[TRUNCATED]' : serialized;
        }

        return body;
    }

    calculateResponseSize(response) {
        if (response.headers['content-length']) {
            return parseInt(response.headers['content-length']);
        }
        
        if (response.data) {
            return JSON.stringify(response.data).length;
        }
        
        return 0;
    }

    categorizePerformance(duration) {
        if (duration < 100) return 'excellent';
        if (duration < 500) return 'good';
        if (duration < 1000) return 'acceptable';
        if (duration < 3000) return 'slow';
        return 'very_slow';
    }

    getCircuitBreakerStatus(serviceName) {
        const breaker = this.circuitBreakerStates.get(serviceName);
        return breaker ? breaker.state : 'closed';
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

## Advanced Service Integration Patterns

### HTTP Client Wrapper with Comprehensive Logging

```javascript
class HTTPServiceClient {
    constructor(baseURL, serviceName, options = {}) {
        this.baseURL = baseURL;
        this.serviceName = serviceName;
        this.serviceLogger = new ExternalServiceLogger(options);
        
        // Create axios instance with interceptors
        this.client = axios.create({
            baseURL,
            timeout: options.timeout || 30000
        });

        this.setupInterceptors();
    }

    setupInterceptors() {
        // Request interceptor
        this.client.interceptors.request.use(
            (config) => {
                config.metadata = {
                    startTime: Date.now(),
                    requestId: this.serviceLogger.generateRequestId()
                };

                this.serviceLogger.logger.debug('HTTP request intercepted', {
                    requestId: config.metadata.requestId,
                    url: config.url,
                    method: config.method,
                    service: this.serviceName
                });

                return config;
            },
            (error) => {
                this.serviceLogger.logger.error('HTTP request interceptor error', {
                    error: error.message,
                    service: this.serviceName
                });
                return Promise.reject(error);
            }
        );

        // Response interceptor
        this.client.interceptors.response.use(
            (response) => {
                const duration = Date.now() - response.config.metadata.startTime;

                this.serviceLogger.logger.debug('HTTP response intercepted', {
                    requestId: response.config.metadata.requestId,
                    status: response.status,
                    duration,
                    service: this.serviceName
                });

                return response;
            },
            (error) => {
                const duration = error.config ? 
                    Date.now() - error.config.metadata.startTime : 0;

                this.serviceLogger.logger.error('HTTP response interceptor error', {
                    requestId: error.config?.metadata?.requestId,
                    error: error.message,
                    duration,
                    service: this.serviceName
                });

                return Promise.reject(error);
            }
        );
    }

    async get(endpoint, config = {}) {
        return this.serviceLogger.makeRequest(
            this.serviceName,
            `${this.baseURL}${endpoint}`,
            { ...config, method: 'GET' }
        );
    }

    async post(endpoint, data, config = {}) {
        return this.serviceLogger.makeRequest(
            this.serviceName,
            `${this.baseURL}${endpoint}`,
            { ...config, method: 'POST', data }
        );
    }

    async put(endpoint, data, config = {}) {
        return this.serviceLogger.makeRequest(
            this.serviceName,
            `${this.baseURL}${endpoint}`,
            { ...config, method: 'PUT', data }
        );
    }

    async delete(endpoint, config = {}) {
        return this.serviceLogger.makeRequest(
            this.serviceName,
            `${this.baseURL}${endpoint}`,
            { ...config, method: 'DELETE' }
        );
    }
}
```

### GraphQL Service Client

```javascript
class GraphQLServiceClient {
    constructor(endpoint, serviceName, options = {}) {
        this.endpoint = endpoint;
        this.serviceName = serviceName;
        this.serviceLogger = new ExternalServiceLogger(options);
    }

    async query(query, variables = {}, operationName = null) {
        const requestPayload = {
            query,
            variables,
            operationName
        };

        try {
            const response = await this.serviceLogger.makeRequest(
                this.serviceName,
                this.endpoint,
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    data: requestPayload
                }
            );

            // Log GraphQL-specific information
            this.logGraphQLOperation(query, variables, response.data, operationName);

            return response.data;

        } catch (error) {
            this.logGraphQLError(query, variables, error, operationName);
            throw error;
        }
    }

    logGraphQLOperation(query, variables, response, operationName) {
        const operationType = this.extractOperationType(query);
        const operationFields = this.extractOperationFields(query);

        this.serviceLogger.logger.info('GraphQL operation completed', {
            event: 'graphql_operation_success',
            serviceName: this.serviceName,
            operationType,
            operationName,
            operationFields,
            variableCount: Object.keys(variables).length,
            hasErrors: response.errors ? response.errors.length > 0 : false,
            errorCount: response.errors ? response.errors.length : 0,
            timestamp: new Date().toISOString()
        });

        // Log GraphQL errors (different from HTTP errors)
        if (response.errors && response.errors.length > 0) {
            response.errors.forEach(error => {
                this.serviceLogger.logger.warn('GraphQL operation returned errors', {
                    event: 'graphql_operation_error',
                    serviceName: this.serviceName,
                    operationType,
                    operationName,
                    error: {
                        message: error.message,
                        path: error.path,
                        locations: error.locations,
                        extensions: error.extensions
                    }
                });
            });
        }
    }

    logGraphQLError(query, variables, error, operationName) {
        const operationType = this.extractOperationType(query);

        this.serviceLogger.logger.error('GraphQL operation failed', {
            event: 'graphql_operation_failure',
            serviceName: this.serviceName,
            operationType,
            operationName,
            variableCount: Object.keys(variables).length,
            error: error.message
        });
    }

    extractOperationType(query) {
        const match = query.trim().match(/^(query|mutation|subscription)/i);
        return match ? match[1].toLowerCase() : 'unknown';
    }

    extractOperationFields(query) {
        // Simple field extraction (could be enhanced with proper GraphQL parsing)
        const fieldMatches = query.match(/{\s*(\w+)/g);
        return fieldMatches ? fieldMatches.map(match => match.replace(/[{\s]/g, '')) : [];
    }
}
```

### Database Service Client

```javascript
class DatabaseServiceClient {
    constructor(connectionConfig, serviceName, options = {}) {
        this.serviceName = serviceName;
        this.serviceLogger = new ExternalServiceLogger(options);
        this.connectionConfig = connectionConfig;
        this.queryStats = new Map();
    }

    async executeQuery(query, params = [], queryType = 'unknown') {
        const queryId = crypto.randomBytes(8).toString('hex');
        const startTime = Date.now();

        try {
            this.logQueryStart(queryId, query, params, queryType);

            // Execute query (implementation depends on database driver)
            const result = await this.performDatabaseQuery(query, params);

            this.logQuerySuccess(queryId, query, result, startTime, queryType);

            return result;

        } catch (error) {
            this.logQueryFailure(queryId, query, error, startTime, queryType);
            throw error;
        }
    }

    logQueryStart(queryId, query, params, queryType) {
        this.serviceLogger.logger.info('Database query initiated', {
            event: 'database_query_start',
            queryId,
            serviceName: this.serviceName,
            queryType,
            query: this.sanitizeQuery(query),
            parameterCount: params.length,
            timestamp: new Date().toISOString()
        });
    }

    logQuerySuccess(queryId, query, result, startTime, queryType) {
        const duration = Date.now() - startTime;
        const rowCount = this.extractRowCount(result);

        this.serviceLogger.logger.info('Database query completed', {
            event: 'database_query_success',
            queryId,
            serviceName: this.serviceName,
            queryType,
            duration,
            rowCount,
            performance: this.serviceLogger.categorizePerformance(duration),
            timestamp: new Date().toISOString()
        });

        // Update query statistics
        this.updateQueryStats(queryType, duration, true);
    }

    logQueryFailure(queryId, query, error, startTime, queryType) {
        const duration = Date.now() - startTime;

        this.serviceLogger.logger.error('Database query failed', {
            event: 'database_query_failure',
            queryId,
            serviceName: this.serviceName,
            queryType,
            duration,
            error: {
                message: error.message,
                code: error.code,
                detail: error.detail,
                hint: error.hint,
                position: error.position
            },
            query: this.sanitizeQuery(query),
            timestamp: new Date().toISOString()
        });

        // Update query statistics
        this.updateQueryStats(queryType, duration, false);
    }

    sanitizeQuery(query) {
        // Remove or mask sensitive data from queries
        return query
            .replace(/'\w*@\w+\.\w+'/g, "'[EMAIL]'")  // Email addresses
            .replace(/'\d{4}-\d{4}-\d{4}-\d{4}'/g, "'[CARD]'")  // Credit cards
            .replace(/'\d{3}-\d{2}-\d{4}'/g, "'[SSN]'");  // SSN pattern
    }

    extractRowCount(result) {
        if (result && typeof result.rowCount === 'number') {
            return result.rowCount;
        }
        if (result && Array.isArray(result.rows)) {
            return result.rows.length;
        }
        if (Array.isArray(result)) {
            return result.length;
        }
        return 0;
    }

    updateQueryStats(queryType, duration, success) {
        if (!this.queryStats.has(queryType)) {
            this.queryStats.set(queryType, {
                totalQueries: 0,
                successfulQueries: 0,
                failedQueries: 0,
                totalDuration: 0,
                averageDuration: 0
            });
        }

        const stats = this.queryStats.get(queryType);
        stats.totalQueries++;
        stats.totalDuration += duration;
        stats.averageDuration = stats.totalDuration / stats.totalQueries;

        if (success) {
            stats.successfulQueries++;
        } else {
            stats.failedQueries++;
        }
    }

    async performDatabaseQuery(query, params) {
        // This would be implemented based on your database driver
        // Example for PostgreSQL with pg library:
        // return await this.pool.query(query, params);
        throw new Error('Database query implementation required');
    }
}
```

## Usage Examples

### Basic HTTP Service Integration

```javascript
// Initialize the external service logger
const paymentServiceLogger = new ExternalServiceLogger({
    logHeaders: true,
    logRequestBody: true,
    logResponseBody: false,
    maxBodySize: 2048,
    retryAttempts: 3,
    circuitBreakerThreshold: 5
});

// Example: Payment service integration
async function processPayment(paymentData) {
    try {
        const response = await paymentServiceLogger.makeRequest(
            'stripe-api',
            'https://api.stripe.com/v1/charges',
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${process.env.STRIPE_SECRET_KEY}`,
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                data: paymentData
            }
        );

        return {
            success: true,
            chargeId: response.data.id,
            amount: response.data.amount
        };

    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}
```

### Microservice Communication

```javascript
// User service client
const userServiceClient = new HTTPServiceClient(
    'http://user-service:3001',
    'user-service',
    {
        timeout: 5000,
        logHeaders: false,
        logResponseBody: true
    }
);

// Example: Get user profile
async function getUserProfile(userId) {
    try {
        const response = await userServiceClient.get(`/users/${userId}`);
        return response.data;
    } catch (error) {
        console.error('Failed to fetch user profile:', error.message);
        throw error;
    }
}

// Example: Update user preferences
async function updateUserPreferences(userId, preferences) {
    try {
        const response = await userServiceClient.put(
            `/users/${userId}/preferences`,
            preferences
        );
        return response.data;
    } catch (error) {
        console.error('Failed to update user preferences:', error.message);
        throw error;
    }
}
```

### GraphQL API Integration

```javascript
// Initialize GraphQL client
const graphqlClient = new GraphQLServiceClient(
    'https://api.github.com/graphql',
    'github-api',
    {
        logRequestBody: true,
        logResponseBody: false
    }
);

// Example: Fetch repository information
async function getRepositoryInfo(owner, name) {
    const query = `
        query GetRepository($owner: String!, $name: String!) {
            repository(owner: $owner, name: $name) {
                id
                name
                description
                stargazerCount
                forkCount
                issues(states: OPEN) {
                    totalCount
                }
                pullRequests(states: OPEN) {
                    totalCount
                }
            }
        }
    `;

    const variables = { owner, name };

    try {
        const result = await graphqlClient.query(query, variables, 'GetRepository');
        return result.data.repository;
    } catch (error) {
        console.error('Failed to fetch repository info:', error.message);
        throw error;
    }
}
```

### Database Integration

```javascript
// PostgreSQL service client
const dbClient = new DatabaseServiceClient(
    {
        host: 'localhost',
        port: 5432,
        database: 'myapp',
        user: 'postgres',
        password: process.env.DB_PASSWORD
    },
    'postgresql-main'
);

// Example: User queries
async function findUserByEmail(email) {
    const query = 'SELECT id, username, email, created_at FROM users WHERE email = $1';
    const params = [email];

    try {
        const result = await dbClient.executeQuery(query, params, 'user_lookup');
        return result.rows[0] || null;
    } catch (error) {
        console.error('Database query failed:', error.message);
        throw error;
    }
}

async function createUser(userData) {
    const query = `
        INSERT INTO users (username, email, password_hash, created_at)
        VALUES ($1, $2, $3, NOW())
        RETURNING id, username, email, created_at
    `;
    const params = [userData.username, userData.email, userData.passwordHash];

    try {
        const result = await dbClient.executeQuery(query, params, 'user_creation');
        return result.rows[0];
    } catch (error) {
        console.error('User creation failed:', error.message);
        throw error;
    }
}
```

## Production Examples

### E-commerce Order Processing

```javascript
class OrderProcessingService {
    constructor() {
        // Initialize service clients
        this.inventoryService = new HTTPServiceClient(
            process.env.INVENTORY_SERVICE_URL,
            'inventory-service'
        );
        
        this.paymentService = new HTTPServiceClient(
            process.env.PAYMENT_SERVICE_URL,
            'payment-service'
        );
        
        this.shippingService = new HTTPServiceClient(
            process.env.SHIPPING_SERVICE_URL,
            'shipping-service'
        );

        this.notificationService = new HTTPServiceClient(
            process.env.NOTIFICATION_SERVICE_URL,
            'notification-service'
        );
    }

    async processOrder(orderData) {
        const orderId = orderData.id;
        const correlationId = crypto.randomBytes(16).toString('hex');

        try {
            // Step 1: Check inventory
            console.log(`[${correlationId}] Starting order processing for order ${orderId}`);
            
            const inventoryCheck = await this.inventoryService.post('/check-availability', {
                correlationId,
                items: orderData.items
            });

            if (!inventoryCheck.data.available) {
                throw new Error('Insufficient inventory');
            }

            // Step 2: Process payment
            const paymentResult = await this.paymentService.post('/charge', {
                correlationId,
                amount: orderData.total,
                currency: orderData.currency,
                source: orderData.paymentMethod
            });

            // Step 3: Reserve inventory
            await this.inventoryService.post('/reserve', {
                correlationId,
                items: orderData.items,
                orderId
            });

            // Step 4: Create shipping label
            const shippingLabel = await this.shippingService.post('/create-label', {
                correlationId,
                orderId,
                address: orderData.shippingAddress,
                items: orderData.items
            });

            // Step 5: Send confirmation notification
            await this.notificationService.post('/send', {
                correlationId,
                type: 'order_confirmation',
                recipient: orderData.customerEmail,
                data: {
                    orderId,
                    trackingNumber: shippingLabel.data.trackingNumber
                }
            });

            console.log(`[${correlationId}] Order processing completed successfully for order ${orderId}`);

            return {
                success: true,
                orderId,
                trackingNumber: shippingLabel.data.trackingNumber,
                chargeId: paymentResult.data.id
            };

        } catch (error) {
            console.error(`[${correlationId}] Order processing failed for order ${orderId}:`, error.message);

            // Attempt rollback
            await this.rollbackOrder(orderId, correlationId);

            throw error;
        }
    }

    async rollbackOrder(orderId, correlationId) {
        console.log(`[${correlationId}] Starting rollback for order ${orderId}`);

        try {
            // Release reserved inventory
            await this.inventoryService.post('/release', {
                correlationId,
                orderId
            });

            console.log(`[${correlationId}] Rollback completed for order ${orderId}`);
        } catch (rollbackError) {
            console.error(`[${correlationId}] Rollback failed for order ${orderId}:`, rollbackError.message);
        }
    }
}
```

## Key Benefits

1. **Comprehensive Visibility**: Complete tracing of external service interactions
2. **Performance Monitoring**: Detailed metrics for response times and success rates
3. **Failure Analysis**: Rich error information for debugging and improvement
4. **Circuit Breaker Pattern**: Automatic protection against cascading failures
5. **Retry Logic**: Intelligent retry mechanisms with exponential backoff
6. **Security**: Automatic sanitization of sensitive data in logs
7. **Service Health**: Real-time monitoring of external service health
8. **Correlation**: Request tracking across service boundaries
9. **Compliance**: Audit trails for external service interactions
10. **Operational Excellence**: Production-ready monitoring and alerting

This external service logging implementation provides enterprise-grade visibility into API integrations while maintaining security and performance standards.
