# 3.1.2 Configuration Changes

## Understanding Configuration Change Logging

Configuration changes are critical events that can significantly impact application behavior, security, and performance. Proper logging of configuration modifications provides visibility into system changes, enables troubleshooting, supports compliance requirements, and maintains an audit trail for operational decisions.

## Why Log Configuration Changes?

### **Operational Benefits**
- **Change Tracking**: Monitor when and what configurations were modified
- **Troubleshooting**: Correlate issues with recent configuration changes
- **Rollback Support**: Provide information needed for configuration rollbacks
- **Environment Drift**: Detect unintended configuration differences between environments
- **Impact Analysis**: Understand the scope and effect of configuration changes

### **Security & Compliance Benefits**
- **Audit Trail**: Maintain records for compliance and security audits
- **Change Authorization**: Track who made changes and whether they were authorized
- **Security Impact**: Monitor changes that could affect system security
- **Regulatory Compliance**: Meet requirements for change documentation

## Advanced Configuration Change Logger

### 1. **Comprehensive Configuration Change Tracking System**

```javascript
// Advanced configuration change logging system
const { EventEmitter } = require('events');
const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');

class ConfigurationChangeLogger extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      applicationName: options.applicationName || process.env.APP_NAME || 'unknown-app',
      version: options.version || process.env.APP_VERSION || '1.0.0',
      environment: options.environment || process.env.NODE_ENV || 'development',
      instanceId: options.instanceId || this.generateInstanceId(),
      
      // Change tracking options
      trackFileChanges: options.trackFileChanges !== false,
      trackEnvironmentChanges: options.trackEnvironmentChanges !== false,
      trackRuntimeChanges: options.trackRuntimeChanges !== false,
      trackDatabaseChanges: options.trackDatabaseChanges !== false,
      
      // Security options
      encryptSensitiveValues: options.encryptSensitiveValues !== false,
      maskSensitiveKeys: options.maskSensitiveKeys !== false,
      sensitiveKeys: options.sensitiveKeys || [
        'password', 'secret', 'key', 'token', 'auth', 'credential',
        'private', 'api_key', 'database_url', 'connection_string'
      ],
      
      // Storage options
      persistChanges: options.persistChanges !== false,
      changeHistoryPath: options.changeHistoryPath || './config-changes.log',
      maxHistorySize: options.maxHistorySize || 10000,
      
      // Validation options
      validateChanges: options.validateChanges !== false,
      requireApproval: options.requireApproval || false,
      approvalTimeout: options.approvalTimeout || 300000, // 5 minutes
      
      // Monitoring options
      monitorConfigFiles: options.monitorConfigFiles || [],
      monitorDirectories: options.monitorDirectories || [],
      pollInterval: options.pollInterval || 30000, // 30 seconds
      
      // Change impact analysis
      analyzeImpact: options.analyzeImpact !== false,
      impactCategories: options.impactCategories || [
        'security', 'performance', 'availability', 'functionality', 'compliance'
      ],
      
      ...options
    };
    
    this.configurationState = new Map();
    this.changeHistory = [];
    this.pendingChanges = new Map();
    this.watchers = new Map();
    this.validators = new Map();
    this.impactAnalyzers = new Map();
    this.approvalQueue = new Map();
    
    this.logger = this.initializeLogger();
    this.changeTracker = this.initializeChangeTracker();
    this.fileWatcher = this.initializeFileWatcher();
    this.impactAnalyzer = this.initializeImpactAnalyzer();
    this.changeValidator = this.initializeChangeValidator();
    
    this.initialize();
  }
  
  initializeLogger() {
    // Initialize your preferred logger here
    return {
      info: (message, metadata) => this.logMessage('INFO', message, metadata),
      warn: (message, metadata) => this.logMessage('WARN', message, metadata),
      error: (message, metadata) => this.logMessage('ERROR', message, metadata),
      debug: (message, metadata) => this.logMessage('DEBUG', message, metadata)
    };
  }
  
  initializeChangeTracker() {
    return {
      trackingEnabled: true,
      lastSnapshot: null,
      changeBuffer: [],
      
      captureSnapshot: async () => {
        const snapshot = {
          timestamp: Date.now(),
          environment: { ...process.env },
          files: await this.captureFileStates(),
          runtime: this.captureRuntimeConfig(),
          database: await this.captureDatabaseConfig(),
          checksum: null
        };
        
        // Calculate checksum for integrity
        snapshot.checksum = this.calculateChecksum(snapshot);
        this.changeTracker.lastSnapshot = snapshot;
        
        return snapshot;
      },
      
      detectChanges: async (newSnapshot) => {
        if (!this.changeTracker.lastSnapshot) {
          return { hasChanges: false, changes: [] };
        }
        
        const changes = [];
        const oldSnapshot = this.changeTracker.lastSnapshot;
        
        // Compare environment variables
        const envChanges = this.compareEnvironmentVariables(
          oldSnapshot.environment, 
          newSnapshot.environment
        );
        changes.push(...envChanges);
        
        // Compare configuration files
        const fileChanges = this.compareFileStates(
          oldSnapshot.files, 
          newSnapshot.files
        );
        changes.push(...fileChanges);
        
        // Compare runtime configuration
        const runtimeChanges = this.compareRuntimeConfig(
          oldSnapshot.runtime, 
          newSnapshot.runtime
        );
        changes.push(...runtimeChanges);
        
        // Compare database configuration
        const dbChanges = this.compareDatabaseConfig(
          oldSnapshot.database, 
          newSnapshot.database
        );
        changes.push(...dbChanges);
        
        return {
          hasChanges: changes.length > 0,
          changes,
          oldChecksum: oldSnapshot.checksum,
          newChecksum: newSnapshot.checksum
        };
      }
    };
  }
  
  initializeFileWatcher() {
    return {
      watchers: new Map(),
      
      watchFile: async (filePath) => {
        try {
          const fs = require('fs');
          const watcher = fs.watch(filePath, (eventType, filename) => {
            this.handleFileChange(filePath, eventType, filename);
          });
          
          this.fileWatcher.watchers.set(filePath, watcher);
          
          this.logger.debug(`Started watching file: ${filePath}`, {
            event: 'file_watcher_started',
            filePath,
            eventType: 'watch_start'
          });
          
        } catch (error) {
          this.logger.error(`Failed to watch file: ${filePath}`, {
            event: 'file_watcher_error',
            filePath,
            error: {
              message: error.message,
              name: error.name
            }
          });
        }
      },
      
      watchDirectory: async (dirPath) => {
        try {
          const fs = require('fs');
          const watcher = fs.watch(dirPath, { recursive: true }, (eventType, filename) => {
            const fullPath = path.join(dirPath, filename || '');
            this.handleFileChange(fullPath, eventType, filename);
          });
          
          this.fileWatcher.watchers.set(dirPath, watcher);
          
          this.logger.debug(`Started watching directory: ${dirPath}`, {
            event: 'directory_watcher_started',
            dirPath,
            eventType: 'watch_start'
          });
          
        } catch (error) {
          this.logger.error(`Failed to watch directory: ${dirPath}`, {
            event: 'directory_watcher_error',
            dirPath,
            error: {
              message: error.message,
              name: error.name
            }
          });
        }
      },
      
      stopWatching: () => {
        for (const [path, watcher] of this.fileWatcher.watchers) {
          try {
            watcher.close();
            this.logger.debug(`Stopped watching: ${path}`, {
              event: 'watcher_stopped',
              path
            });
          } catch (error) {
            this.logger.error(`Error stopping watcher for ${path}:`, error);
          }
        }
        this.fileWatcher.watchers.clear();
      }
    };
  }
  
  initializeImpactAnalyzer() {
    return {
      analyzeChangeImpact: (change) => {
        const impact = {
          categories: [],
          severity: 'low',
          affectedComponents: [],
          recommendations: [],
          risks: []
        };
        
        // Analyze based on change type and key
        if (change.type === 'environment') {
          impact.categories.push('configuration');
          
          if (this.isSensitiveKey(change.key)) {
            impact.categories.push('security');
            impact.severity = 'high';
            impact.risks.push('Potential security credential exposure');
          }
          
          if (change.key.toLowerCase().includes('database')) {
            impact.categories.push('availability');
            impact.affectedComponents.push('database');
            impact.severity = 'medium';
          }
          
          if (change.key.toLowerCase().includes('cache')) {
            impact.categories.push('performance');
            impact.affectedComponents.push('cache');
          }
        }
        
        if (change.type === 'file') {
          impact.categories.push('configuration');
          
          if (change.filePath.includes('security') || change.filePath.includes('auth')) {
            impact.categories.push('security');
            impact.severity = 'high';
          }
          
          if (change.filePath.includes('nginx') || change.filePath.includes('apache')) {
            impact.categories.push('availability');
            impact.affectedComponents.push('web-server');
            impact.severity = 'medium';
          }
        }
        
        // Generate recommendations
        if (impact.severity === 'high') {
          impact.recommendations.push('Review change with security team');
          impact.recommendations.push('Test in staging environment first');
          impact.recommendations.push('Prepare rollback plan');
        }
        
        if (impact.categories.includes('availability')) {
          impact.recommendations.push('Monitor application health after change');
          impact.recommendations.push('Verify dependent services');
        }
        
        return impact;
      },
      
      assessCumulativeImpact: (changes) => {
        const cumulativeImpact = {
          overallSeverity: 'low',
          affectedSystemsCount: 0,
          criticalChangesCount: 0,
          recommendations: []
        };
        
        const severityLevels = { low: 1, medium: 2, high: 3, critical: 4 };
        let maxSeverity = 0;
        const affectedSystems = new Set();
        
        changes.forEach(change => {
          const impact = this.impactAnalyzer.analyzeChangeImpact(change);
          
          const changeSeverity = severityLevels[impact.severity] || 1;
          maxSeverity = Math.max(maxSeverity, changeSeverity);
          
          impact.affectedComponents.forEach(component => {
            affectedSystems.add(component);
          });
          
          if (impact.severity === 'high' || impact.severity === 'critical') {
            cumulativeImpact.criticalChangesCount++;
          }
        });
        
        cumulativeImpact.overallSeverity = Object.keys(severityLevels)
          .find(key => severityLevels[key] === maxSeverity) || 'low';
        
        cumulativeImpact.affectedSystemsCount = affectedSystems.size;
        
        // Generate cumulative recommendations
        if (cumulativeImpact.criticalChangesCount > 0) {
          cumulativeImpact.recommendations.push('Execute changes in controlled maintenance window');
          cumulativeImpact.recommendations.push('Implement comprehensive monitoring');
        }
        
        if (cumulativeImpact.affectedSystemsCount > 3) {
          cumulativeImpact.recommendations.push('Consider phased rollout approach');
          cumulativeImpact.recommendations.push('Prepare comprehensive rollback strategy');
        }
        
        return cumulativeImpact;
      }
    };
  }
  
  initializeChangeValidator() {
    return {
      validators: new Map(),
      
      registerValidator: (name, validatorFunction) => {
        this.changeValidator.validators.set(name, validatorFunction);
      },
      
      validateChange: async (change) => {
        const validationResults = {
          valid: true,
          errors: [],
          warnings: [],
          recommendations: []
        };
        
        // Run all registered validators
        for (const [name, validator] of this.changeValidator.validators) {
          try {
            const result = await validator(change);
            
            if (result.valid === false) {
              validationResults.valid = false;
              validationResults.errors.push({
                validator: name,
                message: result.message || 'Validation failed',
                details: result.details
              });
            }
            
            if (result.warnings) {
              validationResults.warnings.push(...result.warnings.map(w => ({
                validator: name,
                message: w
              })));
            }
            
            if (result.recommendations) {
              validationResults.recommendations.push(...result.recommendations.map(r => ({
                validator: name,
                message: r
              })));
            }
            
          } catch (error) {
            validationResults.errors.push({
              validator: name,
              message: `Validator error: ${error.message}`,
              details: error.stack
            });
          }
        }
        
        return validationResults;
      },
      
      setupDefaultValidators: () => {
        // Environment variable validator
        this.changeValidator.registerValidator('environment', (change) => {
          if (change.type !== 'environment') return { valid: true };
          
          const result = { valid: true, warnings: [], recommendations: [] };
          
          // Check for sensitive data in non-sensitive environments
          if (this.options.environment !== 'production' && 
              this.isSensitiveKey(change.key)) {
            result.warnings.push('Sensitive configuration in non-production environment');
          }
          
          // Check for empty values
          if (!change.newValue || change.newValue.trim() === '') {
            result.valid = false;
            result.message = 'Configuration value cannot be empty';
          }
          
          // Check for suspicious URLs
          if (change.key.toLowerCase().includes('url') && 
              change.newValue && 
              !change.newValue.match(/^https?:\/\//)) {
            result.warnings.push('URL should use HTTPS protocol');
          }
          
          return result;
        });
        
        // File configuration validator
        this.changeValidator.registerValidator('file', (change) => {
          if (change.type !== 'file') return { valid: true };
          
          const result = { valid: true, warnings: [], recommendations: [] };
          
          // Check file permissions
          if (change.filePath.includes('config') && 
              change.permissions && 
              change.permissions.mode > 0o644) {
            result.warnings.push('Configuration file has overly permissive permissions');
          }
          
          // Check for syntax errors in JSON/YAML files
          if (change.filePath.endsWith('.json')) {
            try {
              JSON.parse(change.content);
            } catch (error) {
              result.valid = false;
              result.message = `Invalid JSON syntax: ${error.message}`;
            }
          }
          
          return result;
        });
        
        // Security validator
        this.changeValidator.registerValidator('security', (change) => {
          const result = { valid: true, warnings: [], recommendations: [] };
          
          // Check for hardcoded secrets
          if (change.newValue && typeof change.newValue === 'string') {
            const suspiciousPatterns = [
              /password\s*=\s*['"]\w+['"]/i,
              /api[_-]?key\s*=\s*['"]\w+['"]/i,
              /secret\s*=\s*['"]\w+['"]/i,
              /token\s*=\s*['"]\w+['"]/i
            ];
            
            for (const pattern of suspiciousPatterns) {
              if (pattern.test(change.newValue)) {
                result.warnings.push('Potential hardcoded credential detected');
                result.recommendations.push('Use environment variables or secret management');
                break;
              }
            }
          }
          
          return result;
        });
      }
    };
  }
  
  generateInstanceId() {
    const os = require('os');
    const identifier = `${os.hostname()}-${process.pid}-${Date.now()}`;
    return crypto.createHash('md5').update(identifier).digest('hex').substring(0, 8);
  }
  
  calculateChecksum(data) {
    const content = JSON.stringify(data, Object.keys(data).sort());
    return crypto.createHash('sha256').update(content).digest('hex');
  }
  
  logMessage(level, message, metadata = {}) {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      application: this.options.applicationName,
      version: this.options.version,
      environment: this.options.environment,
      instanceId: this.options.instanceId,
      category: 'configuration-change',
      ...metadata
    };
    
    console.log(JSON.stringify(logEntry));
    this.emit('log', logEntry);
  }
  
  async initialize() {
    try {
      // Setup default validators
      this.changeValidator.setupDefaultValidators();
      
      // Capture initial configuration snapshot
      await this.changeTracker.captureSnapshot();
      
      // Setup file watchers
      if (this.options.trackFileChanges) {
        await this.setupFileWatchers();
      }
      
      // Start periodic monitoring
      if (this.options.pollInterval > 0) {
        this.startPeriodicMonitoring();
      }
      
      this.logger.info('Configuration change logger initialized', {
        event: 'config_logger_initialized',
        trackFileChanges: this.options.trackFileChanges,
        trackEnvironmentChanges: this.options.trackEnvironmentChanges,
        monitoredFiles: this.options.monitorConfigFiles.length,
        monitoredDirectories: this.options.monitorDirectories.length
      });
      
    } catch (error) {
      this.logger.error('Failed to initialize configuration change logger', {
        event: 'config_logger_init_failed',
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name
        }
      });
      throw error;
    }
  }
  
  async setupFileWatchers() {
    // Watch specific configuration files
    for (const filePath of this.options.monitorConfigFiles) {
      await this.fileWatcher.watchFile(filePath);
    }
    
    // Watch configuration directories
    for (const dirPath of this.options.monitorDirectories) {
      await this.fileWatcher.watchDirectory(dirPath);
    }
  }
  
  startPeriodicMonitoring() {
    this.monitoringInterval = setInterval(async () => {
      try {
        await this.performPeriodicCheck();
      } catch (error) {
        this.logger.error('Periodic configuration check failed', {
          event: 'periodic_check_failed',
          error: {
            message: error.message,
            name: error.name
          }
        });
      }
    }, this.options.pollInterval);
  }
  
  async performPeriodicCheck() {
    const newSnapshot = await this.changeTracker.captureSnapshot();
    const changeDetection = await this.changeTracker.detectChanges(newSnapshot);
    
    if (changeDetection.hasChanges) {
      await this.processDetectedChanges(changeDetection.changes);
    }
    
    // Update the snapshot
    this.changeTracker.lastSnapshot = newSnapshot;
  }
  
  async processDetectedChanges(changes) {
    for (const change of changes) {
      await this.logConfigurationChange(change);
    }
    
    // Analyze cumulative impact
    if (changes.length > 1) {
      const cumulativeImpact = this.impactAnalyzer.assessCumulativeImpact(changes);
      
      this.logger.info('Multiple configuration changes detected', {
        event: 'cumulative_config_changes',
        changeCount: changes.length,
        overallSeverity: cumulativeImpact.overallSeverity,
        affectedSystemsCount: cumulativeImpact.affectedSystemsCount,
        criticalChangesCount: cumulativeImpact.criticalChangesCount,
        recommendations: cumulativeImpact.recommendations
      });
    }
  }
  
  async handleFileChange(filePath, eventType, filename) {
    try {
      const change = await this.captureFileChange(filePath, eventType);
      
      if (change) {
        await this.logConfigurationChange(change);
      }
      
    } catch (error) {
      this.logger.error('Error handling file change', {
        event: 'file_change_error',
        filePath,
        eventType,
        filename,
        error: {
          message: error.message,
          name: error.name
        }
      });
    }
  }
  
  async captureFileChange(filePath, eventType) {
    try {
      const stats = await fs.stat(filePath);
      const content = await fs.readFile(filePath, 'utf8');
      
      const change = {
        id: this.generateChangeId(),
        timestamp: Date.now(),
        type: 'file',
        source: 'file_watcher',
        filePath,
        eventType,
        content,
        size: stats.size,
        modified: stats.mtime.toISOString(),
        permissions: {
          mode: stats.mode,
          readable: true,
          writable: true
        },
        checksum: crypto.createHash('md5').update(content).digest('hex')
      };
      
      return change;
      
    } catch (error) {
      if (error.code === 'ENOENT') {
        // File was deleted
        return {
          id: this.generateChangeId(),
          timestamp: Date.now(),
          type: 'file',
          source: 'file_watcher',
          filePath,
          eventType: 'deleted',
          content: null
        };
      }
      throw error;
    }
  }
  
  async captureFileStates() {
    const fileStates = {};
    
    for (const filePath of this.options.monitorConfigFiles) {
      try {
        const stats = await fs.stat(filePath);
        const content = await fs.readFile(filePath, 'utf8');
        
        fileStates[filePath] = {
          size: stats.size,
          modified: stats.mtime.toISOString(),
          checksum: crypto.createHash('md5').update(content).digest('hex'),
          permissions: stats.mode
        };
      } catch (error) {
        fileStates[filePath] = {
          error: error.message,
          exists: false
        };
      }
    }
    
    return fileStates;
  }
  
  captureRuntimeConfig() {
    // Capture runtime configuration that might change
    return {
      nodeVersion: process.version,
      platform: process.platform,
      architecture: process.arch,
      memoryUsage: process.memoryUsage(),
      uptime: process.uptime(),
      workingDirectory: process.cwd(),
      execPath: process.execPath,
      execArgv: process.execArgv,
      argv: process.argv
    };
  }
  
  async captureDatabaseConfig() {
    // Placeholder for database configuration capture
    // In a real implementation, this would connect to databases
    // and capture relevant configuration settings
    return {
      connections: [],
      poolSizes: {},
      timeouts: {},
      lastUpdated: new Date().toISOString()
    };
  }
  
  compareEnvironmentVariables(oldEnv, newEnv) {
    const changes = [];
    const allKeys = new Set([...Object.keys(oldEnv), ...Object.keys(newEnv)]);
    
    for (const key of allKeys) {
      const oldValue = oldEnv[key];
      const newValue = newEnv[key];
      
      if (oldValue !== newValue) {
        changes.push({
          id: this.generateChangeId(),
          timestamp: Date.now(),
          type: 'environment',
          source: 'environment_monitoring',
          key,
          oldValue: this.sanitizeValue(key, oldValue),
          newValue: this.sanitizeValue(key, newValue),
          changeType: !oldValue ? 'added' : !newValue ? 'removed' : 'modified'
        });
      }
    }
    
    return changes;
  }
  
  compareFileStates(oldFiles, newFiles) {
    const changes = [];
    const allFiles = new Set([...Object.keys(oldFiles), ...Object.keys(newFiles)]);
    
    for (const filePath of allFiles) {
      const oldState = oldFiles[filePath];
      const newState = newFiles[filePath];
      
      if (!oldState && newState) {
        // File added
        changes.push({
          id: this.generateChangeId(),
          timestamp: Date.now(),
          type: 'file',
          source: 'file_monitoring',
          filePath,
          changeType: 'added',
          newState
        });
      } else if (oldState && !newState) {
        // File removed
        changes.push({
          id: this.generateChangeId(),
          timestamp: Date.now(),
          type: 'file',
          source: 'file_monitoring',
          filePath,
          changeType: 'removed',
          oldState
        });
      } else if (oldState && newState && oldState.checksum !== newState.checksum) {
        // File modified
        changes.push({
          id: this.generateChangeId(),
          timestamp: Date.now(),
          type: 'file',
          source: 'file_monitoring',
          filePath,
          changeType: 'modified',
          oldState,
          newState
        });
      }
    }
    
    return changes;
  }
  
  compareRuntimeConfig(oldConfig, newConfig) {
    const changes = [];
    const significantKeys = ['workingDirectory', 'execArgv', 'argv'];
    
    for (const key of significantKeys) {
      const oldValue = JSON.stringify(oldConfig[key]);
      const newValue = JSON.stringify(newConfig[key]);
      
      if (oldValue !== newValue) {
        changes.push({
          id: this.generateChangeId(),
          timestamp: Date.now(),
          type: 'runtime',
          source: 'runtime_monitoring',
          key,
          oldValue: oldConfig[key],
          newValue: newConfig[key],
          changeType: 'modified'
        });
      }
    }
    
    return changes;
  }
  
  compareDatabaseConfig(oldConfig, newConfig) {
    // Placeholder for database configuration comparison
    // In a real implementation, this would compare database settings
    return [];
  }
  
  sanitizeValue(key, value) {
    if (!value) return value;
    
    if (this.isSensitiveKey(key)) {
      if (this.options.maskSensitiveKeys) {
        return this.maskValue(value);
      }
      
      if (this.options.encryptSensitiveValues) {
        return this.encryptValue(value);
      }
      
      return '[REDACTED]';
    }
    
    return value;
  }
  
  isSensitiveKey(key) {
    const lowerKey = key.toLowerCase();
    return this.options.sensitiveKeys.some(sensitive => 
      lowerKey.includes(sensitive.toLowerCase())
    );
  }
  
  maskValue(value) {
    if (typeof value !== 'string' || value.length <= 4) {
      return '[MASKED]';
    }
    
    const visibleChars = 2;
    const masked = '*'.repeat(Math.max(0, value.length - visibleChars * 2));
    return `${value.substring(0, visibleChars)}${masked}${value.substring(value.length - visibleChars)}`;
  }
  
  encryptValue(value) {
    // Simple encryption for demonstration - use proper encryption in production
    try {
      const cipher = crypto.createCipher('aes192', this.options.instanceId);
      let encrypted = cipher.update(value, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      return `[ENCRYPTED:${encrypted}]`;
    } catch (error) {
      return '[ENCRYPTION_FAILED]';
    }
  }
  
  generateChangeId() {
    return `chg_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }
  
  async logConfigurationChange(change) {
    try {
      // Validate change if validation is enabled
      if (this.options.validateChanges) {
        const validation = await this.changeValidator.validateChange(change);
        change.validation = validation;
        
        if (!validation.valid) {
          this.logger.error('Configuration change validation failed', {
            event: 'config_change_validation_failed',
            changeId: change.id,
            changeType: change.type,
            key: change.key || change.filePath,
            validationErrors: validation.errors,
            change: this.sanitizeChangeForLogging(change)
          });
          
          if (this.options.requireApproval) {
            await this.requestChangeApproval(change);
            return;
          }
        }
        
        if (validation.warnings.length > 0) {
          this.logger.warn('Configuration change has warnings', {
            event: 'config_change_warnings',
            changeId: change.id,
            changeType: change.type,
            key: change.key || change.filePath,
            warnings: validation.warnings,
            change: this.sanitizeChangeForLogging(change)
          });
        }
      }
      
      // Analyze impact
      let impact = null;
      if (this.options.analyzeImpact) {
        impact = this.impactAnalyzer.analyzeChangeImpact(change);
        change.impact = impact;
      }
      
      // Log the change
      const logLevel = this.determineLogLevel(change, impact);
      
      this.logger[logLevel]('Configuration change detected', {
        event: 'configuration_change',
        changeId: change.id,
        changeType: change.type,
        source: change.source,
        key: change.key || change.filePath,
        operation: change.changeType,
        impact: impact ? {
          categories: impact.categories,
          severity: impact.severity,
          affectedComponents: impact.affectedComponents
        } : undefined,
        validation: change.validation ? {
          valid: change.validation.valid,
          warningCount: change.validation.warnings.length,
          errorCount: change.validation.errors.length
        } : undefined,
        change: this.sanitizeChangeForLogging(change),
        timestamp: new Date(change.timestamp).toISOString()
      });
      
      // Store change in history
      this.addToChangeHistory(change);
      
      // Emit event for external handlers
      this.emit('configurationChange', change);
      
      // Handle high-impact changes
      if (impact && (impact.severity === 'high' || impact.severity === 'critical')) {
        await this.handleHighImpactChange(change, impact);
      }
      
    } catch (error) {
      this.logger.error('Error processing configuration change', {
        event: 'config_change_processing_error',
        changeId: change.id,
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name
        }
      });
    }
  }
  
  determineLogLevel(change, impact) {
    if (change.validation && !change.validation.valid) {
      return 'error';
    }
    
    if (impact) {
      switch (impact.severity) {
        case 'critical':
        case 'high':
          return 'warn';
        case 'medium':
          return 'info';
        default:
          return 'debug';
      }
    }
    
    if (change.type === 'environment' && this.isSensitiveKey(change.key)) {
      return 'warn';
    }
    
    return 'info';
  }
  
  sanitizeChangeForLogging(change) {
    const sanitized = { ...change };
    
    // Remove sensitive content
    if (sanitized.oldValue && this.isSensitiveKey(sanitized.key)) {
      sanitized.oldValue = this.sanitizeValue(sanitized.key, sanitized.oldValue);
    }
    
    if (sanitized.newValue && this.isSensitiveKey(sanitized.key)) {
      sanitized.newValue = this.sanitizeValue(sanitized.key, sanitized.newValue);
    }
    
    // Truncate large content
    if (sanitized.content && sanitized.content.length > 1000) {
      sanitized.content = sanitized.content.substring(0, 1000) + '... [TRUNCATED]';
    }
    
    return sanitized;
  }
  
  addToChangeHistory(change) {
    this.changeHistory.push(change);
    
    // Limit history size
    if (this.changeHistory.length > this.options.maxHistorySize) {
      this.changeHistory = this.changeHistory.slice(-this.options.maxHistorySize);
    }
    
    // Persist if enabled
    if (this.options.persistChanges) {
      this.persistChangeHistory();
    }
  }
  
  async persistChangeHistory() {
    try {
      const historyData = {
        application: this.options.applicationName,
        instanceId: this.options.instanceId,
        lastUpdated: new Date().toISOString(),
        changes: this.changeHistory
      };
      
      await fs.writeFile(
        this.options.changeHistoryPath,
        JSON.stringify(historyData, null, 2)
      );
      
    } catch (error) {
      this.logger.error('Failed to persist change history', {
        event: 'persist_history_failed',
        error: {
          message: error.message,
          name: error.name
        }
      });
    }
  }
  
  async handleHighImpactChange(change, impact) {
    this.logger.warn('High-impact configuration change detected', {
      event: 'high_impact_config_change',
      changeId: change.id,
      severity: impact.severity,
      categories: impact.categories,
      affectedComponents: impact.affectedComponents,
      risks: impact.risks,
      recommendations: impact.recommendations
    });
    
    // Send alert to monitoring system
    this.emit('highImpactChange', { change, impact });
    
    // If approval is required, request it
    if (this.options.requireApproval) {
      await this.requestChangeApproval(change);
    }
  }
  
  async requestChangeApproval(change) {
    const approvalId = `approval_${change.id}`;
    
    this.approvalQueue.set(approvalId, {
      change,
      requested: Date.now(),
      status: 'pending',
      timeout: setTimeout(() => {
        this.handleApprovalTimeout(approvalId);
      }, this.options.approvalTimeout)
    });
    
    this.logger.warn('Configuration change requires approval', {
      event: 'config_change_approval_required',
      approvalId,
      changeId: change.id,
      changeType: change.type,
      key: change.key || change.filePath,
      timeoutMinutes: this.options.approvalTimeout / 60000
    });
    
    this.emit('approvalRequired', { approvalId, change });
  }
  
  handleApprovalTimeout(approvalId) {
    const approval = this.approvalQueue.get(approvalId);
    
    if (approval && approval.status === 'pending') {
      approval.status = 'timeout';
      
      this.logger.error('Configuration change approval timeout', {
        event: 'config_change_approval_timeout',
        approvalId,
        changeId: approval.change.id
      });
      
      this.emit('approvalTimeout', { approvalId, change: approval.change });
    }
  }
  
  // Public API methods
  
  async logEnvironmentChange(key, oldValue, newValue, metadata = {}) {
    const change = {
      id: this.generateChangeId(),
      timestamp: Date.now(),
      type: 'environment',
      source: 'manual',
      key,
      oldValue: this.sanitizeValue(key, oldValue),
      newValue: this.sanitizeValue(key, newValue),
      changeType: !oldValue ? 'added' : !newValue ? 'removed' : 'modified',
      ...metadata
    };
    
    await this.logConfigurationChange(change);
    return change.id;
  }
  
  async logFileChange(filePath, changeType, metadata = {}) {
    const change = {
      id: this.generateChangeId(),
      timestamp: Date.now(),
      type: 'file',
      source: 'manual',
      filePath,
      changeType,
      ...metadata
    };
    
    if (changeType !== 'removed') {
      try {
        const stats = await fs.stat(filePath);
        const content = await fs.readFile(filePath, 'utf8');
        
        change.content = content;
        change.size = stats.size;
        change.modified = stats.mtime.toISOString();
        change.checksum = crypto.createHash('md5').update(content).digest('hex');
      } catch (error) {
        change.error = error.message;
      }
    }
    
    await this.logConfigurationChange(change);
    return change.id;
  }
  
  async logRuntimeChange(key, oldValue, newValue, metadata = {}) {
    const change = {
      id: this.generateChangeId(),
      timestamp: Date.now(),
      type: 'runtime',
      source: 'manual',
      key,
      oldValue,
      newValue,
      changeType: 'modified',
      ...metadata
    };
    
    await this.logConfigurationChange(change);
    return change.id;
  }
  
  async logDatabaseConfigChange(database, setting, oldValue, newValue, metadata = {}) {
    const change = {
      id: this.generateChangeId(),
      timestamp: Date.now(),
      type: 'database',
      source: 'manual',
      database,
      setting,
      oldValue,
      newValue,
      changeType: 'modified',
      ...metadata
    };
    
    await this.logConfigurationChange(change);
    return change.id;
  }
  
  approveChange(approvalId, approver, reason = '') {
    const approval = this.approvalQueue.get(approvalId);
    
    if (!approval) {
      throw new Error(`Approval ${approvalId} not found`);
    }
    
    if (approval.status !== 'pending') {
      throw new Error(`Approval ${approvalId} is not pending (status: ${approval.status})`);
    }
    
    approval.status = 'approved';
    approval.approver = approver;
    approval.approvedAt = Date.now();
    approval.reason = reason;
    
    clearTimeout(approval.timeout);
    
    this.logger.info('Configuration change approved', {
      event: 'config_change_approved',
      approvalId,
      changeId: approval.change.id,
      approver,
      reason
    });
    
    this.emit('changeApproved', { approvalId, change: approval.change, approver });
    
    // Now process the approved change
    this.logConfigurationChange(approval.change);
  }
  
  rejectChange(approvalId, rejector, reason = '') {
    const approval = this.approvalQueue.get(approvalId);
    
    if (!approval) {
      throw new Error(`Approval ${approvalId} not found`);
    }
    
    if (approval.status !== 'pending') {
      throw new Error(`Approval ${approvalId} is not pending (status: ${approval.status})`);
    }
    
    approval.status = 'rejected';
    approval.rejector = rejector;
    approval.rejectedAt = Date.now();
    approval.reason = reason;
    
    clearTimeout(approval.timeout);
    
    this.logger.warn('Configuration change rejected', {
      event: 'config_change_rejected',
      approvalId,
      changeId: approval.change.id,
      rejector,
      reason
    });
    
    this.emit('changeRejected', { approvalId, change: approval.change, rejector });
  }
  
  getChangeHistory(options = {}) {
    let history = [...this.changeHistory];
    
    // Filter by type
    if (options.type) {
      history = history.filter(change => change.type === options.type);
    }
    
    // Filter by time range
    if (options.since) {
      const since = typeof options.since === 'string' ? new Date(options.since).getTime() : options.since;
      history = history.filter(change => change.timestamp >= since);
    }
    
    if (options.until) {
      const until = typeof options.until === 'string' ? new Date(options.until).getTime() : options.until;
      history = history.filter(change => change.timestamp <= until);
    }
    
    // Sort by timestamp (newest first)
    history.sort((a, b) => b.timestamp - a.timestamp);
    
    // Limit results
    if (options.limit) {
      history = history.slice(0, options.limit);
    }
    
    return history;
  }
  
  getApprovalQueue() {
    return Array.from(this.approvalQueue.entries()).map(([id, approval]) => ({
      approvalId: id,
      changeId: approval.change.id,
      status: approval.status,
      requested: approval.requested,
      change: this.sanitizeChangeForLogging(approval.change)
    }));
  }
  
  registerValidator(name, validatorFunction) {
    this.changeValidator.registerValidator(name, validatorFunction);
  }
  
  registerImpactAnalyzer(name, analyzerFunction) {
    this.impactAnalyzers.set(name, analyzerFunction);
  }
  
  // Cleanup methods
  
  async destroy() {
    try {
      // Stop periodic monitoring
      if (this.monitoringInterval) {
        clearInterval(this.monitoringInterval);
      }
      
      // Stop file watchers
      this.fileWatcher.stopWatching();
      
      // Clear approval timeouts
      for (const approval of this.approvalQueue.values()) {
        if (approval.timeout) {
          clearTimeout(approval.timeout);
        }
      }
      
      // Persist final change history
      if (this.options.persistChanges) {
        await this.persistChangeHistory();
      }
      
      this.logger.info('Configuration change logger destroyed', {
        event: 'config_logger_destroyed',
        changesTracked: this.changeHistory.length
      });
      
    } catch (error) {
      this.logger.error('Error during configuration logger destruction', {
        event: 'config_logger_destroy_error',
        error: {
          message: error.message,
          name: error.name
        }
      });
    }
  }
}
```

## Production Usage Examples

### **Basic Configuration Change Logging**
```javascript
// Basic usage with Express.js application
const express = require('express');
const ConfigurationChangeLogger = require('./ConfigurationChangeLogger');

class ConfigurableWebApp {
  constructor() {
    this.app = express();
    this.config = {
      port: process.env.PORT || 3000,
      database: {
        url: process.env.DATABASE_URL,
        pool: {
          min: parseInt(process.env.DB_POOL_MIN) || 2,
          max: parseInt(process.env.DB_POOL_MAX) || 10
        }
      },
      cache: {
        enabled: process.env.CACHE_ENABLED === 'true',
        ttl: parseInt(process.env.CACHE_TTL) || 300
      }
    };
    
    // Initialize configuration change logger
    this.configLogger = new ConfigurationChangeLogger({
      applicationName: 'configurable-web-app',
      version: process.env.APP_VERSION || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      
      // Monitor configuration files
      monitorConfigFiles: [
        './config/app.json',
        './config/database.json',
        '.env'
      ],
      
      // Track environment variables
      trackEnvironmentChanges: true,
      
      // Security settings
      maskSensitiveKeys: true,
      sensitiveKeys: [
        'password', 'secret', 'key', 'token', 'database_url',
        'api_key', 'private_key', 'connection_string'
      ],
      
      // Validation settings
      validateChanges: true,
      requireApproval: process.env.NODE_ENV === 'production',
      
      // Impact analysis
      analyzeImpact: true
    });
    
    this.setupConfigurationHandlers();
    this.setupExpressApp();
  }
  
  setupConfigurationHandlers() {
    // Handle configuration changes
    this.configLogger.on('configurationChange', (change) => {
      this.handleConfigurationChange(change);
    });
    
    // Handle high-impact changes
    this.configLogger.on('highImpactChange', ({ change, impact }) => {
      this.handleHighImpactChange(change, impact);
    });
    
    // Handle approval requirements
    this.configLogger.on('approvalRequired', ({ approvalId, change }) => {
      this.requestConfigurationApproval(approvalId, change);
    });
    
    // Setup custom validators
    this.setupCustomValidators();
  }
  
  setupCustomValidators() {
    // Database URL validator
    this.configLogger.registerValidator('database_url', (change) => {
      if (change.key !== 'DATABASE_URL') return { valid: true };
      
      const result = { valid: true, warnings: [], recommendations: [] };
      
      if (!change.newValue) {
        result.valid = false;
        result.message = 'Database URL cannot be empty';
        return result;
      }
      
      // Check for SSL requirement in production
      if (process.env.NODE_ENV === 'production' && 
          !change.newValue.includes('sslmode=require')) {
        result.warnings.push('Database connection should use SSL in production');
        result.recommendations.push('Add sslmode=require to database URL');
      }
      
      return result;
    });
    
    // Port validator
    this.configLogger.registerValidator('port', (change) => {
      if (change.key !== 'PORT') return { valid: true };
      
      const port = parseInt(change.newValue);
      
      if (isNaN(port) || port < 1 || port > 65535) {
        return {
          valid: false,
          message: 'Port must be a valid number between 1 and 65535'
        };
      }
      
      if (port < 1024 && process.getuid && process.getuid() !== 0) {
        return {
          valid: false,
          message: 'Ports below 1024 require root privileges'
        };
      }
      
      return { valid: true };
    });
  }
  
  setupExpressApp() {
    this.app.use(express.json());
    
    // Configuration management endpoints
    this.app.get('/admin/config', (req, res) => {
      res.json({
        current: this.getSafeConfig(),
        history: this.configLogger.getChangeHistory({ limit: 50 }),
        approvals: this.configLogger.getApprovalQueue()
      });
    });
    
    this.app.post('/admin/config/environment', async (req, res) => {
      try {
        const { key, value, reason } = req.body;
        const oldValue = process.env[key];
        
        // Log the change
        const changeId = await this.configLogger.logEnvironmentChange(
          key, 
          oldValue, 
          value, 
          { 
            user: req.user?.id || 'system',
            reason,
            ip: req.ip
          }
        );
        
        // Apply the change
        process.env[key] = value;
        
        res.json({
          success: true,
          changeId,
          message: `Environment variable ${key} updated`
        });
        
      } catch (error) {
        res.status(400).json({
          success: false,
          error: error.message
        });
      }
    });
    
    this.app.post('/admin/config/approve/:approvalId', (req, res) => {
      try {
        const { approvalId } = req.params;
        const { reason } = req.body;
        const approver = req.user?.id || 'system';
        
        this.configLogger.approveChange(approvalId, approver, reason);
        
        res.json({
          success: true,
          message: `Change ${approvalId} approved`
        });
        
      } catch (error) {
        res.status(400).json({
          success: false,
          error: error.message
        });
      }
    });
    
    this.app.post('/admin/config/reject/:approvalId', (req, res) => {
      try {
        const { approvalId } = req.params;
        const { reason } = req.body;
        const rejector = req.user?.id || 'system';
        
        this.configLogger.rejectChange(approvalId, rejector, reason);
        
        res.json({
          success: true,
          message: `Change ${approvalId} rejected`
        });
        
      } catch (error) {
        res.status(400).json({
          success: false,
          error: error.message
        });
      }
    });
  }
  
  handleConfigurationChange(change) {
    console.log(`Configuration change detected: ${change.type} - ${change.key || change.filePath}`);
    
    // Handle specific configuration changes
    switch (change.key) {
      case 'PORT':
        this.handlePortChange(change);
        break;
      case 'DATABASE_URL':
        this.handleDatabaseUrlChange(change);
        break;
      case 'CACHE_ENABLED':
        this.handleCacheEnabledChange(change);
        break;
    }
  }
  
  handlePortChange(change) {
    const newPort = parseInt(change.newValue);
    
    if (this.server && this.config.port !== newPort) {
      console.log(`Port changed from ${this.config.port} to ${newPort}, restart required`);
      this.config.port = newPort;
      
      // In a real application, you might implement graceful restart
      this.scheduleRestart('Port configuration changed');
    }
  }
  
  handleDatabaseUrlChange(change) {
    console.log('Database URL changed, connection pool will be recreated');
    this.config.database.url = change.newValue;
    
    // Recreate database connection pool
    this.recreateDatabasePool();
  }
  
  handleCacheEnabledChange(change) {
    const enabled = change.newValue === 'true';
    
    if (this.config.cache.enabled !== enabled) {
      console.log(`Cache ${enabled ? 'enabled' : 'disabled'}`);
      this.config.cache.enabled = enabled;
      
      if (enabled) {
        this.initializeCache();
      } else {
        this.destroyCache();
      }
    }
  }
  
  handleHighImpactChange(change, impact) {
    console.warn(`High-impact configuration change detected:`, {
      change: change.key || change.filePath,
      severity: impact.severity,
      affectedComponents: impact.affectedComponents
    });
    
    // Send alert to monitoring system
    this.sendAlert({
      type: 'configuration_change',
      severity: impact.severity,
      change,
      impact
    });
    
    // If in production, might want to require manual restart
    if (process.env.NODE_ENV === 'production' && impact.severity === 'critical') {
      console.log('Critical configuration change in production, manual intervention required');
      this.requireManualIntervention(change, impact);
    }
  }
  
  requestConfigurationApproval(approvalId, change) {
    console.log(`Configuration change requires approval: ${approvalId}`);
    
    // In a real application, you would:
    // - Send notification to administrators
    // - Create approval ticket in ITSM system
    // - Send email/slack message to approvers
    
    this.sendApprovalNotification(approvalId, change);
  }
  
  getSafeConfig() {
    // Return configuration with sensitive values masked
    const safeConfig = JSON.parse(JSON.stringify(this.config));
    
    if (safeConfig.database?.url) {
      safeConfig.database.url = this.maskDatabaseUrl(safeConfig.database.url);
    }
    
    return safeConfig;
  }
  
  maskDatabaseUrl(url) {
    // Mask credentials in database URL
    return url.replace(/:\/\/([^:]+):([^@]+)@/, '://***:***@');
  }
  
  recreateDatabasePool() {
    console.log('Recreating database connection pool with new configuration');
    // Implementation would recreate the database pool
  }
  
  initializeCache() {
    console.log('Initializing cache system');
    // Implementation would initialize cache
  }
  
  destroyCache() {
    console.log('Destroying cache system');
    // Implementation would destroy cache
  }
  
  scheduleRestart(reason) {
    console.log(`Scheduling application restart: ${reason}`);
    // Implementation would schedule graceful restart
  }
  
  requireManualIntervention(change, impact) {
    console.log('Manual intervention required for critical configuration change');
    // Implementation would pause automatic processing
  }
  
  sendAlert(alert) {
    console.log('ALERT:', alert);
    // Implementation would send to monitoring system
  }
  
  sendApprovalNotification(approvalId, change) {
    console.log(`Approval notification sent for ${approvalId}`);
    // Implementation would send notifications
  }
  
  async start() {
    try {
      this.server = this.app.listen(this.config.port, () => {
        console.log(`Server started on port ${this.config.port}`);
      });
      
    } catch (error) {
      console.error('Failed to start server:', error);
      process.exit(1);
    }
  }
  
  async stop() {
    if (this.configLogger) {
      await this.configLogger.destroy();
    }
    
    if (this.server) {
      this.server.close();
    }
  }
}

// Usage
const app = new ConfigurableWebApp();
app.start();

// Graceful shutdown
process.on('SIGTERM', () => app.stop());
process.on('SIGINT', () => app.stop());
```

---

## Configuration Change Logging Best Practices

### **Essential Configuration Changes to Log**

1. **Environment Variables**
   - Application configuration parameters
   - Database connection strings
   - API keys and secrets (masked)
   - Feature flags
   - Performance tuning parameters

2. **Configuration Files**
   - Application config files
   - Database configuration
   - Web server configuration
   - Security policy files
   - Deployment descriptors

3. **Runtime Configuration**
   - Dynamic feature toggles
   - Cache settings
   - Rate limiting parameters
   - Timeout values
   - Circuit breaker thresholds

### **Security Considerations**

1. **Data Protection**
   - Mask or encrypt sensitive values
   - Use secure storage for change history
   - Implement access controls
   - Audit configuration access

2. **Change Authorization**
   - Implement approval workflows
   - Track change initiators
   - Validate change permissions
   - Maintain audit trails

### **Production Implementation**

1. **Change Validation**
   - Syntax validation
   - Business rule validation
   - Security policy compliance
   - Impact assessment

2. **Monitoring & Alerting**
   - Real-time change detection
   - High-impact change alerts
   - Configuration drift monitoring
   - Compliance violation alerts

**Next Section**: Ready to continue with **3.1.3 User Authentication/Authorization** - tracking security-related events and access patterns!
