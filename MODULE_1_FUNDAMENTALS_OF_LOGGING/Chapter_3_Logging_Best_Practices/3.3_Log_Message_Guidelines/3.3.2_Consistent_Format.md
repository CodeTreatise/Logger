# 3.3.2 Consistent Format

## Overview

Consistent log formatting is crucial for effective log analysis, automated processing, and team collaboration. When every component of your application follows the same formatting standards, it becomes significantly easier to search, filter, aggregate, and analyze logs across different services, environments, and time periods. This section provides comprehensive strategies for establishing and maintaining consistent log formats that scale from simple applications to complex distributed systems.

## Importance of Format Consistency

### Operational Benefits
- **Unified Search**: Consistent field names and structures enable effective searching across all logs
- **Automated Processing**: Standardized formats allow log analysis tools to parse and process logs reliably
- **Pattern Recognition**: Consistent patterns make it easier to identify anomalies and trends
- **Team Efficiency**: Developers can quickly understand logs from any part of the system
- **Tool Integration**: Monitoring and alerting tools work more effectively with consistent formats

### Technical Advantages
- **Parser Efficiency**: Single parser configurations can handle all log entries
- **Index Optimization**: Database and search engines can optimize storage and retrieval
- **Correlation Accuracy**: Consistent correlation IDs and timestamps enable precise tracing
- **Aggregation Reliability**: Metrics and statistics calculations are more accurate
- **Migration Simplicity**: Moving between logging platforms becomes straightforward

## Log Format Standardization System

### Advanced Format Management Framework

```javascript
const winston = require('winston');
const moment = require('moment-timezone');
const crypto = require('crypto');

/**
 * Comprehensive Log Format Standardization System
 * Provides enterprise-grade format consistency, validation, and enforcement
 */
class LogFormatStandardizer {
    constructor(options = {}) {
        this.config = {
            // Format standards
            timestampFormat: options.timestampFormat || 'ISO8601',
            timezone: options.timezone || 'UTC',
            defaultEncoding: options.defaultEncoding || 'utf8',
            
            // Field standardization
            enforceFieldNames: options.enforceFieldNames !== false,
            requireMandatoryFields: options.requireMandatoryFields !== false,
            allowCustomFields: options.allowCustomFields !== false,
            fieldNamingConvention: options.fieldNamingConvention || 'camelCase', // 'camelCase', 'snake_case', 'kebab-case'
            
            // Message structure
            messageFormat: options.messageFormat || 'structured', // 'structured', 'plain', 'hybrid'
            includeStackTrace: options.includeStackTrace !== false,
            includeMetadata: options.includeMetadata !== false,
            
            // Content standards
            maxMessageLength: options.maxMessageLength || 1000,
            trimWhitespace: options.trimWhitespace !== false,
            normalizeLineBreaks: options.normalizeLineBreaks !== false,
            escapeSpecialChars: options.escapeSpecialChars !== false,
            
            // Correlation standards
            correlationIdField: options.correlationIdField || 'correlationId',
            traceIdField: options.traceIdField || 'traceId',
            spanIdField: options.spanIdField || 'spanId',
            
            // Validation settings
            enableValidation: options.enableValidation !== false,
            strictMode: options.strictMode || false,
            allowUnknownFields: options.allowUnknownFields !== false,
            
            // Performance settings
            enableCaching: options.enableCaching !== false,
            cacheSize: options.cacheSize || 1000,
            
            // Organization settings
            applicationName: options.applicationName || 'unknown',
            serviceName: options.serviceName || 'unknown',
            environment: options.environment || process.env.NODE_ENV || 'development',
            version: options.version || '1.0.0'
        };
        
        this.formatSchema = this._initializeFormatSchema();
        this.fieldValidators = this._initializeFieldValidators();
        this.formatCache = new Map();
        this.namingConverter = new NamingConventionConverter(this.config.fieldNamingConvention);
        this.correlationManager = new CorrelationManager(this.config);
        this.metrics = this._initializeMetrics();
    }
    
    /**
     * Standardize a log entry according to defined format rules
     */
    standardizeLogEntry(logInfo, context = {}) {
        const startTime = Date.now();
        
        try {
            // Create base standardized entry
            const standardized = this._createBaseEntry(logInfo, context);
            
            // Apply field name standardization
            const normalizedFields = this._normalizeFieldNames(standardized);
            
            // Validate against schema
            const validationResult = this._validateFormat(normalizedFields);
            
            if (!validationResult.isValid && this.config.strictMode) {
                throw new Error(`Format validation failed: ${validationResult.errors.join(', ')}`);
            }
            
            // Apply content standardization
            const contentStandardized = this._standardizeContent(normalizedFields);
            
            // Add correlation information
            const correlationEnriched = this._enrichWithCorrelation(contentStandardized, context);
            
            // Add organizational metadata
            const organizationEnriched = this._addOrganizationalMetadata(correlationEnriched);
            
            // Apply final formatting
            const finalFormatted = this._applyFinalFormatting(organizationEnriched);
            
            // Record metrics
            this._recordStandardizationMetrics(startTime, validationResult);
            
            return {
                log: finalFormatted,
                metadata: {
                    standardized: true,
                    validation: validationResult,
                    processingTime: Date.now() - startTime,
                    formatVersion: this.config.version
                }
            };
            
        } catch (error) {
            this._handleStandardizationError(error, logInfo);
            
            // Return original with error metadata in non-strict mode
            if (!this.config.strictMode) {
                return {
                    log: logInfo,
                    metadata: {
                        standardized: false,
                        error: error.message,
                        original: true
                    }
                };
            }
            
            throw error;
        }
    }
    
    /**
     * Create base standardized log entry structure
     */
    _createBaseEntry(logInfo, context) {
        const timestamp = this._standardizeTimestamp(logInfo.timestamp || new Date());
        
        const baseEntry = {
            // Core fields (always present)
            timestamp,
            level: this._standardizeLevel(logInfo.level),
            message: this._standardizeMessage(logInfo.message),
            
            // Context fields (when available)
            logger: logInfo.logger || context.logger || 'default',
            
            // Metadata container
            metadata: {},
            
            // Error information (when applicable)
            ...(logInfo.error && { error: this._standardizeError(logInfo.error) }),
            
            // Performance information (when available)
            ...(logInfo.duration && { duration: this._standardizeDuration(logInfo.duration) }),
            
            // User context (when available)
            ...(context.userId && { userId: context.userId }),
            ...(context.sessionId && { sessionId: context.sessionId }),
            
            // Request context (when available)
            ...(context.requestId && { requestId: context.requestId }),
            ...(context.method && { httpMethod: context.method }),
            ...(context.path && { httpPath: context.path }),
            ...(context.statusCode && { httpStatusCode: context.statusCode }),
            
            // Additional metadata
            ...this._extractAdditionalMetadata(logInfo, context)
        };
        
        return baseEntry;
    }
    
    /**
     * Standardize timestamp format
     */
    _standardizeTimestamp(timestamp) {
        const momentObj = moment(timestamp).utc();
        
        switch (this.config.timestampFormat) {
            case 'ISO8601':
                return momentObj.toISOString();
            case 'RFC3339':
                return momentObj.format('YYYY-MM-DDTHH:mm:ss.SSSZ');
            case 'UNIX':
                return momentObj.unix();
            case 'UNIX_MS':
                return momentObj.valueOf();
            case 'HUMAN':
                return momentObj.format('YYYY-MM-DD HH:mm:ss.SSS UTC');
            default:
                return momentObj.toISOString();
        }
    }
    
    /**
     * Standardize log level
     */
    _standardizeLevel(level) {
        if (!level) return 'info';
        
        const normalizedLevel = level.toLowerCase().trim();
        
        // Map common level variations to standard levels
        const levelMappings = {
            'trace': 'debug',
            'verbose': 'debug',
            'information': 'info',
            'warning': 'warn',
            'err': 'error',
            'failure': 'error',
            'critical': 'error',
            'fatal': 'error',
            'emergency': 'error',
            'alert': 'error'
        };
        
        return levelMappings[normalizedLevel] || normalizedLevel;
    }
    
    /**
     * Standardize message content
     */
    _standardizeMessage(message) {
        if (!message) return '';
        
        let standardized = String(message);
        
        // Trim whitespace
        if (this.config.trimWhitespace) {
            standardized = standardized.trim();
        }
        
        // Normalize line breaks
        if (this.config.normalizeLineBreaks) {
            standardized = standardized.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        }
        
        // Escape special characters
        if (this.config.escapeSpecialChars) {
            standardized = standardized
                .replace(/\t/g, '\\t')
                .replace(/\b/g, '\\b')
                .replace(/\f/g, '\\f')
                .replace(/\v/g, '\\v');
        }
        
        // Enforce maximum length
        if (standardized.length > this.config.maxMessageLength) {
            const truncated = standardized.substring(0, this.config.maxMessageLength - 3) + '...';
            return truncated;
        }
        
        return standardized;
    }
    
    /**
     * Standardize error information
     */
    _standardizeError(error) {
        if (!error) return null;
        
        const standardizedError = {
            name: error.name || 'Error',
            message: error.message || 'Unknown error',
            code: error.code || null,
            statusCode: error.statusCode || error.status || null
        };
        
        // Include stack trace if enabled
        if (this.config.includeStackTrace && error.stack) {
            standardizedError.stack = error.stack
                .split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
        }
        
        // Include additional error properties
        const additionalProps = ['errno', 'syscall', 'hostname', 'address', 'port'];
        additionalProps.forEach(prop => {
            if (error[prop] !== undefined) {
                standardizedError[prop] = error[prop];
            }
        });
        
        return standardizedError;
    }
    
    /**
     * Standardize duration information
     */
    _standardizeDuration(duration) {
        if (typeof duration === 'number') {
            return {
                ms: duration,
                human: this._formatDurationHuman(duration)
            };
        }
        
        if (typeof duration === 'string') {
            const parsed = parseFloat(duration);
            if (!isNaN(parsed)) {
                return {
                    ms: parsed,
                    human: this._formatDurationHuman(parsed)
                };
            }
        }
        
        return { raw: duration };
    }
    
    /**
     * Format duration in human-readable form
     */
    _formatDurationHuman(ms) {
        if (ms < 1000) return `${ms}ms`;
        if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
        if (ms < 3600000) return `${(ms / 60000).toFixed(2)}m`;
        return `${(ms / 3600000).toFixed(2)}h`;
    }
    
    /**
     * Extract additional metadata from log info and context
     */
    _extractAdditionalMetadata(logInfo, context) {
        const metadata = {};
        
        // Extract from logInfo (excluding already processed fields)
        const excludedFields = ['timestamp', 'level', 'message', 'logger', 'error', 'duration'];
        Object.keys(logInfo).forEach(key => {
            if (!excludedFields.includes(key)) {
                metadata[key] = logInfo[key];
            }
        });
        
        // Extract from context (excluding already processed fields)
        const excludedContextFields = ['userId', 'sessionId', 'requestId', 'method', 'path', 'statusCode', 'logger'];
        Object.keys(context).forEach(key => {
            if (!excludedContextFields.includes(key)) {
                metadata[key] = context[key];
            }
        });
        
        return Object.keys(metadata).length > 0 ? { metadata } : {};
    }
    
    /**
     * Normalize field names according to naming convention
     */
    _normalizeFieldNames(entry) {
        if (!this.config.enforceFieldNames) return entry;
        
        return this.namingConverter.convertObject(entry);
    }
    
    /**
     * Validate log format against schema
     */
    _validateFormat(entry) {
        const validation = {
            isValid: true,
            errors: [],
            warnings: []
        };
        
        if (!this.config.enableValidation) {
            return validation;
        }
        
        // Validate mandatory fields
        if (this.config.requireMandatoryFields) {
            const mandatoryFields = ['timestamp', 'level', 'message'];
            mandatoryFields.forEach(field => {
                if (!entry[field]) {
                    validation.errors.push(`Missing mandatory field: ${field}`);
                    validation.isValid = false;
                }
            });
        }
        
        // Validate field types
        this._validateFieldTypes(entry, validation);
        
        // Validate unknown fields
        if (!this.config.allowUnknownFields) {
            this._validateUnknownFields(entry, validation);
        }
        
        // Validate field naming convention
        this._validateNamingConvention(entry, validation);
        
        return validation;
    }
    
    /**
     * Validate field types
     */
    _validateFieldTypes(entry, validation) {
        const typeValidations = {
            timestamp: 'string',
            level: 'string',
            message: 'string',
            logger: 'string',
            duration: 'object',
            userId: 'string',
            sessionId: 'string',
            requestId: 'string',
            httpMethod: 'string',
            httpPath: 'string',
            httpStatusCode: 'number'
        };
        
        Object.entries(typeValidations).forEach(([field, expectedType]) => {
            if (entry[field] !== undefined) {
                const actualType = Array.isArray(entry[field]) ? 'array' : typeof entry[field];
                if (actualType !== expectedType) {
                    validation.warnings.push(
                        `Field '${field}' expected type '${expectedType}' but got '${actualType}'`
                    );
                }
            }
        });
    }
    
    /**
     * Validate unknown fields
     */
    _validateUnknownFields(entry, validation) {
        const knownFields = new Set([
            'timestamp', 'level', 'message', 'logger', 'error', 'duration',
            'userId', 'sessionId', 'requestId', 'httpMethod', 'httpPath', 
            'httpStatusCode', 'metadata', 'correlationId', 'traceId', 'spanId',
            'application', 'service', 'environment', 'version', 'hostname', 'pid'
        ]);
        
        Object.keys(entry).forEach(field => {
            if (!knownFields.has(field)) {
                validation.warnings.push(`Unknown field: ${field}`);
            }
        });
    }
    
    /**
     * Validate naming convention
     */
    _validateNamingConvention(entry, validation) {
        const convention = this.config.fieldNamingConvention;
        
        Object.keys(entry).forEach(field => {
            if (!this.namingConverter.isValidName(field, convention)) {
                validation.warnings.push(
                    `Field '${field}' does not follow ${convention} naming convention`
                );
            }
        });
    }
    
    /**
     * Standardize content format
     */
    _standardizeContent(entry) {
        const standardized = { ...entry };
        
        // Ensure all string fields are properly encoded
        if (this.config.defaultEncoding === 'utf8') {
            this._ensureUtf8Encoding(standardized);
        }
        
        // Standardize nested objects
        if (standardized.metadata && typeof standardized.metadata === 'object') {
            standardized.metadata = this._standardizeNestedObject(standardized.metadata);
        }
        
        if (standardized.error && typeof standardized.error === 'object') {
            standardized.error = this._standardizeNestedObject(standardized.error);
        }
        
        return standardized;
    }
    
    /**
     * Ensure UTF-8 encoding for all string fields
     */
    _ensureUtf8Encoding(obj) {
        Object.keys(obj).forEach(key => {
            if (typeof obj[key] === 'string') {
                // Ensure proper UTF-8 encoding
                obj[key] = Buffer.from(obj[key], 'utf8').toString('utf8');
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                this._ensureUtf8Encoding(obj[key]);
            }
        });
    }
    
    /**
     * Standardize nested objects
     */
    _standardizeNestedObject(obj, depth = 0) {
        if (depth > 5) return '[Max Depth Exceeded]'; // Prevent infinite recursion
        
        if (Array.isArray(obj)) {
            return obj.map(item => 
                typeof item === 'object' ? this._standardizeNestedObject(item, depth + 1) : item
            );
        }
        
        if (typeof obj === 'object' && obj !== null) {
            const standardized = {};
            Object.entries(obj).forEach(([key, value]) => {
                const standardizedKey = this.namingConverter.convertName(key);
                if (typeof value === 'object' && value !== null) {
                    standardized[standardizedKey] = this._standardizeNestedObject(value, depth + 1);
                } else {
                    standardized[standardizedKey] = value;
                }
            });
            return standardized;
        }
        
        return obj;
    }
    
    /**
     * Enrich with correlation information
     */
    _enrichWithCorrelation(entry, context) {
        return this.correlationManager.enrichWithCorrelation(entry, context);
    }
    
    /**
     * Add organizational metadata
     */
    _addOrganizationalMetadata(entry) {
        const organizational = {
            application: this.config.applicationName,
            service: this.config.serviceName,
            environment: this.config.environment,
            version: this.config.version,
            hostname: require('os').hostname(),
            pid: process.pid
        };
        
        return { ...entry, ...organizational };
    }
    
    /**
     * Apply final formatting based on message format preference
     */
    _applyFinalFormatting(entry) {
        switch (this.config.messageFormat) {
            case 'structured':
                return this._applyStructuredFormat(entry);
            case 'plain':
                return this._applyPlainFormat(entry);
            case 'hybrid':
                return this._applyHybridFormat(entry);
            default:
                return entry;
        }
    }
    
    /**
     * Apply structured format (full JSON structure)
     */
    _applyStructuredFormat(entry) {
        return entry; // Already in structured format
    }
    
    /**
     * Apply plain format (message-focused)
     */
    _applyPlainFormat(entry) {
        const { timestamp, level, message, ...metadata } = entry;
        
        return {
            timestamp,
            level,
            message,
            ...(Object.keys(metadata).length > 0 && { _metadata: metadata })
        };
    }
    
    /**
     * Apply hybrid format (structured with readable message)
     */
    _applyHybridFormat(entry) {
        const readable = this._createReadableMessage(entry);
        
        return {
            ...entry,
            readableMessage: readable
        };
    }
    
    /**
     * Create human-readable message from structured data
     */
    _createReadableMessage(entry) {
        const parts = [entry.message];
        
        if (entry.httpMethod && entry.httpPath) {
            parts.push(`[${entry.httpMethod} ${entry.httpPath}]`);
        }
        
        if (entry.userId) {
            parts.push(`(user: ${entry.userId})`);
        }
        
        if (entry.duration && entry.duration.human) {
            parts.push(`(${entry.duration.human})`);
        }
        
        if (entry.error) {
            parts.push(`- ${entry.error.name}: ${entry.error.message}`);
        }
        
        return parts.join(' ');
    }
    
    /**
     * Initialize format schema
     */
    _initializeFormatSchema() {
        return {
            version: '1.0.0',
            fields: {
                mandatory: ['timestamp', 'level', 'message'],
                optional: [
                    'logger', 'error', 'duration', 'userId', 'sessionId', 
                    'requestId', 'httpMethod', 'httpPath', 'httpStatusCode',
                    'correlationId', 'traceId', 'spanId', 'metadata',
                    'application', 'service', 'environment', 'version', 'hostname', 'pid'
                ],
                types: {
                    timestamp: 'string',
                    level: 'string',
                    message: 'string',
                    logger: 'string',
                    error: 'object',
                    duration: 'object',
                    httpStatusCode: 'number'
                }
            }
        };
    }
    
    /**
     * Initialize field validators
     */
    _initializeFieldValidators() {
        return {
            timestamp: (value) => this._isValidTimestamp(value),
            level: (value) => ['debug', 'info', 'warn', 'error'].includes(value.toLowerCase()),
            message: (value) => typeof value === 'string' && value.length > 0,
            httpStatusCode: (value) => Number.isInteger(value) && value >= 100 && value < 600
        };
    }
    
    /**
     * Validate timestamp format
     */
    _isValidTimestamp(value) {
        return moment(value).isValid();
    }
    
    /**
     * Record standardization metrics
     */
    _recordStandardizationMetrics(startTime, validation) {
        this.metrics.totalStandardizations++;
        this.metrics.processingTime += Date.now() - startTime;
        
        if (validation.isValid) {
            this.metrics.validEntries++;
        } else {
            this.metrics.invalidEntries++;
        }
        
        this.metrics.totalErrors += validation.errors.length;
        this.metrics.totalWarnings += validation.warnings.length;
    }
    
    /**
     * Handle standardization errors
     */
    _handleStandardizationError(error, originalLog) {
        this.metrics.processingErrors++;
        
        console.error('Log standardization error:', {
            error: error.message,
            originalLog: JSON.stringify(originalLog).substring(0, 200),
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Initialize metrics tracking
     */
    _initializeMetrics() {
        return {
            totalStandardizations: 0,
            validEntries: 0,
            invalidEntries: 0,
            processingErrors: 0,
            processingTime: 0,
            totalErrors: 0,
            totalWarnings: 0,
            startTime: Date.now()
        };
    }
    
    /**
     * Get standardization statistics
     */
    getStatistics() {
        const total = this.metrics.totalStandardizations;
        const avgProcessingTime = total > 0 ? this.metrics.processingTime / total : 0;
        
        return {
            totalProcessed: total,
            validEntries: this.metrics.validEntries,
            invalidEntries: this.metrics.invalidEntries,
            validationRate: total > 0 ? `${(this.metrics.validEntries / total * 100).toFixed(2)}%` : '0%',
            averageProcessingTime: `${avgProcessingTime.toFixed(2)}ms`,
            totalErrors: this.metrics.totalErrors,
            totalWarnings: this.metrics.totalWarnings,
            processingErrors: this.metrics.processingErrors,
            uptime: `${Math.round((Date.now() - this.metrics.startTime) / 1000)}s`,
            formatVersion: this.config.version
        };
    }
}

/**
 * Naming Convention Converter for field standardization
 */
class NamingConventionConverter {
    constructor(convention = 'camelCase') {
        this.convention = convention;
        this.conversionCache = new Map();
    }
    
    convertName(name) {
        if (this.conversionCache.has(name)) {
            return this.conversionCache.get(name);
        }
        
        let converted;
        
        switch (this.convention) {
            case 'camelCase':
                converted = this._toCamelCase(name);
                break;
            case 'snake_case':
                converted = this._toSnakeCase(name);
                break;
            case 'kebab-case':
                converted = this._toKebabCase(name);
                break;
            case 'PascalCase':
                converted = this._toPascalCase(name);
                break;
            default:
                converted = name;
        }
        
        this.conversionCache.set(name, converted);
        return converted;
    }
    
    convertObject(obj) {
        if (Array.isArray(obj)) {
            return obj.map(item => typeof item === 'object' ? this.convertObject(item) : item);
        }
        
        if (typeof obj === 'object' && obj !== null) {
            const converted = {};
            Object.entries(obj).forEach(([key, value]) => {
                const convertedKey = this.convertName(key);
                converted[convertedKey] = typeof value === 'object' ? this.convertObject(value) : value;
            });
            return converted;
        }
        
        return obj;
    }
    
    isValidName(name, convention = this.convention) {
        switch (convention) {
            case 'camelCase':
                return /^[a-z][a-zA-Z0-9]*$/.test(name);
            case 'snake_case':
                return /^[a-z][a-z0-9_]*$/.test(name);
            case 'kebab-case':
                return /^[a-z][a-z0-9-]*$/.test(name);
            case 'PascalCase':
                return /^[A-Z][a-zA-Z0-9]*$/.test(name);
            default:
                return true;
        }
    }
    
    _toCamelCase(str) {
        return str.replace(/[-_\s]+(.)?/g, (_, char) => char ? char.toUpperCase() : '');
    }
    
    _toSnakeCase(str) {
        return str.replace(/([a-z])([A-Z])/g, '$1_$2')
                  .replace(/[-\s]+/g, '_')
                  .toLowerCase();
    }
    
    _toKebabCase(str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2')
                  .replace(/[_\s]+/g, '-')
                  .toLowerCase();
    }
    
    _toPascalCase(str) {
        return this._toCamelCase(str).replace(/^./, char => char.toUpperCase());
    }
}

/**
 * Correlation Manager for distributed tracing
 */
class CorrelationManager {
    constructor(config) {
        this.config = config;
    }
    
    enrichWithCorrelation(entry, context) {
        const enriched = { ...entry };
        
        // Add correlation ID
        enriched[this.config.correlationIdField] = 
            context.correlationId || 
            entry[this.config.correlationIdField] || 
            this._generateCorrelationId();
        
        // Add trace ID
        if (context.traceId || entry[this.config.traceIdField]) {
            enriched[this.config.traceIdField] = 
                context.traceId || entry[this.config.traceIdField];
        }
        
        // Add span ID
        if (context.spanId || entry[this.config.spanIdField]) {
            enriched[this.config.spanIdField] = 
                context.spanId || entry[this.config.spanIdField];
        }
        
        return enriched;
    }
    
    _generateCorrelationId() {
        return crypto.randomBytes(16).toString('hex');
    }
}

module.exports = {
    LogFormatStandardizer,
    NamingConventionConverter,
    CorrelationManager
};
```

### Winston Integration for Consistent Formatting

```javascript
const winston = require('winston');
const { LogFormatStandardizer } = require('./LogFormatStandardizer');

/**
 * Consistent format for Winston logger
 */
const consistentFormat = (standardizer) => {
    return winston.format((info) => {
        try {
            const context = {
                correlationId: info.correlationId,
                traceId: info.traceId,
                spanId: info.spanId,
                userId: info.userId,
                sessionId: info.sessionId,
                requestId: info.requestId,
                method: info.httpMethod,
                path: info.httpPath,
                statusCode: info.httpStatusCode
            };
            
            const standardized = standardizer.standardizeLogEntry(info, context);
            
            // Replace info with standardized log
            Object.keys(info).forEach(key => delete info[key]);
            Object.assign(info, standardized.log);
            
            // Add standardization metadata
            info._standardization = standardized.metadata;
            
            return info;
            
        } catch (error) {
            // Fallback to original format if standardization fails
            info._standardizationError = error.message;
            return info;
        }
    })();
};

/**
 * Create logger with consistent formatting
 */
function createConsistentLogger(options = {}) {
    const standardizer = new LogFormatStandardizer({
        applicationName: options.applicationName || 'my-app',
        serviceName: options.serviceName || 'main-service',
        environment: options.environment || process.env.NODE_ENV || 'development',
        version: options.version || '1.0.0',
        timestampFormat: options.timestampFormat || 'ISO8601',
        fieldNamingConvention: options.fieldNamingConvention || 'camelCase',
        messageFormat: options.messageFormat || 'structured',
        ...options.formatConfig
    });
    
    const logger = winston.createLogger({
        level: options.level || 'info',
        format: winston.format.combine(
            winston.format.timestamp(),
            consistentFormat(standardizer),
            winston.format.json()
        ),
        transports: [
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.timestamp(),
                    winston.format.printf(({ timestamp, level, message, ...meta }) => {
                        // Clean display format
                        const cleanMeta = { ...meta };
                        delete cleanMeta._standardization;
                        delete cleanMeta._standardizationError;
                        
                        const metaStr = Object.keys(cleanMeta).length ? 
                            JSON.stringify(cleanMeta, null, 2) : '';
                        return `${timestamp} [${level}]: ${message} ${metaStr}`;
                    })
                )
            }),
            new winston.transports.File({
                filename: 'logs/consistent-format.log',
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            })
        ]
    });
    
    // Add standardization methods
    logger.getFormatStats = () => standardizer.getStatistics();
    logger.validateFormat = (entry) => standardizer._validateFormat(entry);
    
    return logger;
}

module.exports = { createConsistentLogger, LogFormatStandardizer };
```

### Express.js Integration with Format Standards

```javascript
const express = require('express');
const { createConsistentLogger } = require('./consistent-logger');
const { v4: uuidv4 } = require('uuid');

const app = express();
const logger = createConsistentLogger({
    applicationName: 'e-commerce-api',
    serviceName: 'order-service',
    environment: process.env.NODE_ENV,
    version: process.env.APP_VERSION || '1.0.0',
    fieldNamingConvention: 'camelCase',
    messageFormat: 'structured'
});

/**
 * Consistent logging middleware
 */
function consistentLoggingMiddleware() {
    return (req, res, next) => {
        // Generate correlation ID for request tracking
        req.correlationId = req.headers['x-correlation-id'] || uuidv4();
        req.requestId = req.headers['x-request-id'] || uuidv4();
        req.startTime = Date.now();
        
        // Set correlation ID in response headers
        res.setHeader('X-Correlation-ID', req.correlationId);
        res.setHeader('X-Request-ID', req.requestId);
        
        // Log request with consistent format
        logger.info('HTTP request received', {
            httpMethod: req.method,
            httpPath: req.path,
            httpQuery: req.query,
            httpHeaders: {
                userAgent: req.get('User-Agent'),
                contentType: req.get('Content-Type'),
                accept: req.get('Accept')
            },
            clientIp: req.ip,
            correlationId: req.correlationId,
            requestId: req.requestId,
            userId: req.user?.id,
            sessionId: req.sessionID,
            operation: 'http_request_processing',
            stage: 'received'
        });
        
        // Override res.end to log response
        const originalEnd = res.end;
        res.end = function(chunk, encoding) {
            const duration = Date.now() - req.startTime;
            
            logger.info('HTTP request completed', {
                httpMethod: req.method,
                httpPath: req.path,
                httpStatusCode: res.statusCode,
                httpHeaders: {
                    contentType: res.get('Content-Type'),
                    contentLength: res.get('Content-Length')
                },
                correlationId: req.correlationId,
                requestId: req.requestId,
                userId: req.user?.id,
                sessionId: req.sessionID,
                duration: {
                    ms: duration,
                    human: duration < 1000 ? `${duration}ms` : `${(duration/1000).toFixed(2)}s`
                },
                operation: 'http_request_processing',
                stage: 'completed',
                outcome: res.statusCode >= 400 ? 'error' : 'success'
            });
            
            return originalEnd.call(this, chunk, encoding);
        };
        
        next();
    };
}

/**
 * Consistent error logging middleware
 */
function consistentErrorMiddleware() {
    return (err, req, res, next) => {
        const duration = Date.now() - req.startTime;
        
        logger.error('HTTP request failed with unhandled error', {
            httpMethod: req.method,
            httpPath: req.path,
            httpStatusCode: err.statusCode || 500,
            error: {
                name: err.name,
                message: err.message,
                code: err.code,
                statusCode: err.statusCode || err.status,
                stack: err.stack?.split('\n').map(line => line.trim())
            },
            correlationId: req.correlationId,
            requestId: req.requestId,
            userId: req.user?.id,
            sessionId: req.sessionID,
            duration: {
                ms: duration,
                human: duration < 1000 ? `${duration}ms` : `${(duration/1000).toFixed(2)}s`
            },
            operation: 'http_request_processing',
            stage: 'error_handling',
            outcome: 'error'
        });
        
        next(err);
    };
}

/**
 * Consistent logging utilities with standardized formats
 */
const consistentLog = {
    // Business operation logging
    businessOperation: {
        start: (operationType, entityId, context = {}) => {
            logger.info(`Business operation ${operationType} initiated`, {
                operation: operationType,
                entityId,
                entityType: context.entityType,
                userId: context.userId,
                correlationId: context.correlationId,
                requestId: context.requestId,
                stage: 'initiation',
                outcome: 'started',
                metadata: {
                    initiatedBy: context.initiatedBy,
                    reason: context.reason,
                    priority: context.priority
                }
            });
        },
        
        complete: (operationType, entityId, context = {}) => {
            logger.info(`Business operation ${operationType} completed successfully`, {
                operation: operationType,
                entityId,
                entityType: context.entityType,
                userId: context.userId,
                correlationId: context.correlationId,
                requestId: context.requestId,
                duration: context.duration,
                stage: 'completion',
                outcome: 'success',
                metadata: {
                    completedBy: context.completedBy,
                    changesCount: context.changesCount,
                    affectedRecords: context.affectedRecords
                }
            });
        },
        
        fail: (operationType, entityId, error, context = {}) => {
            logger.error(`Business operation ${operationType} failed`, {
                operation: operationType,
                entityId,
                entityType: context.entityType,
                error: {
                    name: error.name,
                    message: error.message,
                    code: error.code,
                    statusCode: error.statusCode
                },
                userId: context.userId,
                correlationId: context.correlationId,
                requestId: context.requestId,
                duration: context.duration,
                stage: 'error_handling',
                outcome: 'failure',
                metadata: {
                    retryAttempt: context.retryAttempt,
                    maxRetries: context.maxRetries,
                    rollbackRequired: context.rollbackRequired
                }
            });
        }
    },
    
    // Database operation logging
    database: {
        query: (queryType, table, duration, result, context = {}) => {
            logger.info(`Database ${queryType} operation completed`, {
                operation: `database_${queryType}`,
                targetTable: table,
                targetDatabase: context.database,
                executionDuration: {
                    ms: duration,
                    human: duration < 1000 ? `${duration}ms` : `${(duration/1000).toFixed(2)}s`
                },
                result: {
                    rowsAffected: result.rowsAffected,
                    recordsReturned: result.recordsReturned,
                    insertId: result.insertId
                },
                correlationId: context.correlationId,
                requestId: context.requestId,
                userId: context.userId,
                stage: 'execution',
                outcome: 'success',
                metadata: {
                    queryPlan: context.queryPlan,
                    indexesUsed: context.indexesUsed,
                    cacheHit: context.cacheHit
                }
            });
        },
        
        error: (queryType, table, error, duration, context = {}) => {
            logger.error(`Database ${queryType} operation failed`, {
                operation: `database_${queryType}`,
                targetTable: table,
                targetDatabase: context.database,
                error: {
                    name: error.name,
                    message: error.message,
                    code: error.code,
                    sqlState: error.sqlState,
                    errno: error.errno
                },
                executionDuration: {
                    ms: duration,
                    human: duration < 1000 ? `${duration}ms` : `${(duration/1000).toFixed(2)}s`
                },
                correlationId: context.correlationId,
                requestId: context.requestId,
                userId: context.userId,
                stage: 'error_handling',
                outcome: 'failure',
                metadata: {
                    retryAttempt: context.retryAttempt,
                    connectionId: context.connectionId,
                    transactionId: context.transactionId
                }
            });
        }
    },
    
    // External service logging
    externalService: {
        call: (serviceName, endpoint, method, duration, statusCode, context = {}) => {
            const outcome = statusCode >= 200 && statusCode < 300 ? 'success' : 'failure';
            const level = outcome === 'success' ? 'info' : 'warn';
            
            logger[level](`External service call to ${serviceName} ${outcome}`, {
                operation: 'external_service_call',
                serviceName,
                serviceEndpoint: endpoint,
                httpMethod: method,
                httpStatusCode: statusCode,
                callDuration: {
                    ms: duration,
                    human: duration < 1000 ? `${duration}ms` : `${(duration/1000).toFixed(2)}s`
                },
                correlationId: context.correlationId,
                requestId: context.requestId,
                userId: context.userId,
                stage: 'external_communication',
                outcome,
                metadata: {
                    requestSize: context.requestSize,
                    responseSize: context.responseSize,
                    retryAttempt: context.retryAttempt,
                    circuitBreakerState: context.circuitBreakerState
                }
            });
        }
    },
    
    // Security event logging
    security: {
        authAttempt: (userId, method, outcome, context = {}) => {
            const level = outcome === 'success' ? 'info' : 'warn';
            
            logger[level](`Authentication attempt ${outcome}`, {
                operation: 'user_authentication',
                userId,
                authMethod: method,
                clientIp: context.clientIp,
                userAgent: context.userAgent,
                correlationId: context.correlationId,
                requestId: context.requestId,
                stage: 'authentication',
                outcome,
                metadata: {
                    attemptNumber: context.attemptNumber,
                    maxAttempts: context.maxAttempts,
                    accountLocked: context.accountLocked,
                    mfaRequired: context.mfaRequired
                }
            });
        },
        
        accessViolation: (userId, resource, action, context = {}) => {
            logger.error('Access violation detected', {
                operation: 'access_control_violation',
                userId,
                targetResource: resource,
                attemptedAction: action,
                clientIp: context.clientIp,
                userAgent: context.userAgent,
                correlationId: context.correlationId,
                requestId: context.requestId,
                stage: 'authorization',
                outcome: 'violation',
                metadata: {
                    userRole: context.userRole,
                    requiredPermission: context.requiredPermission,
                    riskScore: context.riskScore,
                    alertTriggered: context.alertTriggered
                }
            });
        }
    }
};

// Apply middleware
app.use(express.json());
app.use(consistentLoggingMiddleware());

// Example route using consistent logging
app.post('/api/orders', async (req, res) => {
    const startTime = Date.now();
    const operationType = 'order_creation';
    
    try {
        // Log operation start
        consistentLog.businessOperation.start(operationType, null, {
            entityType: 'order',
            userId: req.user?.id,
            correlationId: req.correlationId,
            requestId: req.requestId,
            initiatedBy: 'api_request',
            priority: 'normal'
        });
        
        // Simulate order creation
        const order = await createOrder(req.body, {
            correlationId: req.correlationId,
            requestId: req.requestId,
            userId: req.user?.id
        });
        
        const duration = Date.now() - startTime;
        
        // Log operation completion
        consistentLog.businessOperation.complete(operationType, order.id, {
            entityType: 'order',
            userId: req.user?.id,
            correlationId: req.correlationId,
            requestId: req.requestId,
            duration: { ms: duration },
            completedBy: 'order_service',
            affectedRecords: 1
        });
        
        res.status(201).json({
            success: true,
            order,
            correlationId: req.correlationId
        });
        
    } catch (error) {
        const duration = Date.now() - startTime;
        
        // Log operation failure
        consistentLog.businessOperation.fail(operationType, null, error, {
            entityType: 'order',
            userId: req.user?.id,
            correlationId: req.correlationId,
            requestId: req.requestId,
            duration: { ms: duration },
            retryAttempt: 1,
            maxRetries: 3
        });
        
        res.status(500).json({
            success: false,
            error: 'Order creation failed',
            correlationId: req.correlationId
        });
    }
});

// Format statistics endpoint
app.get('/admin/logging/format-stats', (req, res) => {
    const stats = logger.getFormatStats();
    
    logger.info('Format statistics requested', {
        operation: 'admin_stats_request',
        statsType: 'format_consistency',
        correlationId: req.correlationId,
        requestId: req.requestId,
        userId: req.user?.id,
        stage: 'data_retrieval',
        outcome: 'success'
    });
    
    res.json({
        success: true,
        statistics: stats,
        correlationId: req.correlationId
    });
});

// Apply error middleware last
app.use(consistentErrorMiddleware());

async function createOrder(orderData, context) {
    const dbStartTime = Date.now();
    
    try {
        // Simulate database operation
        await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
        
        const order = {
            id: Date.now().toString(),
            ...orderData,
            createdAt: new Date().toISOString(),
            status: 'pending'
        };
        
        const duration = Date.now() - dbStartTime;
        
        // Log database operation
        consistentLog.database.query('insert', 'orders', duration, {
            rowsAffected: 1,
            insertId: order.id
        }, context);
        
        return order;
        
    } catch (error) {
        const duration = Date.now() - dbStartTime;
        
        // Log database error
        consistentLog.database.error('insert', 'orders', error, duration, context);
        
        throw error;
    }
}

module.exports = { app, consistentLog };
```

## Format Consistency Standards

### ✅ **DO: Consistency Best Practices**
- **Standardize field names**: Use consistent naming conventions (camelCase, snake_case, etc.)
- **Normalize timestamps**: Always use the same timestamp format (ISO8601 recommended)
- **Structure messages**: Maintain consistent message structure across all log entries
- **Validate formats**: Implement format validation to catch inconsistencies early
- **Document standards**: Create and maintain format documentation for your team

### ❌ **DON'T: Format Inconsistency Pitfalls**
- **Mixed naming conventions**: Don't use both camelCase and snake_case in the same system
- **Varying timestamp formats**: Avoid mixing different date/time representations
- **Inconsistent field presence**: Don't have some logs with `userId` and others with `user_id`
- **Arbitrary structures**: Avoid ad-hoc log structures without standardization
- **Ignoring validation**: Don't skip format validation in production

### 🎯 **Standard Log Structure Template**
```json
{
  "timestamp": "2025-08-19T10:30:45.123Z",
  "level": "info",
  "message": "User authentication successful",
  "correlationId": "abc123-def456-ghi789",
  "requestId": "req-789-456-123",
  "operation": "user_authentication",
  "outcome": "success",
  "userId": "user123",
  "httpMethod": "POST",
  "httpPath": "/api/auth/login",
  "httpStatusCode": 200,
  "duration": {
    "ms": 45,
    "human": "45ms"
  },
  "application": "e-commerce-api",
  "service": "auth-service",
  "environment": "production",
  "version": "1.2.3",
  "hostname": "api-server-01",
  "pid": 12345
}
```

### 📊 **Format Benefits**
- **Unified Processing**: Single parser handles all logs
- **Efficient Search**: Consistent field names enable precise queries
- **Reliable Correlation**: Standardized correlation IDs link related events
- **Automated Analysis**: Tools can process logs without custom configuration
- **Team Productivity**: Developers understand any log entry immediately

Consistent formatting transforms chaotic log streams into structured, searchable, and actionable information that drives effective observability and debugging.
