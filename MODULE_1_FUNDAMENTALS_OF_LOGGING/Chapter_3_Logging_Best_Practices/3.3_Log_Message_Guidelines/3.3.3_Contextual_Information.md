# 3.3.3 Contextual Information

## Overview

Contextual information is the difference between logs that simply record events and logs that tell the complete story of what happened in your system. Rich context transforms individual log entries into powerful diagnostic tools that enable rapid troubleshooting, effective monitoring, and deep system understanding. This section provides comprehensive strategies for identifying, capturing, and managing contextual information that makes your logs truly valuable for operations, debugging, and business intelligence.

## Understanding Context Layers

### Application Context
- **Service Identity**: Which service, module, or component generated the log
- **Version Information**: Software version, build number, deployment timestamp
- **Environment Details**: Development, staging, production, and their specific configurations
- **Resource Information**: Memory usage, CPU load, disk space, network conditions

### Request Context
- **Request Lifecycle**: Correlation IDs, request IDs, trace IDs for distributed tracking
- **HTTP Details**: Method, path, headers, query parameters, response codes
- **Timing Information**: Request start time, processing duration, external call latencies
- **Client Information**: IP address, user agent, geographic location, device type

### User Context
- **Identity Information**: User ID, email, role, permissions, organization
- **Session Details**: Session ID, authentication method, login time, session state
- **Behavioral Context**: Previous actions, navigation path, feature usage patterns
- **Personalization**: User preferences, language, timezone, accessibility settings

### Business Context
- **Transaction Information**: Order ID, payment ID, invoice number, transaction type
- **Entity Relationships**: Customer ID, product ID, campaign ID, tenant ID
- **Business Metrics**: Transaction value, quantity, category, priority level
- **Workflow State**: Process step, approval status, completion percentage

## Advanced Context Management System

### Intelligent Context Collector

```javascript
const os = require('os');
const crypto = require('crypto');
const winston = require('winston');

/**
 * Comprehensive Context Management System
 * Provides intelligent context collection, enrichment, and propagation
 */
class ContextualInformationManager {
    constructor(options = {}) {
        this.config = {
            // Context collection settings
            enableAutoCollection: options.enableAutoCollection !== false,
            collectSystemMetrics: options.collectSystemMetrics !== false,
            collectPerformanceMetrics: options.collectPerformanceMetrics !== false,
            
            // Context depth and scope
            maxContextDepth: options.maxContextDepth || 5,
            contextScope: options.contextScope || 'full', // 'minimal', 'standard', 'full', 'comprehensive'
            
            // Context sources
            enableRequestContext: options.enableRequestContext !== false,
            enableUserContext: options.enableUserContext !== false,
            enableBusinessContext: options.enableBusinessContext !== false,
            enableSystemContext: options.enableSystemContext !== false,
            enableEnvironmentContext: options.enableEnvironmentContext !== false,
            
            // Context propagation
            enableContextPropagation: options.enableContextPropagation !== false,
            contextPropagationHeaders: options.contextPropagationHeaders || [
                'x-correlation-id', 'x-request-id', 'x-trace-id', 'x-span-id',
                'x-user-id', 'x-session-id', 'x-tenant-id'
            ],
            
            // Context storage and caching
            enableContextCaching: options.enableContextCaching !== false,
            contextCacheSize: options.contextCacheSize || 1000,
            contextCacheTTL: options.contextCacheTTL || 300000, // 5 minutes
            
            // Context filtering and privacy
            enableContextFiltering: options.enableContextFiltering !== false,
            sensitiveFields: options.sensitiveFields || [
                'password', 'token', 'secret', 'key', 'credit', 'ssn', 'email'
            ],
            
            // Performance settings
            enableAsyncCollection: options.enableAsyncCollection !== false,
            collectionTimeout: options.collectionTimeout || 100, // ms
            
            // Application metadata
            applicationName: options.applicationName || 'unknown',
            serviceName: options.serviceName || 'unknown',
            serviceVersion: options.serviceVersion || '1.0.0',
            environment: options.environment || process.env.NODE_ENV || 'development'
        };
        
        this.contextCollectors = this._initializeContextCollectors();
        this.contextCache = new Map();
        this.contextPropagator = new ContextPropagator(this.config);
        this.contextFilter = new ContextFilter(this.config);
        this.performanceCollector = new PerformanceContextCollector(this.config);
        this.businessContextExtractor = new BusinessContextExtractor(this.config);
        this.metrics = this._initializeMetrics();
        
        // Initialize base context
        this.baseContext = this._collectBaseContext();
    }
    
    /**
     * Collect comprehensive context for a log entry
     */
    async collectContext(logInfo, additionalContext = {}) {
        const startTime = Date.now();
        
        try {
            const context = {
                // Start with base application context
                ...this.baseContext,
                
                // Add provided additional context
                ...additionalContext
            };
            
            // Collect context from various sources based on configuration
            if (this.config.enableRequestContext) {
                Object.assign(context, await this._collectRequestContext(logInfo, additionalContext));
            }
            
            if (this.config.enableUserContext) {
                Object.assign(context, await this._collectUserContext(logInfo, additionalContext));
            }
            
            if (this.config.enableBusinessContext) {
                Object.assign(context, await this._collectBusinessContext(logInfo, additionalContext));
            }
            
            if (this.config.enableSystemContext) {
                Object.assign(context, await this._collectSystemContext(logInfo, additionalContext));
            }
            
            if (this.config.enableEnvironmentContext) {
                Object.assign(context, await this._collectEnvironmentContext(logInfo, additionalContext));
            }
            
            // Apply context propagation
            if (this.config.enableContextPropagation) {
                Object.assign(context, this.contextPropagator.extractPropagatedContext(additionalContext));
            }
            
            // Filter sensitive information
            const filteredContext = this.config.enableContextFiltering ? 
                this.contextFilter.filterSensitiveData(context) : context;
            
            // Apply scope-based filtering
            const scopedContext = this._applyScopeFiltering(filteredContext);
            
            // Record collection metrics
            this._recordCollectionMetrics(startTime, Object.keys(scopedContext).length);
            
            return scopedContext;
            
        } catch (error) {
            this._handleCollectionError(error, logInfo);
            
            // Return minimal context on error
            return {
                ...this.baseContext,
                contextCollectionError: error.message,
                contextCollectionTime: Date.now() - startTime
            };
        }
    }
    
    /**
     * Collect base application context (static information)
     */
    _collectBaseContext() {
        return {
            // Application identification
            application: {
                name: this.config.applicationName,
                service: this.config.serviceName,
                version: this.config.serviceVersion,
                environment: this.config.environment,
                deployment: {
                    hostname: os.hostname(),
                    platform: os.platform(),
                    architecture: os.arch(),
                    nodeVersion: process.version,
                    pid: process.pid,
                    uptime: process.uptime()
                }
            },
            
            // Timestamp information
            timestamp: {
                iso: new Date().toISOString(),
                unix: Math.floor(Date.now() / 1000),
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            }
        };
    }
    
    /**
     * Collect request-specific context
     */
    async _collectRequestContext(logInfo, additionalContext) {
        const requestContext = {};
        
        // HTTP request information
        if (additionalContext.req || additionalContext.request) {
            const req = additionalContext.req || additionalContext.request;
            
            requestContext.request = {
                id: req.id || req.headers?.[&#x27;x-request-id&#x27;] || this._generateId(),
                method: req.method,
                url: req.url || req.originalUrl,
                path: req.path || req.route?.path,
                headers: this._sanitizeHeaders(req.headers),
                query: req.query,
                params: req.params,
                ip: req.ip || req.connection?.remoteAddress,
                userAgent: req.headers?.[&#x27;user-agent&#x27;],
                referer: req.headers?.[&#x27;referer&#x27;],
                contentType: req.headers?.[&#x27;content-type&#x27;],
                contentLength: req.headers?.[&#x27;content-length&#x27;],
                acceptLanguage: req.headers?.[&#x27;accept-language&#x27;],
                startTime: req.startTime || Date.now()
            };
            
            // Add body information (carefully)
            if (req.body && this._isSafeToLogBody(req.body)) {
                requestContext.request.bodySize = JSON.stringify(req.body).length;
                requestContext.request.bodyType = typeof req.body;
            }
        }
        
        // Response information
        if (additionalContext.res || additionalContext.response) {
            const res = additionalContext.res || additionalContext.response;
            
            requestContext.response = {
                statusCode: res.statusCode,
                statusMessage: res.statusMessage,
                headers: this._sanitizeHeaders(res.getHeaders?.() || {}),
                contentType: res.getHeader?.(&#x27;content-type&#x27;),
                contentLength: res.getHeader?.(&#x27;content-length&#x27;),
                responseTime: res.responseTime || (req?.startTime ? Date.now() - req.startTime : undefined)
            };
        }
        
        // Correlation and tracing
        requestContext.correlation = {
            correlationId: additionalContext.correlationId || 
                          additionalContext.req?.correlationId || 
                          this._generateId(),
            traceId: additionalContext.traceId || 
                    additionalContext.req?.traceId,
            spanId: additionalContext.spanId || 
                   additionalContext.req?.spanId,
            parentSpanId: additionalContext.parentSpanId
        };
        
        return requestContext;
    }
    
    /**
     * Collect user-specific context
     */
    async _collectUserContext(logInfo, additionalContext) {
        const userContext = {};
        
        // User identification
        const user = additionalContext.user || additionalContext.req?.user;
        if (user) {
            userContext.user = {
                id: user.id || user._id || user.userId,
                email: user.email ? this._maskEmail(user.email) : undefined,
                username: user.username,
                role: user.role || user.roles,
                permissions: user.permissions,
                organizationId: user.organizationId || user.tenantId,
                lastLoginAt: user.lastLoginAt,
                accountStatus: user.status || user.accountStatus,
                preferences: {
                    language: user.language || user.locale,
                    timezone: user.timezone,
                    theme: user.theme
                }
            };
        }
        
        // Session information
        const session = additionalContext.session || additionalContext.req?.session;
        if (session) {
            userContext.session = {
                id: session.id || session.sessionId,
                startTime: session.startTime || session.createdAt,
                lastActivity: session.lastActivity || session.touch,
                isAuthenticated: session.isAuthenticated || !!session.userId,
                authMethod: session.authMethod,
                ipAddress: session.ipAddress,
                userAgent: session.userAgent,
                deviceInfo: session.deviceInfo
            };
        }
        
        // Authentication context
        if (additionalContext.auth || additionalContext.authentication) {
            const auth = additionalContext.auth || additionalContext.authentication;
            
            userContext.authentication = {
                method: auth.method,
                provider: auth.provider,
                tokenType: auth.tokenType,
                tokenExpiresAt: auth.expiresAt,
                scopes: auth.scopes,
                mfaEnabled: auth.mfaEnabled,
                lastAuthAt: auth.lastAuthAt
            };
        }
        
        return userContext;
    }
    
    /**
     * Collect business-specific context
     */
    async _collectBusinessContext(logInfo, additionalContext) {
        return this.businessContextExtractor.extractBusinessContext(logInfo, additionalContext);
    }
    
    /**
     * Collect system-specific context
     */
    async _collectSystemContext(logInfo, additionalContext) {
        if (!this.config.collectSystemMetrics) {
            return {};
        }
        
        const systemContext = {};
        
        // System resources
        systemContext.system = {
            memory: {
                total: os.totalmem(),
                free: os.freemem(),
                used: os.totalmem() - os.freemem(),
                usagePercent: ((os.totalmem() - os.freemem()) / os.totalmem() * 100).toFixed(2)
            },
            cpu: {
                cores: os.cpus().length,
                loadAverage: os.loadavg(),
                architecture: os.arch(),
                platform: os.platform()
            },
            process: {
                pid: process.pid,
                ppid: process.ppid,
                uptime: process.uptime(),
                memory: process.memoryUsage(),
                cpuUsage: process.cpuUsage(),
                version: process.version,
                title: process.title
            }
        };
        
        // Network information
        const networkInterfaces = os.networkInterfaces();
        systemContext.network = {
            hostname: os.hostname(),
            interfaces: Object.keys(networkInterfaces).reduce((acc, name) => {
                acc[name] = networkInterfaces[name]
                    .filter(iface => !iface.internal)
                    .map(iface => ({
                        address: iface.address,
                        family: iface.family,
                        mac: iface.mac
                    }));
                return acc;
            }, {})
        };
        
        return systemContext;
    }
    
    /**
     * Collect environment-specific context
     */
    async _collectEnvironmentContext(logInfo, additionalContext) {
        const envContext = {};
        
        // Environment variables (filtered)
        const safeEnvVars = [
            &#x27;NODE_ENV&#x27;, &#x27;PORT&#x27;, &#x27;HOST&#x27;, &#x27;LOG_LEVEL&#x27;, &#x27;DEBUG&#x27;,
            &#x27;ENVIRONMENT&#x27;, &#x27;REGION&#x27;, &#x27;ZONE&#x27;, &#x27;CLUSTER&#x27;, &#x27;NAMESPACE&#x27;
        ];
        
        envContext.environment = {
            variables: safeEnvVars.reduce((acc, key) => {
                if (process.env[key]) {
                    acc[key] = process.env[key];
                }
                return acc;
            }, {}),
            workingDirectory: process.cwd(),
            execPath: process.execPath,
            argv: process.argv.slice(2) // Exclude node path and script name
        };
        
        // Container/Cloud context
        if (process.env.KUBERNETES_SERVICE_HOST) {
            envContext.kubernetes = {
                namespace: process.env.KUBERNETES_NAMESPACE,
                podName: process.env.HOSTNAME,
                serviceName: process.env.KUBERNETES_SERVICE_NAME,
                serviceHost: process.env.KUBERNETES_SERVICE_HOST
            };
        }
        
        if (process.env.AWS_REGION) {
            envContext.aws = {
                region: process.env.AWS_REGION,
                availabilityZone: process.env.AWS_AVAILABILITY_ZONE,
                instanceId: process.env.AWS_INSTANCE_ID,
                executionEnv: process.env.AWS_EXECUTION_ENV
            };
        }
        
        if (process.env.DOCKER_CONTAINER) {
            envContext.docker = {
                containerId: process.env.HOSTNAME,
                imageName: process.env.DOCKER_IMAGE,
                imageTag: process.env.DOCKER_TAG
            };
        }
        
        return envContext;
    }
    
    /**
     * Sanitize HTTP headers for logging
     */
    _sanitizeHeaders(headers) {
        if (!headers) return {};
        
        const sanitized = {};
        const sensitiveHeaders = [
            &#x27;authorization&#x27;, &#x27;cookie&#x27;, &#x27;set-cookie&#x27;, &#x27;x-api-key&#x27;,
            &#x27;x-auth-token&#x27;, &#x27;x-session-token&#x27;, &#x27;x-csrf-token&#x27;
        ];
        
        Object.entries(headers).forEach(([key, value]) => {
            const lowerKey = key.toLowerCase();
            if (sensitiveHeaders.includes(lowerKey)) {
                sanitized[key] = &#x27;[REDACTED]&#x27;;
            } else if (lowerKey === &#x27;user-agent&#x27; && value) {
                // Truncate long user agent strings
                sanitized[key] = value.length > 200 ? value.substring(0, 200) + &#x27;...&#x27; : value;
            } else {
                sanitized[key] = value;
            }
        });
        
        return sanitized;
    }
    
    /**
     * Check if request body is safe to log
     */
    _isSafeToLogBody(body) {
        if (!body) return false;
        
        const bodyStr = JSON.stringify(body).toLowerCase();
        const sensitiveKeywords = [
            &#x27;password&#x27;, &#x27;secret&#x27;, &#x27;token&#x27;, &#x27;key&#x27;, &#x27;credit&#x27;, &#x27;ssn&#x27;, &#x27;card&#x27;
        ];
        
        return !sensitiveKeywords.some(keyword => bodyStr.includes(keyword));
    }
    
    /**
     * Mask email for privacy
     */
    _maskEmail(email) {
        if (!email || typeof email !== &#x27;string&#x27;) return email;
        
        const [local, domain] = email.split(&#x27;@&#x27;);
        if (!domain) return email;
        
        const maskedLocal = local.length > 2 ? 
            local[0] + &#x27;*&#x27;.repeat(local.length - 2) + local[local.length - 1] :
            &#x27;*&#x27;.repeat(local.length);
            
        return `${maskedLocal}@${domain}`;
    }
    
    /**
     * Apply scope-based filtering
     */
    _applyScopeFiltering(context) {
        switch (this.config.contextScope) {
            case &#x27;minimal&#x27;:
                return this._extractMinimalContext(context);
            case &#x27;standard&#x27;:
                return this._extractStandardContext(context);
            case &#x27;full&#x27;:
                return this._extractFullContext(context);
            case &#x27;comprehensive&#x27;:
                return context; // Return everything
            default:
                return this._extractStandardContext(context);
        }
    }
    
    /**
     * Extract minimal context (performance-focused)
     */
    _extractMinimalContext(context) {
        return {
            application: context.application ? {
                name: context.application.name,
                service: context.application.service,
                environment: context.application.environment
            } : undefined,
            correlation: context.correlation,
            user: context.user ? {
                id: context.user.id,
                role: context.user.role
            } : undefined,
            request: context.request ? {
                id: context.request.id,
                method: context.request.method,
                path: context.request.path,
                ip: context.request.ip
            } : undefined
        };
    }
    
    /**
     * Extract standard context (balanced)
     */
    _extractStandardContext(context) {
        const minimal = this._extractMinimalContext(context);
        
        return {
            ...minimal,
            timestamp: context.timestamp,
            session: context.session ? {
                id: context.session.id,
                isAuthenticated: context.session.isAuthenticated
            } : undefined,
            request: context.request ? {
                ...minimal.request,
                userAgent: context.request.userAgent,
                responseTime: context.request.responseTime
            } : undefined,
            response: context.response ? {
                statusCode: context.response.statusCode,
                responseTime: context.response.responseTime
            } : undefined
        };
    }
    
    /**
     * Extract full context (comprehensive but filtered)
     */
    _extractFullContext(context) {
        const { system, ...filteredContext } = context;
        
        // Include system context but limit depth
        if (system) {
            filteredContext.system = {
                memory: system.memory ? {
                    usagePercent: system.memory.usagePercent
                } : undefined,
                process: system.process ? {
                    pid: system.process.pid,
                    uptime: system.process.uptime,
                    memory: system.process.memory
                } : undefined
            };
        }
        
        return filteredContext;
    }
    
    /**
     * Generate unique identifier
     */
    _generateId() {
        return crypto.randomBytes(8).toString(&#x27;hex&#x27;);
    }
    
    /**
     * Initialize context collectors
     */
    _initializeContextCollectors() {
        return {
            request: this._collectRequestContext.bind(this),
            user: this._collectUserContext.bind(this),
            business: this._collectBusinessContext.bind(this),
            system: this._collectSystemContext.bind(this),
            environment: this._collectEnvironmentContext.bind(this)
        };
    }
    
    /**
     * Record collection metrics
     */
    _recordCollectionMetrics(startTime, contextFieldCount) {
        this.metrics.totalCollections++;
        this.metrics.collectionTime += Date.now() - startTime;
        this.metrics.totalContextFields += contextFieldCount;
        
        const avgCollectionTime = this.metrics.collectionTime / this.metrics.totalCollections;
        if (avgCollectionTime > this.config.collectionTimeout) {
            this.metrics.slowCollections++;
        }
    }
    
    /**
     * Handle collection errors
     */
    _handleCollectionError(error, logInfo) {
        this.metrics.collectionErrors++;
        
        console.error(&#x27;Context collection error:&#x27;, {
            error: error.message,
            logLevel: logInfo.level,
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Initialize metrics tracking
     */
    _initializeMetrics() {
        return {
            totalCollections: 0,
            collectionTime: 0,
            totalContextFields: 0,
            slowCollections: 0,
            collectionErrors: 0,
            startTime: Date.now()
        };
    }
    
    /**
     * Get collection statistics
     */
    getStatistics() {
        const avgCollectionTime = this.metrics.totalCollections > 0 ?
            this.metrics.collectionTime / this.metrics.totalCollections : 0;
        
        const avgContextFields = this.metrics.totalCollections > 0 ?
            this.metrics.totalContextFields / this.metrics.totalCollections : 0;
        
        return {
            totalCollections: this.metrics.totalCollections,
            averageCollectionTime: `${avgCollectionTime.toFixed(2)}ms`,
            averageContextFields: avgContextFields.toFixed(1),
            slowCollections: this.metrics.slowCollections,
            collectionErrors: this.metrics.collectionErrors,
            uptime: `${Math.round((Date.now() - this.metrics.startTime) / 1000)}s`,
            scope: this.config.contextScope,
            enabledSources: [
                this.config.enableRequestContext && &#x27;request&#x27;,
                this.config.enableUserContext && &#x27;user&#x27;,
                this.config.enableBusinessContext && &#x27;business&#x27;,
                this.config.enableSystemContext && &#x27;system&#x27;,
                this.config.enableEnvironmentContext && &#x27;environment&#x27;
            ].filter(Boolean)
        };
    }
}

/**
 * Context Propagator for distributed systems
 */
class ContextPropagator {
    constructor(config) {
        this.config = config;
        this.propagationHeaders = config.contextPropagationHeaders;
    }
    
    extractPropagatedContext(additionalContext) {
        const propagatedContext = {};
        
        // Extract from headers if available
        const headers = additionalContext.req?.headers || additionalContext.headers || {};
        
        this.propagationHeaders.forEach(header => {
            const value = headers[header] || headers[header.toLowerCase()];
            if (value) {
                const contextKey = this._headerToContextKey(header);
                propagatedContext[contextKey] = value;
            }
        });
        
        return { propagated: propagatedContext };
    }
    
    createPropagationHeaders(context) {
        const headers = {};
        
        if (context.correlation?.correlationId) {
            headers[&#x27;x-correlation-id&#x27;] = context.correlation.correlationId;
        }
        
        if (context.correlation?.traceId) {
            headers[&#x27;x-trace-id&#x27;] = context.correlation.traceId;
        }
        
        if (context.user?.id) {
            headers[&#x27;x-user-id&#x27;] = context.user.id;
        }
        
        if (context.session?.id) {
            headers[&#x27;x-session-id&#x27;] = context.session.id;
        }
        
        return headers;
    }
    
    _headerToContextKey(header) {
        return header.replace(/^x-/, &#x27;&#x27;).replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
    }
}

/**
 * Context Filter for sensitive data protection
 */
class ContextFilter {
    constructor(config) {
        this.config = config;
        this.sensitiveFields = new Set(config.sensitiveFields);
    }
    
    filterSensitiveData(context) {
        return this._filterObject(context);
    }
    
    _filterObject(obj, depth = 0) {
        if (depth > this.config.maxContextDepth) {
            return &#x27;[MAX_DEPTH_EXCEEDED]&#x27;;
        }
        
        if (Array.isArray(obj)) {
            return obj.map(item => this._filterObject(item, depth + 1));
        }
        
        if (typeof obj === &#x27;object&#x27; && obj !== null) {
            const filtered = {};
            
            Object.entries(obj).forEach(([key, value]) => {
                if (this._isSensitiveField(key)) {
                    filtered[key] = &#x27;[REDACTED]&#x27;;
                } else if (typeof value === &#x27;object&#x27;) {
                    filtered[key] = this._filterObject(value, depth + 1);
                } else {
                    filtered[key] = value;
                }
            });
            
            return filtered;
        }
        
        return obj;
    }
    
    _isSensitiveField(fieldName) {
        const lowerField = fieldName.toLowerCase();
        return Array.from(this.sensitiveFields).some(sensitive => 
            lowerField.includes(sensitive.toLowerCase())
        );
    }
}

/**
 * Performance Context Collector
 */
class PerformanceContextCollector {
    constructor(config) {
        this.config = config;
        this.performanceMarks = new Map();
    }
    
    markStart(operation, context = {}) {
        const markId = `${operation}-${Date.now()}-${Math.random()}`;
        this.performanceMarks.set(markId, {
            operation,
            startTime: Date.now(),
            startMemory: process.memoryUsage(),
            context
        });
        return markId;
    }
    
    markEnd(markId) {
        const mark = this.performanceMarks.get(markId);
        if (!mark) return null;
        
        const endTime = Date.now();
        const endMemory = process.memoryUsage();
        
        const performance = {
            operation: mark.operation,
            duration: {
                ms: endTime - mark.startTime,
                human: this._formatDuration(endTime - mark.startTime)
            },
            memory: {
                heapUsedDelta: endMemory.heapUsed - mark.startMemory.heapUsed,
                heapTotalDelta: endMemory.heapTotal - mark.startMemory.heapTotal,
                rss: endMemory.rss,
                external: endMemory.external
            },
            timing: {
                startTime: mark.startTime,
                endTime: endTime
            }
        };
        
        this.performanceMarks.delete(markId);
        return performance;
    }
    
    _formatDuration(ms) {
        if (ms < 1000) return `${ms}ms`;
        if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
        return `${(ms / 60000).toFixed(2)}m`;
    }
}

/**
 * Business Context Extractor
 */
class BusinessContextExtractor {
    constructor(config) {
        this.config = config;
        this.businessRules = this._initializeBusinessRules();
    }
    
    extractBusinessContext(logInfo, additionalContext) {
        const businessContext = {};
        
        // Extract entity information
        if (additionalContext.entityId || additionalContext.entity) {
            businessContext.entity = {
                id: additionalContext.entityId || additionalContext.entity?.id,
                type: additionalContext.entityType || additionalContext.entity?.type,
                name: additionalContext.entityName || additionalContext.entity?.name,
                status: additionalContext.entityStatus || additionalContext.entity?.status
            };
        }
        
        // Extract transaction information
        if (additionalContext.transactionId || additionalContext.transaction) {
            businessContext.transaction = {
                id: additionalContext.transactionId || additionalContext.transaction?.id,
                type: additionalContext.transactionType || additionalContext.transaction?.type,
                amount: additionalContext.amount || additionalContext.transaction?.amount,
                currency: additionalContext.currency || additionalContext.transaction?.currency,
                status: additionalContext.transactionStatus || additionalContext.transaction?.status
            };
        }
        
        // Extract workflow information
        if (additionalContext.workflowId || additionalContext.workflow) {
            businessContext.workflow = {
                id: additionalContext.workflowId || additionalContext.workflow?.id,
                step: additionalContext.workflowStep || additionalContext.workflow?.step,
                status: additionalContext.workflowStatus || additionalContext.workflow?.status,
                progress: additionalContext.workflowProgress || additionalContext.workflow?.progress
            };
        }
        
        // Extract tenant/organization information
        if (additionalContext.tenantId || additionalContext.organizationId) {
            businessContext.tenant = {
                id: additionalContext.tenantId || additionalContext.organizationId,
                name: additionalContext.tenantName || additionalContext.organizationName,
                plan: additionalContext.tenantPlan || additionalContext.plan,
                region: additionalContext.tenantRegion || additionalContext.region
            };
        }
        
        return businessContext;
    }
    
    _initializeBusinessRules() {
        return {
            // Define business-specific extraction rules
            orderProcessing: {
                requiredFields: [&#x27;orderId&#x27;, &#x27;customerId&#x27;, &#x27;orderStatus&#x27;],
                optionalFields: [&#x27;orderValue&#x27;, &#x27;paymentMethod&#x27;, &#x27;shippingAddress&#x27;]
            },
            userManagement: {
                requiredFields: [&#x27;userId&#x27;, &#x27;action&#x27;],
                optionalFields: [&#x27;role&#x27;, &#x27;permissions&#x27;, &#x27;organizationId&#x27;]
            },
            paymentProcessing: {
                requiredFields: [&#x27;transactionId&#x27;, &#x27;amount&#x27;, &#x27;currency&#x27;],
                optionalFields: [&#x27;paymentMethod&#x27;, &#x27;merchantId&#x27;, &#x27;gatewayResponse&#x27;]
            }
        };
    }
}

module.exports = {
    ContextualInformationManager,
    ContextPropagator,
    ContextFilter,
    PerformanceContextCollector,
    BusinessContextExtractor
};
```

### Winston Integration for Contextual Logging

```javascript
const winston = require(&#x27;winston&#x27;);
const { ContextualInformationManager } = require(&#x27;./ContextualInformationManager&#x27;);

/**
 * Contextual format for Winston logger
 */
const contextualFormat = (contextManager) =&gt; {
    return winston.format((info) =&gt; {
        // Extract context from info object
        const additionalContext = {
            req: info.req,
            res: info.res,
            user: info.user,
            session: info.session,
            correlationId: info.correlationId,
            traceId: info.traceId,
            spanId: info.spanId,
            entityId: info.entityId,
            entityType: info.entityType,
            transactionId: info.transactionId,
            workflowId: info.workflowId,
            tenantId: info.tenantId
        };
        
        // Collect context asynchronously (will be resolved in transport)
        info._contextPromise = contextManager.collectContext(info, additionalContext);
        
        return info;
    })();
};

/**
 * Async context resolver format
 */
const asyncContextFormat = () =&gt; {
    return winston.format((info) =&gt; {
        if (info._contextPromise) {
            // For synchronous transports, we need to resolve context immediately
            // In production, consider using async transports or context pre-collection
            try {
                // Note: This is a simplified synchronous approach
                // Real implementation should handle async context collection properly
                delete info._contextPromise;
            } catch (error) {
                info.contextError = error.message;
            }
        }
        
        return info;
    })();
};

/**
 * Create logger with contextual information
 */
function createContextualLogger(options = {}) {
    const contextManager = new ContextualInformationManager({
        applicationName: options.applicationName || &#x27;my-app&#x27;,
        serviceName: options.serviceName || &#x27;main-service&#x27;,
        serviceVersion: options.serviceVersion || &#x27;1.0.0&#x27;,
        environment: options.environment || process.env.NODE_ENV || &#x27;development&#x27;,
        contextScope: options.contextScope || &#x27;standard&#x27;,
        enableRequestContext: options.enableRequestContext !== false,
        enableUserContext: options.enableUserContext !== false,
        enableBusinessContext: options.enableBusinessContext !== false,
        enableSystemContext: options.enableSystemContext !== false,
        ...options.contextConfig
    });
    
    const logger = winston.createLogger({
        level: options.level || &#x27;info&#x27;,
        format: winston.format.combine(
            winston.format.timestamp(),
            contextualFormat(contextManager),
            asyncContextFormat(),
            winston.format.json()
        ),
        transports: [
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.timestamp(),
                    winston.format.printf(({ timestamp, level, message, ...meta }) =&gt; {
                        // Extract key context for console display
                        const keyContext = [];
                        
                        if (meta.correlation?.correlationId) {
                            keyContext.push(`corr:${meta.correlation.correlationId.slice(-8)}`);
                        }
                        
                        if (meta.user?.id) {
                            keyContext.push(`user:${meta.user.id}`);
                        }
                        
                        if (meta.request?.method &amp;&amp; meta.request?.path) {
                            keyContext.push(`${meta.request.method} ${meta.request.path}`);
                        }
                        
                        const contextStr = keyContext.length &gt; 0 ? ` [${keyContext.join(&#x27;, &#x27;)}]` : &#x27;&#x27;;
                        return `${timestamp} [${level}]: ${message}${contextStr}`;
                    })
                )
            }),
            new winston.transports.File({
                filename: &#x27;logs/contextual.log&#x27;,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                )
            })
        ]
    });
    
    // Add context management methods
    logger.getContextStats = () =&gt; contextManager.getStatistics();
    logger.createPerformanceMark = (operation, context) =&gt; 
        contextManager.performanceCollector.markStart(operation, context);
    logger.endPerformanceMark = (markId) =&gt; 
        contextManager.performanceCollector.markEnd(markId);
    
    return logger;
}

module.exports = { createContextualLogger, ContextualInformationManager };
```

### Express.js Integration with Rich Context

```javascript
const express = require(&#x27;express&#x27;);
const { createContextualLogger } = require(&#x27;./contextual-logger&#x27;);
const { v4: uuidv4 } = require(&#x27;uuid&#x27;);

const app = express();
const logger = createContextualLogger({
    applicationName: &#x27;e-commerce-platform&#x27;,
    serviceName: &#x27;order-management-service&#x27;,
    serviceVersion: &#x27;2.1.0&#x27;,
    environment: process.env.NODE_ENV,
    contextScope: &#x27;full&#x27;,
    enableSystemContext: true
});

/**
 * Context enrichment middleware
 */
function contextEnrichmentMiddleware() {
    return (req, res, next) =&gt; {
        // Initialize request context
        req.correlationId = req.headers[&#x27;x-correlation-id&#x27;] || uuidv4();
        req.requestId = req.headers[&#x27;x-request-id&#x27;] || uuidv4();
        req.traceId = req.headers[&#x27;x-trace-id&#x27;] || uuidv4();
        req.spanId = uuidv4();
        req.startTime = Date.now();
        
        // Extract tenant information
        req.tenantId = req.headers[&#x27;x-tenant-id&#x27;] || 
                      req.query.tenantId || 
                      req.user?.organizationId;
        
        // Set response headers for context propagation
        res.setHeader(&#x27;X-Correlation-ID&#x27;, req.correlationId);
        res.setHeader(&#x27;X-Request-ID&#x27;, req.requestId);
        res.setHeader(&#x27;X-Trace-ID&#x27;, req.traceId);
        
        // Create performance mark for request
        req.performanceMark = logger.createPerformanceMark(&#x27;http_request&#x27;, {
            method: req.method,
            path: req.path,
            userAgent: req.get(&#x27;User-Agent&#x27;)
        });
        
        // Log request start with full context
        logger.info(&#x27;HTTP request initiated&#x27;, {
            req,
            correlationId: req.correlationId,
            requestId: req.requestId,
            traceId: req.traceId,
            spanId: req.spanId,
            tenantId: req.tenantId,
            user: req.user,
            session: req.session,
            entityType: &#x27;http_request&#x27;,
            entityId: req.requestId,
            operation: &#x27;http_request_processing&#x27;,
            stage: &#x27;initiation&#x27;
        });
        
        // Override res.end to capture response context
        const originalEnd = res.end;
        res.end = function(chunk, encoding) {
            const performance = logger.endPerformanceMark(req.performanceMark);
            
            logger.info(&#x27;HTTP request completed&#x27;, {
                req,
                res,
                correlationId: req.correlationId,
                requestId: req.requestId,
                traceId: req.traceId,
                spanId: req.spanId,
                tenantId: req.tenantId,
                user: req.user,
                session: req.session,
                entityType: &#x27;http_request&#x27;,
                entityId: req.requestId,
                operation: &#x27;http_request_processing&#x27;,
                stage: &#x27;completion&#x27;,
                outcome: res.statusCode &gt;= 400 ? &#x27;error&#x27; : &#x27;success&#x27;,
                performance
            });
            
            return originalEnd.call(this, chunk, encoding);
        };
        
        next();
    };
}

/**
 * Business context logging utility
 */
const contextualLog = {
    // Order management logging
    order: {
        created: (order, context = {}) =&gt; {
            logger.info(&#x27;Order created successfully&#x27;, {
                entityType: &#x27;order&#x27;,
                entityId: order.id,
                entityStatus: order.status,
                operation: &#x27;order_creation&#x27;,
                stage: &#x27;completion&#x27;,
                outcome: &#x27;success&#x27;,
                transactionId: order.transactionId,
                customerId: order.customerId,
                orderValue: order.totalAmount,
                currency: order.currency,
                itemCount: order.items?.length,
                paymentMethod: order.paymentMethod,
                shippingMethod: order.shippingMethod,
                ...context
            });
        },
        
        updated: (orderId, changes, context = {}) =&gt; {
            logger.info(&#x27;Order updated&#x27;, {
                entityType: &#x27;order&#x27;,
                entityId: orderId,
                operation: &#x27;order_update&#x27;,
                stage: &#x27;completion&#x27;,
                outcome: &#x27;success&#x27;,
                changes: Object.keys(changes),
                changeCount: Object.keys(changes).length,
                ...context
            });
        },
        
        failed: (orderId, error, context = {}) =&gt; {
            logger.error(&#x27;Order processing failed&#x27;, {
                entityType: &#x27;order&#x27;,
                entityId: orderId,
                operation: &#x27;order_processing&#x27;,
                stage: &#x27;error_handling&#x27;,
                outcome: &#x27;failure&#x27;,
                error: {
                    name: error.name,
                    message: error.message,
                    code: error.code,
                    stack: error.stack?.split(&#x27;\n&#x27;).slice(0, 5)
                },
                ...context
            });
        }
    },
    
    // Payment processing logging
    payment: {
        initiated: (paymentId, amount, currency, context = {}) =&gt; {
            logger.info(&#x27;Payment processing initiated&#x27;, {
                entityType: &#x27;payment&#x27;,
                entityId: paymentId,
                operation: &#x27;payment_processing&#x27;,
                stage: &#x27;initiation&#x27;,
                outcome: &#x27;started&#x27;,
                transactionId: paymentId,
                amount,
                currency,
                ...context
            });
        },
        
        completed: (paymentId, gatewayResponse, context = {}) =&gt; {
            logger.info(&#x27;Payment processed successfully&#x27;, {
                entityType: &#x27;payment&#x27;,
                entityId: paymentId,
                operation: &#x27;payment_processing&#x27;,
                stage: &#x27;completion&#x27;,
                outcome: &#x27;success&#x27;,
                transactionId: paymentId,
                gatewayTransactionId: gatewayResponse.transactionId,
                processingTime: gatewayResponse.processingTime,
                ...context
            });
        },
        
        failed: (paymentId, error, gatewayResponse, context = {}) =&gt; {
            logger.error(&#x27;Payment processing failed&#x27;, {
                entityType: &#x27;payment&#x27;,
                entityId: paymentId,
                operation: &#x27;payment_processing&#x27;,
                stage: &#x27;error_handling&#x27;,
                outcome: &#x27;failure&#x27;,
                transactionId: paymentId,
                error: {
                    name: error.name,
                    message: error.message,
                    code: error.code,
                    gatewayError: gatewayResponse?.errorCode,
                    gatewayMessage: gatewayResponse?.errorMessage
                },
                ...context
            });
        }
    },
    
    // User activity logging
    user: {
        activity: (action, userId, details, context = {}) =&gt; {
            logger.info(`User ${action} activity`, {
                entityType: &#x27;user_activity&#x27;,
                entityId: `${userId}-${action}-${Date.now()}`,
                operation: `user_${action}`,
                stage: &#x27;completion&#x27;,
                outcome: &#x27;success&#x27;,
                userId,
                activityType: action,
                activityDetails: details,
                ...context
            });
        },
        
        loginAttempt: (userId, result, context = {}) =&gt; {
            const level = result === &#x27;success&#x27; ? &#x27;info&#x27; : &#x27;warn&#x27;;
            
            logger[level](`User login attempt ${result}`, {
                entityType: &#x27;authentication&#x27;,
                entityId: `${userId}-login-${Date.now()}`,
                operation: &#x27;user_authentication&#x27;,
                stage: &#x27;completion&#x27;,
                outcome: result,
                userId,
                authMethod: context.authMethod,
                clientInfo: {
                    ip: context.clientIp,
                    userAgent: context.userAgent,
                    location: context.location
                },
                ...context
            });
        }
    },
    
    // External service logging
    externalService: {
        call: (serviceName, operation, duration, response, context = {}) =&gt; {
            const outcome = response.success ? &#x27;success&#x27; : &#x27;failure&#x27;;
            const level = outcome === &#x27;success&#x27; ? &#x27;info&#x27; : &#x27;warn&#x27;;
            
            logger[level](`External service ${serviceName} call ${outcome}`, {
                entityType: &#x27;external_service_call&#x27;,
                entityId: `${serviceName}-${operation}-${Date.now()}`,
                operation: &#x27;external_service_communication&#x27;,
                stage: &#x27;completion&#x27;,
                outcome,
                serviceName,
                serviceOperation: operation,
                serviceResponse: {
                    statusCode: response.statusCode,
                    responseTime: duration,
                    dataSize: response.dataSize,
                    success: response.success
                },
                performance: {
                    duration: { ms: duration }
                },
                ...context
            });
        }
    }
};

// Apply middleware
app.use(express.json());
app.use(contextEnrichmentMiddleware());

// Example route with rich contextual logging
app.post(&#x27;/api/orders&#x27;, async (req, res) =&gt; {
    const operationMark = logger.createPerformanceMark(&#x27;order_creation&#x27;);
    
    try {
        // Log operation start with business context
        logger.info(&#x27;Order creation process started&#x27;, {
            req,
            correlationId: req.correlationId,
            requestId: req.requestId,
            traceId: req.traceId,
            spanId: req.spanId,
            tenantId: req.tenantId,
            user: req.user,
            operation: &#x27;order_creation&#x27;,
            stage: &#x27;initiation&#x27;,
            entityType: &#x27;order&#x27;,
            orderData: {
                itemCount: req.body.items?.length,
                estimatedValue: req.body.estimatedTotal,
                currency: req.body.currency,
                customerId: req.body.customerId
            }
        });
        
        // Create order with contextual logging
        const order = await createOrder(req.body, {
            correlationId: req.correlationId,
            requestId: req.requestId,
            traceId: req.traceId,
            tenantId: req.tenantId,
            userId: req.user?.id
        });
        
        const performance = logger.endPerformanceMark(operationMark);
        
        // Log successful creation
        contextualLog.order.created(order, {
            correlationId: req.correlationId,
            requestId: req.requestId,
            traceId: req.traceId,
            tenantId: req.tenantId,
            user: req.user,
            performance
        });
        
        res.status(201).json({
            success: true,
            order,
            context: {
                correlationId: req.correlationId,
                requestId: req.requestId
            }
        });
        
    } catch (error) {
        const performance = logger.endPerformanceMark(operationMark);
        
        // Log order creation failure
        contextualLog.order.failed(null, error, {
            correlationId: req.correlationId,
            requestId: req.requestId,
            traceId: req.traceId,
            tenantId: req.tenantId,
            user: req.user,
            performance,
            orderData: req.body
        });
        
        res.status(500).json({
            success: false,
            error: &#x27;Order creation failed&#x27;,
            context: {
                correlationId: req.correlationId,
                requestId: req.requestId
            }
        });
    }
});

// Context statistics endpoint
app.get(&#x27;/admin/logging/context-stats&#x27;, (req, res) =&gt; {
    const stats = logger.getContextStats();
    
    logger.info(&#x27;Context statistics requested&#x27;, {
        req,
        correlationId: req.correlationId,
        requestId: req.requestId,
        operation: &#x27;admin_stats_request&#x27;,
        entityType: &#x27;admin_operation&#x27;,
        statsType: &#x27;context_collection&#x27;
    });
    
    res.json({
        success: true,
        statistics: stats,
        context: {
            correlationId: req.correlationId,
            requestId: req.requestId
        }
    });
});

async function createOrder(orderData, context) {
    const dbMark = logger.createPerformanceMark(&#x27;database_order_insert&#x27;);
    
    try {
        // Simulate order creation
        await new Promise(resolve =&gt; setTimeout(resolve, Math.random() * 200));
        
        const order = {
            id: `order-${Date.now()}`,
            ...orderData,
            status: &#x27;pending&#x27;,
            createdAt: new Date().toISOString(),
            transactionId: `txn-${Date.now()}`
        };
        
        const dbPerformance = logger.endPerformanceMark(dbMark);
        
        // Log database operation
        logger.info(&#x27;Order record created in database&#x27;, {
            entityType: &#x27;database_operation&#x27;,
            entityId: order.id,
            operation: &#x27;database_insert&#x27;,
            stage: &#x27;completion&#x27;,
            outcome: &#x27;success&#x27;,
            tableName: &#x27;orders&#x27;,
            recordId: order.id,
            performance: dbPerformance,
            ...context
        });
        
        return order;
        
    } catch (error) {
        const dbPerformance = logger.endPerformanceMark(dbMark);
        
        logger.error(&#x27;Database order creation failed&#x27;, {
            entityType: &#x27;database_operation&#x27;,
            operation: &#x27;database_insert&#x27;,
            stage: &#x27;error_handling&#x27;,
            outcome: &#x27;failure&#x27;,
            tableName: &#x27;orders&#x27;,
            error: {
                name: error.name,
                message: error.message,
                code: error.code
            },
            performance: dbPerformance,
            ...context
        });
        
        throw error;
    }
}

module.exports = { app, contextualLog };
```

## Context Best Practices

###  **DO: Context Enhancement Best Practices**
- **Layer context appropriately**: Application  Request  User  Business  System
- **Use correlation IDs**: Track requests across distributed systems
- **Include performance metrics**: Duration, memory usage, resource consumption
- **Add business entities**: Order IDs, customer IDs, transaction IDs
- **Capture user journey**: Session flow, authentication state, user actions

###  **DON'T: Context Anti-patterns**
- **Over-collect context**: Avoid gathering unnecessary information that impacts performance
- **Log sensitive context**: Never include passwords, tokens, or PII in context
- **Ignore context scope**: Don't use the same context depth for all environments
- **Forget correlation**: Missing request tracking makes distributed debugging impossible
- **Hardcode context**: Make context collection configurable and environment-aware

###  **Context Categories**

#### **Essential Context (Always Include)**
- Correlation/Request/Trace IDs
- User identification (non-sensitive)
- Operation type and stage
- Timestamp and duration
- Application/service identity

#### **Extended Context (Standard Scope)**
- HTTP request/response details
- Session information
- Basic system metrics
- Business entity references
- Error details and stack traces

#### **Comprehensive Context (Full Scope)**
- Performance metrics
- Environment variables
- Resource utilization
- Detailed business state
- External service interactions

###  **Context Structure Example**
```json
{
  "application": {
    "name": "e-commerce-platform",
    "service": "order-service",
    "version": "2.1.0",
    "environment": "production"
  },
  "correlation": {
    "correlationId": "abc123-def456-ghi789",
    "traceId": "trace-789-456-123",
    "spanId": "span-123-789-456"
  },
  "user": {
    "id": "user-12345",
    "role": "customer",
    "organizationId": "org-567"
  },
  "request": {
    "id": "req-789-456-123",
    "method": "POST",
    "path": "/api/orders",
    "ip": "192.168.1.100",
    "userAgent": "Mozilla/5.0..."
  },
  "business": {
    "entity": {
      "type": "order",
      "id": "order-98765",
      "status": "processing"
    },
    "transaction": {
      "id": "txn-54321",
      "amount": 99.99,
      "currency": "USD"
    }
  },
  "performance": {
    "duration": { "ms": 245 },
    "memory": { "heapUsed": 45678912 }
  }
}
```

Rich contextual information transforms logs from isolated events into connected stories that enable rapid problem resolution and deep system understanding!
