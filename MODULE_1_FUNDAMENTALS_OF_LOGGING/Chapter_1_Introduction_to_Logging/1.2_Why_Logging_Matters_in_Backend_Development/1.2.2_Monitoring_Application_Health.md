# 1.2.2 Monitoring Application Health

## Understanding Application Health Through Logging

Application health monitoring is crucial for maintaining system reliability, and logging provides real-time insights into system behavior, performance, and potential issues before they become critical problems.

## What is Application Health?

### Key Health Indicators
- **Availability**: Is the application accessible and responding?
- **Performance**: Are response times within acceptable limits?
- **Resource Utilization**: CPU, memory, disk, and network usage
- **Error Rates**: Frequency and types of errors occurring
- **Throughput**: Request volume and processing capacity
- **Dependencies**: Health of external services and databases

### Health vs Functionality
```javascript
// Functional check - Does it work?
app.get('/api/users/:id', async (req, res) => {
  try {
    const user = await userService.getUser(req.params.id);
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'User not found' });
  }
});

// Health check - How well does it work?
app.get('/health', async (req, res) => {
  const healthCheck = {
    timestamp: new Date().toISOString(),
    status: 'healthy',
    version: process.env.APP_VERSION,
    uptime: process.uptime(),
    checks: {}
  };
  
  // Database connectivity
  try {
    await database.ping();
    healthCheck.checks.database = { status: 'healthy', responseTime: 25 };
    logger.debug('Database health check passed');
  } catch (error) {
    healthCheck.checks.database = { status: 'unhealthy', error: error.message };
    healthCheck.status = 'degraded';
    logger.warn('Database health check failed', { error: error.message });
  }
  
  // Memory usage
  const memUsage = process.memoryUsage();
  const memoryHealthy = memUsage.heapUsed / memUsage.heapTotal < 0.9;
  healthCheck.checks.memory = {
    status: memoryHealthy ? 'healthy' : 'warning',
    heapUsed: memUsage.heapUsed,
    heapTotal: memUsage.heapTotal,
    utilizationPercent: (memUsage.heapUsed / memUsage.heapTotal * 100).toFixed(2)
  };
  
  if (!memoryHealthy) {
    logger.warn('High memory usage detected', healthCheck.checks.memory);
  }
  
  res.json(healthCheck);
});
```

## Health Monitoring Through Strategic Logging

### 1. **System Resource Monitoring**
```javascript
// Resource usage logging
class SystemMonitor {
  constructor(logger) {
    this.logger = logger.child({ component: 'system-monitor' });
    this.startMonitoring();
  }
  
  startMonitoring() {
    setInterval(() => {
      this.logSystemHealth();
    }, 30000); // Every 30 seconds
  }
  
  logSystemHealth() {
    const cpuUsage = process.cpuUsage();
    const memUsage = process.memoryUsage();
    
    const healthMetrics = {
      timestamp: new Date().toISOString(),
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system
      },
      memory: {
        rss: memUsage.rss,
        heapTotal: memUsage.heapTotal,
        heapUsed: memUsage.heapUsed,
        external: memUsage.external,
        heapUtilization: (memUsage.heapUsed / memUsage.heapTotal * 100).toFixed(2)
      },
      uptime: process.uptime(),
      activeHandles: process._getActiveHandles().length,
      activeRequests: process._getActiveRequests().length
    };
    
    // Log at different levels based on thresholds
    const heapUtilization = parseFloat(healthMetrics.memory.heapUtilization);
    
    if (heapUtilization > 90) {
      this.logger.error('Critical memory usage', healthMetrics);
    } else if (heapUtilization > 75) {
      this.logger.warn('High memory usage', healthMetrics);
    } else {
      this.logger.debug('System health metrics', healthMetrics);
    }
  }
}
```

### 2. **Request/Response Health Monitoring**
```javascript
// Request health monitoring middleware
function requestHealthMonitoring(req, res, next) {
  const startTime = Date.now();
  const originalSend = res.send;
  
  res.send = function(data) {
    const duration = Date.now() - startTime;
    const healthData = {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration,
      contentLength: data ? data.length : 0,
      userAgent: req.get('User-Agent'),
      ip: req.ip
    };
    
    // Categorize health status
    if (res.statusCode >= 500) {
      logger.error('Server error response', healthData);
    } else if (res.statusCode >= 400) {
      logger.warn('Client error response', healthData);
    } else if (duration > 5000) {
      logger.warn('Slow response detected', healthData);
    } else if (duration > 1000) {
      logger.info('Response completed', healthData);
    } else {
      logger.debug('Response completed', healthData);
    }
    
    originalSend.call(this, data);
  };
  
  next();
}
```

### 3. **Database Health Monitoring**
```javascript
// Database connection health
class DatabaseHealthMonitor {
  constructor(database, logger) {
    this.database = database;
    this.logger = logger.child({ component: 'db-health' });
    this.connectionCount = 0;
    this.queryCount = 0;
    this.slowQueries = [];
  }
  
  async executeQuery(query, params) {
    const queryId = `query-${Date.now()}-${Math.random()}`;
    const startTime = Date.now();
    
    this.queryCount++;
    
    this.logger.debug('Query started', {
      queryId,
      query: this.sanitizeQuery(query),
      paramCount: params?.length || 0
    });
    
    try {
      const result = await this.database.query(query, params);
      const duration = Date.now() - startTime;
      
      const queryHealth = {
        queryId,
        duration,
        resultCount: result.rows?.length || 0,
        status: 'success'
      };
      
      if (duration > 10000) {
        this.logger.error('Extremely slow query', queryHealth);
        this.slowQueries.push({ ...queryHealth, query, timestamp: new Date() });
      } else if (duration > 1000) {
        this.logger.warn('Slow query detected', queryHealth);
      } else {
        this.logger.debug('Query completed', queryHealth);
      }
      
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      
      this.logger.error('Query failed', {
        queryId,
        duration,
        error: error.message,
        query: this.sanitizeQuery(query)
      });
      
      throw error;
    }
  }
  
  getHealthSummary() {
    return {
      totalQueries: this.queryCount,
      activeConnections: this.connectionCount,
      slowQueries: this.slowQueries.length,
      recentSlowQueries: this.slowQueries.slice(-5)
    };
  }
}
```

### 4. **External Service Health Monitoring**
```javascript
// External service dependency health
class ServiceHealthChecker {
  constructor(services, logger) {
    this.services = services;
    this.logger = logger.child({ component: 'service-health' });
    this.serviceStatus = new Map();
    this.startHealthChecks();
  }
  
  startHealthChecks() {
    // Check each service every 60 seconds
    setInterval(async () => {
      await this.checkAllServices();
    }, 60000);
  }
  
  async checkAllServices() {
    for (const [serviceName, config] of Object.entries(this.services)) {
      await this.checkService(serviceName, config);
    }
    
    this.logger.info('Service health check completed', {
      servicesChecked: Object.keys(this.services).length,
      healthyServices: Array.from(this.serviceStatus.values()).filter(s => s.healthy).length,
      unhealthyServices: Array.from(this.serviceStatus.values()).filter(s => !s.healthy).length
    });
  }
  
  async checkService(serviceName, config) {
    const startTime = Date.now();
    
    try {
      const response = await fetch(config.healthEndpoint, {
        timeout: config.timeout || 5000,
        method: 'GET'
      });
      
      const duration = Date.now() - startTime;
      const healthy = response.ok;
      
      this.serviceStatus.set(serviceName, {
        healthy,
        lastCheck: new Date(),
        responseTime: duration,
        statusCode: response.status
      });
      
      if (healthy) {
        this.logger.debug('Service health check passed', {
          service: serviceName,
          responseTime: duration,
          statusCode: response.status
        });
      } else {
        this.logger.warn('Service health check failed', {
          service: serviceName,
          responseTime: duration,
          statusCode: response.status,
          endpoint: config.healthEndpoint
        });
      }
      
    } catch (error) {
      const duration = Date.now() - startTime;
      
      this.serviceStatus.set(serviceName, {
        healthy: false,
        lastCheck: new Date(),
        responseTime: duration,
        error: error.message
      });
      
      this.logger.error('Service health check error', {
        service: serviceName,
        error: error.message,
        endpoint: config.healthEndpoint,
        responseTime: duration
      });
    }
  }
  
  getServiceHealth(serviceName) {
    return this.serviceStatus.get(serviceName) || { healthy: false, error: 'Unknown service' };
  }
}
```

## Health Metrics and KPIs

### 1. **Availability Metrics**
```javascript
// Track uptime and availability
class AvailabilityTracker {
  constructor(logger) {
    this.logger = logger.child({ component: 'availability' });
    this.startTime = Date.now();
    this.downtimeEvents = [];
    this.isHealthy = true;
  }
  
  recordDowntime(reason, severity = 'minor') {
    if (this.isHealthy) {
      this.isHealthy = false;
      const downtimeEvent = {
        startTime: Date.now(),
        reason,
        severity,
        id: `downtime-${Date.now()}`
      };
      
      this.downtimeEvents.push(downtimeEvent);
      
      this.logger.error('Service downtime started', downtimeEvent);
    }
  }
  
  recordRecovery() {
    if (!this.isHealthy && this.downtimeEvents.length > 0) {
      const lastDowntime = this.downtimeEvents[this.downtimeEvents.length - 1];
      lastDowntime.endTime = Date.now();
      lastDowntime.duration = lastDowntime.endTime - lastDowntime.startTime;
      
      this.isHealthy = true;
      
      this.logger.info('Service recovered', {
        downtimeId: lastDowntime.id,
        duration: lastDowntime.duration,
        reason: lastDowntime.reason
      });
    }
  }
  
  getAvailabilityStats() {
    const totalRuntime = Date.now() - this.startTime;
    const totalDowntime = this.downtimeEvents.reduce((sum, event) => {
      return sum + (event.duration || 0);
    }, 0);
    
    const availability = ((totalRuntime - totalDowntime) / totalRuntime * 100).toFixed(4);
    
    return {
      uptimePercentage: availability,
      totalDowntimeMs: totalDowntime,
      downtimeEvents: this.downtimeEvents.length,
      currentStatus: this.isHealthy ? 'healthy' : 'unhealthy'
    };
  }
}
```

### 2. **Performance Metrics**
```javascript
// Performance tracking
class PerformanceMonitor {
  constructor(logger) {
    this.logger = logger.child({ component: 'performance' });
    this.responseTimeWindow = [];
    this.errorRateWindow = [];
    this.windowSize = 100; // Keep last 100 requests
  }
  
  recordRequest(duration, isError) {
    // Add to response time window
    this.responseTimeWindow.push({
      duration,
      timestamp: Date.now(),
      isError
    });
    
    // Maintain window size
    if (this.responseTimeWindow.length > this.windowSize) {
      this.responseTimeWindow.shift();
    }
    
    // Calculate current metrics
    const metrics = this.getCurrentMetrics();
    
    // Log performance alerts
    if (metrics.averageResponseTime > 5000) {
      this.logger.warn('High average response time detected', metrics);
    }
    
    if (metrics.errorRate > 0.05) { // 5% error rate
      this.logger.error('High error rate detected', metrics);
    }
  }
  
  getCurrentMetrics() {
    if (this.responseTimeWindow.length === 0) return null;
    
    const totalDuration = this.responseTimeWindow.reduce((sum, req) => sum + req.duration, 0);
    const errorCount = this.responseTimeWindow.filter(req => req.isError).length;
    
    return {
      averageResponseTime: totalDuration / this.responseTimeWindow.length,
      errorRate: errorCount / this.responseTimeWindow.length,
      totalRequests: this.responseTimeWindow.length,
      errorCount,
      timeWindow: '100 requests'
    };
  }
}
```

## Health Dashboard Integration

### 1. **Health Endpoint Implementation**
```javascript
// Comprehensive health endpoint
app.get('/health/detailed', async (req, res) => {
  const startTime = Date.now();
  
  const healthReport = {
    timestamp: new Date().toISOString(),
    service: 'user-service',
    version: process.env.APP_VERSION,
    status: 'healthy',
    checks: {},
    metrics: {}
  };
  
  try {
    // Database check
    const dbStart = Date.now();
    await database.ping();
    healthReport.checks.database = {
      status: 'healthy',
      responseTime: Date.now() - dbStart
    };
    
    // Redis check
    const redisStart = Date.now();
    await redisClient.ping();
    healthReport.checks.redis = {
      status: 'healthy',
      responseTime: Date.now() - redisStart
    };
    
    // External services
    healthReport.checks.externalServices = {};
    for (const service of externalServices) {
      healthReport.checks.externalServices[service.name] = 
        serviceHealthChecker.getServiceHealth(service.name);
    }
    
    // System metrics
    healthReport.metrics = {
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      cpu: process.cpuUsage(),
      activeConnections: server.connections || 0
    };
    
    // Performance metrics
    healthReport.metrics.performance = performanceMonitor.getCurrentMetrics();
    
    // Availability stats
    healthReport.metrics.availability = availabilityTracker.getAvailabilityStats();
    
    // Overall health determination
    const hasUnhealthyChecks = Object.values(healthReport.checks)
      .some(check => check.status !== 'healthy');
    
    if (hasUnhealthyChecks) {
      healthReport.status = 'degraded';
    }
    
    logger.info('Health check completed', {
      duration: Date.now() - startTime,
      status: healthReport.status,
      checks: Object.keys(healthReport.checks).length
    });
    
    res.json(healthReport);
    
  } catch (error) {
    healthReport.status = 'unhealthy';
    healthReport.error = error.message;
    
    logger.error('Health check failed', {
      error: error.message,
      duration: Date.now() - startTime
    });
    
    res.status(503).json(healthReport);
  }
});
```

### 2. **Alerting Based on Health Logs**
```javascript
// Health-based alerting
class HealthAlerting {
  constructor(logger, alertService) {
    this.logger = logger.child({ component: 'health-alerting' });
    this.alertService = alertService;
    this.alertThresholds = {
      errorRate: 0.05,
      responseTime: 5000,
      memoryUsage: 0.9,
      diskUsage: 0.8
    };
    this.recentAlerts = new Map();
  }
  
  checkAndAlert(metrics) {
    // Error rate alerting
    if (metrics.errorRate > this.alertThresholds.errorRate) {
      this.sendAlert('high_error_rate', {
        currentRate: metrics.errorRate,
        threshold: this.alertThresholds.errorRate,
        severity: 'critical'
      });
    }
    
    // Response time alerting
    if (metrics.averageResponseTime > this.alertThresholds.responseTime) {
      this.sendAlert('slow_response_time', {
        currentTime: metrics.averageResponseTime,
        threshold: this.alertThresholds.responseTime,
        severity: 'warning'
      });
    }
    
    // Memory usage alerting
    const memUsage = process.memoryUsage();
    const memUtilization = memUsage.heapUsed / memUsage.heapTotal;
    
    if (memUtilization > this.alertThresholds.memoryUsage) {
      this.sendAlert('high_memory_usage', {
        currentUsage: memUtilization,
        threshold: this.alertThresholds.memoryUsage,
        severity: 'critical'
      });
    }
  }
  
  sendAlert(alertType, data) {
    const alertKey = `${alertType}-${Date.now()}`;
    
    // Prevent alert spam (same alert type within 5 minutes)
    const lastAlert = this.recentAlerts.get(alertType);
    if (lastAlert && Date.now() - lastAlert < 300000) {
      return;
    }
    
    this.recentAlerts.set(alertType, Date.now());
    
    const alert = {
      type: alertType,
      timestamp: new Date().toISOString(),
      service: 'user-service',
      data,
      alertKey
    };
    
    this.logger.error('Health alert triggered', alert);
    
    // Send to external alerting service
    this.alertService.send(alert).catch(error => {
      this.logger.error('Failed to send alert', {
        alert,
        error: error.message
      });
    });
  }
}
```

## Best Practices for Health Monitoring

### 1. **Proactive vs Reactive Monitoring**
- **Proactive**: Monitor trends and patterns before issues occur
- **Reactive**: Respond to alerts and incidents after they happen
- **Balance**: Use logs for both approaches

### 2. **Health Check Levels**
- **Shallow**: Basic connectivity and response
- **Deep**: Full functionality and dependency checks
- **Critical Path**: Most important user journeys

### 3. **Logging Strategy for Health**
- Use structured logging for metrics
- Implement proper log levels for different health states
- Include sufficient context for troubleshooting
- Balance verbosity with performance

---

**Previous**: [1.2.1 Troubleshooting and Debugging](./1.2.1_Troubleshooting_and_Debugging.md)  
**Next**: [1.2.3 Compliance and Audit Requirements](./1.2.3_Compliance_and_Audit_Requirements.md)
