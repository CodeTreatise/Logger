# 1.2.4 Performance Analysis

## Leveraging Logging for Performance Optimization

Performance analysis through logging is essential for maintaining responsive, efficient backend systems. Logging provides the data needed to identify bottlenecks, optimize resource usage, and ensure systems meet performance requirements under various load conditions.

## Understanding Performance Metrics Through Logging

### Key Performance Indicators (KPIs)
- **Response Time**: Time to process requests
- **Throughput**: Requests processed per unit time
- **Resource Utilization**: CPU, memory, disk, network usage
- **Error Rates**: Frequency of failures
- **Concurrency**: Simultaneous operations
- **Queue Depths**: Backlog in processing pipelines

### Performance Logging vs Metrics
```javascript
// Metrics - Quantitative measurements
const metrics = {
  responseTime: 245, // milliseconds
  memoryUsage: 0.75,  // 75% of heap
  cpuUsage: 0.45      // 45% CPU utilization
};

// Performance Logging - Contextual data with metrics
logger.info('Request processing completed', {
  // Performance metrics
  responseTime: 245,
  memoryUsage: process.memoryUsage(),
  cpuUsage: process.cpuUsage(),
  
  // Context for analysis
  endpoint: '/api/users/search',
  method: 'POST',
  requestSize: 1024,
  responseSize: 15360,
  userId: 'user123',
  
  // Environmental factors
  serverLoad: 0.65,
  databaseConnections: 45,
  cacheHitRate: 0.89,
  
  // Business context
  searchQuery: 'complex_query_type',
  resultCount: 150,
  cacheMiss: false
});
```

## Implementing Comprehensive Performance Logging

### 1. **Request-Level Performance Tracking**
```javascript
// Request performance middleware
class RequestPerformanceTracker {
  constructor(logger) {
    this.logger = logger.child({ component: 'performance' });
  }
  
  middleware() {
    return (req, res, next) => {
      const startTime = process.hrtime.bigint();
      const startMemory = process.memoryUsage();
      const startCpu = process.cpuUsage();
      
      // Track request details
      req.performanceContext = {
        startTime,
        startMemory,
        startCpu,
        requestId: req.headers['x-request-id'] || this.generateId()
      };
      
      // Override res.send to capture response metrics
      const originalSend = res.send;
      res.send = (data) => {
        const endTime = process.hrtime.bigint();
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        
        const performanceData = {
          // Request identification
          requestId: req.performanceContext.requestId,
          method: req.method,
          url: req.url,
          statusCode: res.statusCode,
          
          // Timing metrics
          responseTime: Number(endTime - startTime) / 1000000, // Convert to milliseconds
          
          // Resource usage
          memoryDelta: {
            rss: endMemory.rss - startMemory.rss,
            heapTotal: endMemory.heapTotal - startMemory.heapTotal,
            heapUsed: endMemory.heapUsed - startMemory.heapUsed,
            external: endMemory.external - startMemory.external
          },
          
          cpuUsage: {
            user: endCpu.user,
            system: endCpu.system
          },
          
          // Content metrics
          requestSize: req.get('content-length') || 0,
          responseSize: data ? Buffer.byteLength(data) : 0,
          
          // System state
          currentMemory: endMemory,
          activeHandles: process._getActiveHandles().length,
          activeRequests: process._getActiveRequests().length
        };
        
        // Log based on performance thresholds
        this.logPerformanceData(performanceData);
        
        return originalSend.call(res, data);
      };
      
      next();
    };
  }
  
  logPerformanceData(data) {
    // Categorize performance levels
    if (data.responseTime > 10000) { // > 10 seconds
      this.logger.error('Extremely slow request', data);
    } else if (data.responseTime > 5000) { // > 5 seconds
      this.logger.warn('Slow request detected', data);
    } else if (data.responseTime > 1000) { // > 1 second
      this.logger.info('Request completed', data);
    } else {
      this.logger.debug('Fast request completed', data);
    }
    
    // Memory usage alerts
    const heapUtilization = data.currentMemory.heapUsed / data.currentMemory.heapTotal;
    if (heapUtilization > 0.9) {
      this.logger.warn('High memory usage during request', {
        ...data,
        heapUtilization,
        memoryPressure: 'critical'
      });
    }
  }
}
```

### 2. **Database Performance Monitoring**
```javascript
// Database query performance logging
class DatabasePerformanceMonitor {
  constructor(database, logger) {
    this.database = database;
    this.logger = logger.child({ component: 'database-performance' });
    this.slowQueryThreshold = 1000; // 1 second
    this.queryStats = new Map(); // Track query patterns
  }
  
  async executeQuery(sql, params = [], context = {}) {
    const queryId = this.generateQueryId();
    const startTime = process.hrtime.bigint();
    const startMemory = process.memoryUsage();
    
    // Sanitize SQL for logging (remove sensitive data)
    const sanitizedSQL = this.sanitizeSQL(sql);
    const queryHash = this.hashQuery(sql);
    
    this.logger.debug('Query started', {
      queryId,
      sql: sanitizedSQL,
      paramCount: params.length,
      context
    });
    
    try {
      // Execute the actual query
      const result = await this.database.query(sql, params);
      
      const endTime = process.hrtime.bigint();
      const duration = Number(endTime - startTime) / 1000000; // milliseconds
      const endMemory = process.memoryUsage();
      
      const performanceData = {
        queryId,
        queryHash,
        sql: sanitizedSQL,
        duration,
        
        // Result metrics
        rowCount: result.rows?.length || 0,
        affectedRows: result.affectedRows || 0,
        
        // Resource usage
        memoryUsed: endMemory.heapUsed - startMemory.heapUsed,
        
        // Connection info
        connectionId: result.connection?.id,
        
        // Context
        ...context,
        
        // Classification
        queryType: this.classifyQuery(sql),
        performance: this.classifyPerformance(duration)
      };
      
      // Update query statistics
      this.updateQueryStats(queryHash, duration);
      
      // Log based on performance
      if (duration > this.slowQueryThreshold) {
        this.logger.warn('Slow query detected', performanceData);
      } else {
        this.logger.debug('Query completed', performanceData);
      }
      
      return result;
      
    } catch (error) {
      const endTime = process.hrtime.bigint();
      const duration = Number(endTime - startTime) / 1000000;
      
      this.logger.error('Query failed', {
        queryId,
        sql: sanitizedSQL,
        duration,
        error: error.message,
        context
      });
      
      throw error;
    }
  }
  
  classifyQuery(sql) {
    const upperSQL = sql.toUpperCase().trim();
    if (upperSQL.startsWith('SELECT')) return 'SELECT';
    if (upperSQL.startsWith('INSERT')) return 'INSERT';
    if (upperSQL.startsWith('UPDATE')) return 'UPDATE';
    if (upperSQL.startsWith('DELETE')) return 'DELETE';
    return 'OTHER';
  }
  
  classifyPerformance(duration) {
    if (duration < 100) return 'fast';
    if (duration < 500) return 'normal';
    if (duration < 1000) return 'slow';
    return 'very_slow';
  }
  
  getQueryStatistics() {
    const stats = Array.from(this.queryStats.entries()).map(([hash, data]) => ({
      queryHash: hash,
      totalExecutions: data.count,
      averageDuration: data.totalDuration / data.count,
      minDuration: data.minDuration,
      maxDuration: data.maxDuration,
      lastExecuted: data.lastExecuted
    }));
    
    return stats.sort((a, b) => b.averageDuration - a.averageDuration);
  }
}
```

### 3. **Application-Level Performance Profiling**
```javascript
// Function-level performance profiling
class FunctionProfiler {
  constructor(logger) {
    this.logger = logger.child({ component: 'function-profiler' });
    this.profiles = new Map();
  }
  
  // Decorator for automatic function profiling
  profile(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    const profiler = this;
    
    descriptor.value = async function(...args) {
      const functionName = `${target.constructor.name}.${propertyKey}`;
      return await profiler.profileFunction(functionName, originalMethod, this, args);
    };
    
    return descriptor;
  }
  
  async profileFunction(functionName, fn, context, args) {
    const profileId = this.generateProfileId();
    const startTime = process.hrtime.bigint();
    const startMemory = process.memoryUsage();
    const startCpu = process.cpuUsage();
    
    this.logger.debug('Function execution started', {
      profileId,
      functionName,
      argumentCount: args.length
    });
    
    try {
      const result = await fn.apply(context, args);
      
      const endTime = process.hrtime.bigint();
      const endMemory = process.memoryUsage();
      const endCpu = process.cpuUsage(startCpu);
      
      const performanceData = {
        profileId,
        functionName,
        duration: Number(endTime - startTime) / 1000000, // milliseconds
        
        // Memory impact
        memoryDelta: {
          heapUsed: endMemory.heapUsed - startMemory.heapUsed,
          rss: endMemory.rss - startMemory.rss
        },
        
        // CPU usage
        cpuUsage: {
          user: endCpu.user / 1000, // Convert to milliseconds
          system: endCpu.system / 1000
        },
        
        // Result info
        resultType: typeof result,
        resultSize: this.estimateObjectSize(result),
        
        // Success/failure
        status: 'success'
      };
      
      this.updateProfileStats(functionName, performanceData);
      this.logProfileData(performanceData);
      
      return result;
      
    } catch (error) {
      const endTime = process.hrtime.bigint();
      const duration = Number(endTime - startTime) / 1000000;
      
      this.logger.error('Function execution failed', {
        profileId,
        functionName,
        duration,
        error: error.message,
        status: 'error'
      });
      
      throw error;
    }
  }
  
  logProfileData(data) {
    if (data.duration > 5000) { // > 5 seconds
      this.logger.warn('Slow function execution', data);
    } else if (data.duration > 1000) { // > 1 second
      this.logger.info('Function execution completed', data);
    } else {
      this.logger.debug('Function execution completed', data);
    }
  }
  
  getTopSlowFunctions(limit = 10) {
    return Array.from(this.profiles.entries())
      .map(([name, stats]) => ({
        functionName: name,
        averageDuration: stats.totalDuration / stats.callCount,
        callCount: stats.callCount,
        totalDuration: stats.totalDuration,
        maxDuration: stats.maxDuration
      }))
      .sort((a, b) => b.averageDuration - a.averageDuration)
      .slice(0, limit);
  }
}

// Usage example with decorator
class UserService {
  constructor(database, logger) {
    this.database = database;
    this.profiler = new FunctionProfiler(logger);
  }
  
  @profile
  async getUserProfile(userId) {
    // Complex user profile aggregation
    const user = await this.database.findUser(userId);
    const preferences = await this.database.getUserPreferences(userId);
    const activityLog = await this.database.getUserActivity(userId, 30); // Last 30 days
    
    return {
      ...user,
      preferences,
      recentActivity: activityLog
    };
  }
}
```

### 4. **System Resource Performance Monitoring**
```javascript
// System-wide performance monitoring
class SystemPerformanceMonitor {
  constructor(logger) {
    this.logger = logger.child({ component: 'system-performance' });
    this.monitoringInterval = 10000; // 10 seconds
    this.performanceHistory = [];
    this.alertThresholds = {
      cpuUsage: 0.8,        // 80%
      memoryUsage: 0.85,    // 85%
      diskUsage: 0.9,       // 90%
      responseTime: 5000    // 5 seconds
    };
  }
  
  startMonitoring() {
    setInterval(() => {
      this.collectSystemMetrics();
    }, this.monitoringInterval);
    
    this.logger.info('System performance monitoring started', {
      interval: this.monitoringInterval,
      thresholds: this.alertThresholds
    });
  }
  
  async collectSystemMetrics() {
    const timestamp = new Date().toISOString();
    
    try {
      const metrics = {
        timestamp,
        
        // CPU metrics
        cpu: {
          usage: await this.getCPUUsage(),
          loadAverage: process.loadavg ? process.loadavg() : null
        },
        
        // Memory metrics
        memory: {
          ...process.memoryUsage(),
          usage: this.calculateMemoryUsage(),
          available: this.getAvailableMemory()
        },
        
        // Process metrics
        process: {
          uptime: process.uptime(),
          pid: process.pid,
          activeHandles: process._getActiveHandles().length,
          activeRequests: process._getActiveRequests().length
        },
        
        // Event loop metrics
        eventLoop: {
          delay: await this.measureEventLoopDelay(),
          utilization: this.getEventLoopUtilization()
        },
        
        // Garbage collection metrics (if available)
        gc: this.getGCStats()
      };
      
      this.performanceHistory.push(metrics);
      
      // Maintain history size (keep last 100 entries)
      if (this.performanceHistory.length > 100) {
        this.performanceHistory.shift();
      }
      
      // Check for performance issues
      this.analyzePerformance(metrics);
      
      // Log metrics
      this.logSystemMetrics(metrics);
      
    } catch (error) {
      this.logger.error('System metrics collection failed', {
        error: error.message,
        timestamp
      });
    }
  }
  
  analyzePerformance(metrics) {
    const issues = [];
    
    // CPU usage analysis
    if (metrics.cpu.usage > this.alertThresholds.cpuUsage) {
      issues.push({
        type: 'high_cpu_usage',
        severity: 'warning',
        value: metrics.cpu.usage,
        threshold: this.alertThresholds.cpuUsage
      });
    }
    
    // Memory usage analysis
    if (metrics.memory.usage > this.alertThresholds.memoryUsage) {
      issues.push({
        type: 'high_memory_usage',
        severity: 'warning',
        value: metrics.memory.usage,
        threshold: this.alertThresholds.memoryUsage
      });
    }
    
    // Event loop delay analysis
    if (metrics.eventLoop.delay > 100) { // > 100ms
      issues.push({
        type: 'event_loop_lag',
        severity: 'warning',
        value: metrics.eventLoop.delay,
        threshold: 100
      });
    }
    
    // Log performance issues
    if (issues.length > 0) {
      this.logger.warn('Performance issues detected', {
        timestamp: metrics.timestamp,
        issues,
        systemMetrics: metrics
      });
    }
    
    // Check for performance trends
    this.analyzeTrends();
  }
  
  analyzeTrends() {
    if (this.performanceHistory.length < 10) return;
    
    const recent = this.performanceHistory.slice(-10);
    const avgCpu = recent.reduce((sum, m) => sum + m.cpu.usage, 0) / recent.length;
    const avgMemory = recent.reduce((sum, m) => sum + m.memory.usage, 0) / recent.length;
    
    // Trend analysis
    const trends = {
      cpu: this.calculateTrend(recent.map(m => m.cpu.usage)),
      memory: this.calculateTrend(recent.map(m => m.memory.usage)),
      eventLoopDelay: this.calculateTrend(recent.map(m => m.eventLoop.delay))
    };
    
    // Log significant trends
    if (Math.abs(trends.cpu) > 0.1) { // 10% trend change
      this.logger.info('CPU usage trend detected', {
        trend: trends.cpu > 0 ? 'increasing' : 'decreasing',
        magnitude: Math.abs(trends.cpu),
        currentAverage: avgCpu
      });
    }
  }
  
  getPerformanceSummary(hours = 1) {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    const recentMetrics = this.performanceHistory.filter(m => 
      new Date(m.timestamp) > cutoff
    );
    
    if (recentMetrics.length === 0) return null;
    
    return {
      period: `${hours} hour(s)`,
      sampleCount: recentMetrics.length,
      
      cpu: {
        average: recentMetrics.reduce((sum, m) => sum + m.cpu.usage, 0) / recentMetrics.length,
        max: Math.max(...recentMetrics.map(m => m.cpu.usage)),
        min: Math.min(...recentMetrics.map(m => m.cpu.usage))
      },
      
      memory: {
        average: recentMetrics.reduce((sum, m) => sum + m.memory.usage, 0) / recentMetrics.length,
        max: Math.max(...recentMetrics.map(m => m.memory.usage)),
        min: Math.min(...recentMetrics.map(m => m.memory.usage))
      },
      
      eventLoop: {
        averageDelay: recentMetrics.reduce((sum, m) => sum + m.eventLoop.delay, 0) / recentMetrics.length,
        maxDelay: Math.max(...recentMetrics.map(m => m.eventLoop.delay))
      }
    };
  }
}
```

### 5. **Performance Alerting and Optimization**
```javascript
// Performance-based alerting system
class PerformanceAlerting {
  constructor(logger, alertService) {
    this.logger = logger.child({ component: 'performance-alerting' });
    this.alertService = alertService;
    this.recentAlerts = new Map();
    this.alertCooldown = 300000; // 5 minutes between same alert types
  }
  
  checkPerformanceThresholds(metrics) {
    const alerts = [];
    
    // Response time alerting
    if (metrics.responseTime > 5000) {
      alerts.push({
        type: 'slow_response',
        severity: 'warning',
        message: `Slow response time detected: ${metrics.responseTime}ms`,
        metrics: { responseTime: metrics.responseTime, threshold: 5000 }
      });
    }
    
    // Memory usage alerting
    const memoryUsage = metrics.memory.heapUsed / metrics.memory.heapTotal;
    if (memoryUsage > 0.9) {
      alerts.push({
        type: 'high_memory',
        severity: 'critical',
        message: `Critical memory usage: ${(memoryUsage * 100).toFixed(1)}%`,
        metrics: { memoryUsage, threshold: 0.9 }
      });
    }
    
    // Database query alerting
    if (metrics.dbQueryTime > 10000) {
      alerts.push({
        type: 'slow_database',
        severity: 'warning',
        message: `Slow database query: ${metrics.dbQueryTime}ms`,
        metrics: { queryTime: metrics.dbQueryTime, threshold: 10000 }
      });
    }
    
    // Send alerts
    alerts.forEach(alert => this.sendAlert(alert));
  }
  
  sendAlert(alert) {
    const now = Date.now();
    const lastAlert = this.recentAlerts.get(alert.type);
    
    // Check cooldown period
    if (lastAlert && (now - lastAlert) < this.alertCooldown) {
      return;
    }
    
    this.recentAlerts.set(alert.type, now);
    
    const alertData = {
      ...alert,
      timestamp: new Date().toISOString(),
      service: 'performance-monitor',
      environment: process.env.NODE_ENV
    };
    
    this.logger.error('Performance alert triggered', alertData);
    
    // Send to external alerting service
    this.alertService.send(alertData).catch(error => {
      this.logger.error('Failed to send performance alert', {
        alert: alertData,
        error: error.message
      });
    });
  }
}
```

## Performance Optimization Strategies Based on Log Analysis

### 1. **Identifying Bottlenecks**
```javascript
// Log analysis for bottleneck identification
class BottleneckAnalyzer {
  constructor(logStore) {
    this.logStore = logStore;
  }
  
  async analyzeBottlenecks(timeRange) {
    // Analyze slow endpoints
    const slowEndpoints = await this.logStore.aggregate([
      { $match: { 
        timestamp: { $gte: timeRange.start, $lte: timeRange.end },
        responseTime: { $gt: 1000 }
      }},
      { $group: {
        _id: '$url',
        avgResponseTime: { $avg: '$responseTime' },
        maxResponseTime: { $max: '$responseTime' },
        requestCount: { $sum: 1 }
      }},
      { $sort: { avgResponseTime: -1 }},
      { $limit: 10 }
    ]);
    
    // Analyze slow database queries
    const slowQueries = await this.logStore.aggregate([
      { $match: {
        component: 'database-performance',
        duration: { $gt: 1000 }
      }},
      { $group: {
        _id: '$queryHash',
        avgDuration: { $avg: '$duration' },
        maxDuration: { $max: '$duration' },
        executionCount: { $sum: 1 }
      }},
      { $sort: { avgDuration: -1 }},
      { $limit: 10 }
    ]);
    
    return {
      slowEndpoints,
      slowQueries,
      recommendations: this.generateRecommendations(slowEndpoints, slowQueries)
    };
  }
  
  generateRecommendations(endpoints, queries) {
    const recommendations = [];
    
    endpoints.forEach(endpoint => {
      if (endpoint.avgResponseTime > 5000) {
        recommendations.push({
          type: 'endpoint_optimization',
          priority: 'high',
          target: endpoint._id,
          suggestion: 'Consider caching, database optimization, or code profiling'
        });
      }
    });
    
    queries.forEach(query => {
      if (query.avgDuration > 5000) {
        recommendations.push({
          type: 'database_optimization',
          priority: 'high',
          target: query._id,
          suggestion: 'Review query execution plan, add indexes, or optimize joins'
        });
      }
    });
    
    return recommendations;
  }
}
```

## Best Practices for Performance Logging

### 1. **Minimal Performance Impact**
- Use asynchronous logging for performance-critical paths
- Sample high-frequency events to reduce volume
- Aggregate metrics before logging
- Use efficient serialization formats

### 2. **Comprehensive Coverage**
- Log at multiple application layers
- Include both success and failure scenarios
- Capture environmental context
- Track user experience metrics

### 3. **Actionable Insights**
- Include sufficient context for optimization
- Correlate performance with business metrics
- Set up automated alerting for thresholds
- Regular performance review cycles

---

**Previous**: [1.2.3 Compliance and Audit Requirements](./1.2.3_Compliance_and_Audit_Requirements.md)  
**Next**: [1.2.5 Security Incident Investigation](./1.2.5_Security_Incident_Investigation.md)
