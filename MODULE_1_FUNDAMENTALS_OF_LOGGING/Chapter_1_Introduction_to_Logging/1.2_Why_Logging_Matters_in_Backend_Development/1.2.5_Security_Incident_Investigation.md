# 1.2.5 Security Incident Investigation

## The Critical Role of Logging in Cybersecurity

Security incident investigation relies heavily on comprehensive logging to detect, analyze, and respond to security threats. Effective security logging enables organizations to identify attack patterns, understand breach scope, and implement appropriate countermeasures.

## Understanding Security Events Through Logging

### Types of Security Events
- **Authentication Events**: Login attempts, failures, account lockouts
- **Authorization Violations**: Unauthorized access attempts
- **Data Access**: Sensitive data viewing, modification, export
- **System Changes**: Configuration modifications, privilege escalations
- **Network Activity**: Suspicious connections, data transfers
- **Application Exploits**: Injection attempts, malicious inputs

### Security Logging vs Regular Logging
```javascript
// Regular application logging
logger.info('User logged in', { userId: 'user123' });

// Security-focused logging
securityLogger.warn('Authentication attempt', {
  eventType: 'authentication',
  result: 'success',
  
  // Who
  userId: 'user123',
  username: 'john.doe@company.com',
  userRole: 'admin',
  
  // When
  timestamp: new Date().toISOString(),
  sessionId: 'sess_abc123',
  
  // Where
  sourceIP: '192.168.1.100',
  userAgent: 'Mozilla/5.0...',
  location: 'New York, US',
  
  // How
  authenticationMethod: 'password',
  mfaUsed: true,
  mfaMethod: 'TOTP',
  
  // Context
  previousFailedAttempts: 0,
  lastSuccessfulLogin: '2025-08-17T15:30:00Z',
  deviceFingerprint: 'fp_xyz789',
  riskScore: 0.2,
  
  // Security metadata
  threatIndicators: [],
  anomalies: [],
  severity: 'low'
});
```

## Implementing Comprehensive Security Logging

### 1. **Authentication and Authorization Logging**
```javascript
// Comprehensive authentication logging
class SecurityAuthLogger {
  constructor(logger, threatDetection) {
    this.logger = logger.child({ component: 'security-auth' });
    this.threatDetection = threatDetection;
    this.failedAttempts = new Map(); // Track failed attempts per user
    this.suspiciousIPs = new Set();
  }
  
  async logAuthenticationAttempt(attempt) {
    const {
      username,
      password, // Never log the actual password
      sourceIP,
      userAgent,
      success,
      failureReason,
      mfaUsed,
      deviceFingerprint
    } = attempt;
    
    // Risk assessment
    const riskFactors = await this.assessRisk(attempt);
    const threatIndicators = await this.threatDetection.analyze(attempt);
    
    const authEvent = {
      eventType: 'authentication_attempt',
      timestamp: new Date().toISOString(),
      
      // Authentication details
      username: this.hashUsername(username), // Hash for privacy while maintaining trackability
      result: success ? 'success' : 'failure',
      failureReason: success ? null : failureReason,
      
      // Source information
      sourceIP,
      userAgent,
      deviceFingerprint,
      geoLocation: await this.getGeoLocation(sourceIP),
      
      // Security context
      mfaUsed,
      riskScore: riskFactors.score,
      riskFactors: riskFactors.factors,
      threatIndicators,
      
      // Session information
      sessionId: success ? this.generateSessionId() : null,
      
      // Historical context
      recentFailures: this.getRecentFailures(username),
      firstSeenIP: !this.isKnownIP(sourceIP, username),
      
      // Behavioral analysis
      timeOfDay: new Date().getHours(),
      dayOfWeek: new Date().getDay(),
      typicalLoginPattern: await this.analyzeBehavior(username, sourceIP)
    };
    
    // Update tracking
    if (!success) {
      this.trackFailedAttempt(username, sourceIP);
    } else {
      this.clearFailedAttempts(username);
    }
    
    // Log with appropriate severity
    if (riskFactors.score > 0.8 || threatIndicators.length > 0) {
      this.logger.error('High-risk authentication attempt', authEvent);
      await this.triggerSecurityAlert(authEvent);
    } else if (riskFactors.score > 0.5 || !success) {
      this.logger.warn('Suspicious authentication attempt', authEvent);
    } else {
      this.logger.info('Authentication attempt', authEvent);
    }
    
    return authEvent;
  }
  
  async logPrivilegeEscalation(user, targetPrivilege, success, context) {
    const escalationEvent = {
      eventType: 'privilege_escalation',
      timestamp: new Date().toISOString(),
      
      // Actor details
      userId: user.id,
      username: user.username,
      currentRole: user.role,
      currentPrivileges: user.privileges,
      
      // Target privilege
      targetPrivilege,
      escalationMethod: context.method,
      
      // Result
      success,
      newPrivileges: success ? context.newPrivileges : null,
      
      // Authorization chain
      approvedBy: context.approvedBy,
      approvalRequired: context.approvalRequired,
      emergencyOverride: context.emergencyOverride,
      
      // Context
      businessJustification: context.justification,
      requestedDuration: context.duration,
      
      // Security assessment
      riskLevel: this.assessPrivilegeRisk(user.role, targetPrivilege),
      securityReview: context.securityReview
    };
    
    if (success || escalationEvent.riskLevel === 'high') {
      this.logger.warn('Privilege escalation event', escalationEvent);
    } else {
      this.logger.info('Privilege escalation attempt', escalationEvent);
    }
  }
}
```

### 2. **Data Access and Manipulation Logging**
```javascript
// Sensitive data access logging
class DataSecurityLogger {
  constructor(logger, dataClassifier) {
    this.logger = logger.child({ component: 'data-security' });
    this.dataClassifier = dataClassifier;
    this.sensitiveDataTypes = ['PII', 'PHI', 'financial', 'classified'];
  }
  
  async logDataAccess(operation, user, resource, data) {
    // Classify data sensitivity
    const dataClassification = await this.dataClassifier.classify(data);
    const isSensitive = this.sensitiveDataTypes.includes(dataClassification.category);
    
    const dataAccessEvent = {
      eventType: 'data_access',
      timestamp: new Date().toISOString(),
      
      // Operation details
      operation, // 'read', 'create', 'update', 'delete', 'export'
      
      // User context
      userId: user.id,
      username: user.username,
      role: user.role,
      department: user.department,
      
      // Resource information
      resourceType: resource.type,
      resourceId: resource.id,
      resourceOwner: resource.owner,
      
      // Data classification
      dataClassification: dataClassification.category,
      sensitivityLevel: dataClassification.level,
      dataVolume: this.calculateDataVolume(data),
      recordCount: Array.isArray(data) ? data.length : 1,
      
      // Access context
      accessMethod: 'api', // 'api', 'direct_db', 'export', 'backup'
      sourceApplication: user.application,
      businessPurpose: user.accessPurpose,
      
      // Security context
      dataMinimization: this.checkDataMinimization(user.role, data),
      accessJustification: user.accessJustification,
      
      // Compliance tracking
      complianceFrameworks: dataClassification.complianceRelevant,
      auditRequired: isSensitive,
      
      // Network context
      sourceIP: user.ipAddress,
      location: user.location
    };
    
    // Log with appropriate level based on sensitivity
    if (isSensitive) {
      this.logger.warn('Sensitive data access', dataAccessEvent);
    } else {
      this.logger.info('Data access', dataAccessEvent);
    }
    
    // Trigger additional monitoring for sensitive data
    if (isSensitive && operation === 'export') {
      await this.logDataExport(dataAccessEvent, data);
    }
    
    return dataAccessEvent;
  }
  
  async logDataExport(baseEvent, exportedData) {
    const exportEvent = {
      ...baseEvent,
      eventType: 'sensitive_data_export',
      
      // Export-specific details
      exportFormat: 'json', // 'csv', 'json', 'xml', 'pdf'
      exportDestination: 'user_download',
      exportSize: Buffer.byteLength(JSON.stringify(exportedData)),
      
      // Data details (without actual content)
      dataTypes: this.analyzeDataTypes(exportedData),
      fieldsExported: Object.keys(exportedData[0] || {}),
      
      // Security measures
      encrypted: true,
      accessControlsApplied: true,
      watermarked: true,
      
      // Compliance
      dataRetentionApplied: true,
      privacyNoticeGiven: true
    };
    
    this.logger.error('Sensitive data export', exportEvent);
    
    // Trigger immediate security review for large exports
    if (exportEvent.exportSize > 1024 * 1024) { // > 1MB
      await this.triggerSecurityReview(exportEvent);
    }
  }
}
```

### 3. **Network and System Security Logging**
```javascript
// Network security event logging
class NetworkSecurityLogger {
  constructor(logger, threatIntelligence) {
    this.logger = logger.child({ component: 'network-security' });
    this.threatIntelligence = threatIntelligence;
    this.suspiciousPatterns = new Map();
  }
  
  async logNetworkConnection(connection) {
    const threatAnalysis = await this.threatIntelligence.analyze(connection.remoteIP);
    
    const networkEvent = {
      eventType: 'network_connection',
      timestamp: new Date().toISOString(),
      
      // Connection details
      protocol: connection.protocol,
      sourceIP: connection.remoteIP,
      sourcePort: connection.remotePort,
      destinationIP: connection.localIP,
      destinationPort: connection.localPort,
      
      // Threat intelligence
      threatScore: threatAnalysis.score,
      knownMalicious: threatAnalysis.knownMalicious,
      threatCategories: threatAnalysis.categories,
      geoLocation: threatAnalysis.geoLocation,
      
      // Connection context
      userAgent: connection.userAgent,
      referrer: connection.referrer,
      
      // Traffic analysis
      requestSize: connection.requestSize,
      responseSize: connection.responseSize,
      duration: connection.duration,
      
      // Security flags
      encryptedConnection: connection.encrypted,
      validCertificate: connection.validCert,
      
      // Pattern analysis
      frequencyAnalysis: this.analyzeConnectionFrequency(connection.remoteIP),
      behaviouralAnomalies: this.detectAnomalies(connection)
    };
    
    // Log based on threat level
    if (threatAnalysis.knownMalicious || threatAnalysis.score > 0.8) {
      this.logger.error('Malicious network connection detected', networkEvent);
      await this.blockIP(connection.remoteIP);
    } else if (threatAnalysis.score > 0.5) {
      this.logger.warn('Suspicious network connection', networkEvent);
    } else {
      this.logger.debug('Network connection', networkEvent);
    }
  }
  
  async logSecurityScan(scanEvent) {
    const securityScanEvent = {
      eventType: 'security_scan_detected',
      timestamp: new Date().toISOString(),
      
      // Scan characteristics
      scanType: scanEvent.type, // 'port_scan', 'vulnerability_scan', 'brute_force'
      sourceIP: scanEvent.sourceIP,
      targetPorts: scanEvent.ports,
      scanDuration: scanEvent.duration,
      requestPattern: scanEvent.pattern,
      
      // Detection details
      detectionMethod: 'pattern_analysis',
      confidence: scanEvent.confidence,
      
      // Threat assessment
      severity: this.assessScanSeverity(scanEvent),
      potentialTarget: scanEvent.targetService,
      
      // Response actions
      automaticBlocking: true,
      alertsTriggered: ['security_team', 'network_admin'],
      
      // Historical context
      previousScansFromIP: this.getPreviousScans(scanEvent.sourceIP),
      knownAttacker: await this.checkAttackerDB(scanEvent.sourceIP)
    };
    
    this.logger.error('Security scan detected', securityScanEvent);
    await this.triggerIncidentResponse(securityScanEvent);
  }
}
```

### 4. **Application Security Logging**
```javascript
// Application-level security logging
class ApplicationSecurityLogger {
  constructor(logger, inputValidator) {
    this.logger = logger.child({ component: 'application-security' });
    this.inputValidator = inputValidator;
    this.attackPatterns = new Map();
  }
  
  async logSecurityEvent(request, eventType, details) {
    // Analyze request for attack patterns
    const attackAnalysis = await this.analyzeForAttacks(request);
    
    const securityEvent = {
      eventType,
      timestamp: new Date().toISOString(),
      
      // Request details (sanitized)
      method: request.method,
      url: this.sanitizeURL(request.url),
      headers: this.sanitizeHeaders(request.headers),
      
      // User context
      userId: request.user?.id,
      sessionId: request.sessionId,
      sourceIP: request.ip,
      userAgent: request.get('User-Agent'),
      
      // Attack analysis
      attackType: attackAnalysis.type,
      attackPatterns: attackAnalysis.patterns,
      maliciousPayload: attackAnalysis.hasMaliciousPayload,
      riskScore: attackAnalysis.riskScore,
      
      // Input validation results
      validationErrors: details.validationErrors,
      sanitizationApplied: details.sanitizationApplied,
      blocked: details.blocked,
      
      // Context
      endpoint: request.route?.path,
      parameters: this.sanitizeParameters(request.params),
      
      // Security measures
      rateLimitingApplied: details.rateLimited,
      authenticationRequired: details.authRequired,
      authorizationPassed: details.authorized
    };
    
    // Log based on severity
    switch (eventType) {
      case 'sql_injection_attempt':
      case 'xss_attempt':
      case 'command_injection_attempt':
        this.logger.error('Critical security attack detected', securityEvent);
        await this.triggerSecurityAlert(securityEvent);
        break;
        
      case 'suspicious_input':
      case 'rate_limit_exceeded':
        this.logger.warn('Security event detected', securityEvent);
        break;
        
      default:
        this.logger.info('Security event', securityEvent);
    }
    
    // Update attack tracking
    this.updateAttackTracking(request.ip, attackAnalysis);
  }
  
  async logFileUploadSecurity(upload, user, scanResults) {
    const fileSecurityEvent = {
      eventType: 'file_upload_security',
      timestamp: new Date().toISOString(),
      
      // File details
      fileName: upload.originalname,
      fileSize: upload.size,
      mimeType: upload.mimetype,
      fileExtension: path.extname(upload.originalname),
      
      // User context
      userId: user.id,
      userRole: user.role,
      sourceIP: user.ipAddress,
      
      // Security scanning results
      virusScanResult: scanResults.virusScan,
      malwareDetected: scanResults.malwareDetected,
      contentValidation: scanResults.contentValidation,
      
      // File analysis
      suspiciousExtension: this.checkSuspiciousExtension(upload.originalname),
      executableContent: scanResults.executableContent,
      embeddedScripts: scanResults.embeddedScripts,
      
      // Security measures
      quarantined: scanResults.quarantined,
      sanitized: scanResults.sanitized,
      allowedToProcess: scanResults.allowed
    };
    
    if (scanResults.malwareDetected || scanResults.quarantined) {
      this.logger.error('Malicious file upload detected', fileSecurityEvent);
    } else if (fileSecurityEvent.suspiciousExtension) {
      this.logger.warn('Suspicious file upload', fileSecurityEvent);
    } else {
      this.logger.info('File upload security check', fileSecurityEvent);
    }
  }
}
```

### 5. **Security Incident Response Logging**
```javascript
// Security incident response and forensics logging
class SecurityIncidentLogger {
  constructor(logger, incidentManager) {
    this.logger = logger.child({ component: 'security-incident' });
    this.incidentManager = incidentManager;
  }
  
  async createSecurityIncident(triggerEvent, severity = 'medium') {
    const incidentId = this.generateIncidentId();
    
    const incident = {
      incidentId,
      eventType: 'security_incident_created',
      timestamp: new Date().toISOString(),
      
      // Incident classification
      severity, // 'low', 'medium', 'high', 'critical'
      category: this.categorizeIncident(triggerEvent),
      
      // Trigger event
      triggerEvent: {
        eventType: triggerEvent.eventType,
        timestamp: triggerEvent.timestamp,
        sourceIP: triggerEvent.sourceIP,
        userId: triggerEvent.userId,
        riskScore: triggerEvent.riskScore
      },
      
      // Initial assessment
      initialAssessment: {
        scope: 'under_investigation',
        affectedSystems: [],
        dataAtRisk: 'unknown',
        businessImpact: 'assessing'
      },
      
      // Response team
      assignedTo: this.getIncidentHandler(severity),
      stakeholdersNotified: this.getStakeholders(severity),
      
      // Timeline
      detectionTime: triggerEvent.timestamp,
      responseTime: new Date().toISOString(),
      targetResolutionTime: this.calculateSLA(severity),
      
      // Status
      status: 'open',
      priority: this.calculatePriority(severity, triggerEvent)
    };
    
    this.logger.error('Security incident created', incident);
    
    // Initialize incident response
    await this.incidentManager.initializeResponse(incident);
    
    return incident;
  }
  
  async logIncidentUpdate(incidentId, update, updatedBy) {
    const updateEvent = {
      eventType: 'security_incident_update',
      timestamp: new Date().toISOString(),
      incidentId,
      
      // Update details
      updateType: update.type, // 'assessment', 'containment', 'eradication', 'recovery'
      updatedBy: updatedBy.id,
      updatedByRole: updatedBy.role,
      
      // Changes made
      statusChange: update.statusChange,
      severityChange: update.severityChange,
      assignmentChange: update.assignmentChange,
      
      // Investigation findings
      newFindings: update.findings,
      evidenceCollected: update.evidence,
      affectedSystemsUpdate: update.affectedSystems,
      
      // Actions taken
      containmentActions: update.containmentActions,
      mitigationSteps: update.mitigationSteps,
      
      // Next steps
      nextActions: update.nextActions,
      estimatedResolution: update.estimatedResolution
    };
    
    this.logger.warn('Security incident updated', updateEvent);
    
    // Check for escalation criteria
    if (update.severityChange === 'increased') {
      await this.checkEscalationCriteria(incidentId, update);
    }
  }
  
  async logForensicEvidence(incidentId, evidence, collectedBy) {
    const evidenceEvent = {
      eventType: 'forensic_evidence_collected',
      timestamp: new Date().toISOString(),
      incidentId,
      
      // Evidence details
      evidenceType: evidence.type, // 'log_file', 'memory_dump', 'disk_image', 'network_capture'
      evidenceId: evidence.id,
      collectionTime: evidence.collectionTime,
      
      // Chain of custody
      collectedBy: collectedBy.id,
      collectorRole: collectedBy.role,
      custodyChain: evidence.custodyChain,
      
      // Evidence integrity
      hash: evidence.hash,
      hashAlgorithm: evidence.hashAlgorithm,
      digitalSignature: evidence.signature,
      
      // Source information
      sourceSystem: evidence.sourceSystem,
      sourceLocation: evidence.sourceLocation,
      acquisitionMethod: evidence.acquisitionMethod,
      
      // Analysis
      initialAnalysis: evidence.initialAnalysis,
      keyFindings: evidence.keyFindings,
      
      // Storage
      storageLocation: evidence.storageLocation,
      retentionPeriod: evidence.retentionPeriod,
      accessRestrictions: evidence.accessRestrictions
    };
    
    this.logger.info('Forensic evidence collected', evidenceEvent);
    
    // Ensure evidence integrity
    await this.verifyEvidenceIntegrity(evidence);
  }
}
```

## Security Monitoring and Alerting

### 1. **Real-time Security Monitoring**
```javascript
// Real-time security event monitoring
class SecurityMonitor {
  constructor(logger, alertService) {
    this.logger = logger.child({ component: 'security-monitor' });
    this.alertService = alertService;
    this.securityRules = new Map();
    this.eventBuffer = [];
    
    this.initializeSecurityRules();
    this.startMonitoring();
  }
  
  initializeSecurityRules() {
    // Failed authentication rule
    this.securityRules.set('multiple_failed_auth', {
      condition: (events) => {
        const failedAuth = events.filter(e => 
          e.eventType === 'authentication_attempt' && 
          e.result === 'failure' &&
          Date.now() - new Date(e.timestamp).getTime() < 300000 // Last 5 minutes
        );
        return failedAuth.length >= 5;
      },
      severity: 'high',
      action: 'block_ip'
    });
    
    // Privilege escalation rule
    this.securityRules.set('suspicious_privilege_escalation', {
      condition: (events) => {
        return events.some(e => 
          e.eventType === 'privilege_escalation' &&
          e.riskLevel === 'high' &&
          !e.approvedBy
        );
      },
      severity: 'critical',
      action: 'immediate_alert'
    });
    
    // Data exfiltration rule
    this.securityRules.set('large_data_export', {
      condition: (events) => {
        const exports = events.filter(e => 
          e.eventType === 'sensitive_data_export' &&
          e.exportSize > 10 * 1024 * 1024 // > 10MB
        );
        return exports.length > 0;
      },
      severity: 'high',
      action: 'security_review'
    });
  }
  
  async processSecurityEvent(event) {
    // Add to event buffer
    this.eventBuffer.push(event);
    
    // Maintain buffer size (last 1000 events)
    if (this.eventBuffer.length > 1000) {
      this.eventBuffer.shift();
    }
    
    // Check security rules
    for (const [ruleName, rule] of this.securityRules) {
      if (rule.condition(this.eventBuffer)) {
        await this.triggerSecurityRule(ruleName, rule, event);
      }
    }
    
    // Real-time threat detection
    const threatLevel = await this.assessThreatLevel(event);
    if (threatLevel >= 0.8) {
      await this.triggerImmediateResponse(event, threatLevel);
    }
  }
  
  async triggerSecurityRule(ruleName, rule, triggerEvent) {
    const alertData = {
      alertType: 'security_rule_triggered',
      ruleName,
      severity: rule.severity,
      timestamp: new Date().toISOString(),
      triggerEvent,
      recommendedAction: rule.action,
      context: this.gatherSecurityContext(triggerEvent)
    };
    
    this.logger.error('Security rule triggered', alertData);
    
    // Execute automated response
    await this.executeAutomatedResponse(rule.action, triggerEvent);
    
    // Send alert
    await this.alertService.sendSecurityAlert(alertData);
  }
}
```

## Best Practices for Security Logging

### 1. **Comprehensive Coverage**
- Log all authentication and authorization events
- Track all access to sensitive data
- Monitor system configuration changes
- Capture network security events
- Log application security events

### 2. **Real-time Detection**
- Implement real-time log analysis
- Set up automated alerting for threats
- Use correlation rules for pattern detection
- Enable automatic response for critical threats

### 3. **Forensic Readiness**
- Maintain detailed audit trails
- Ensure log integrity and non-repudiation
- Implement proper chain of custody
- Enable comprehensive incident reconstruction

### 4. **Privacy and Compliance**
- Sanitize sensitive data in logs
- Implement proper access controls
- Meet regulatory logging requirements
- Maintain appropriate retention periods

### 5. **Performance Considerations**
- Use asynchronous logging for security events
- Implement efficient log storage and retrieval
- Balance detail with performance impact
- Optimize for both security and operations

---

**Previous**: [1.2.4 Performance Analysis](./1.2.4_Performance_Analysis.md)  
**Next**: [1.3 Types of Information to Log](../1.3_Types_of_Information_to_Log/)
