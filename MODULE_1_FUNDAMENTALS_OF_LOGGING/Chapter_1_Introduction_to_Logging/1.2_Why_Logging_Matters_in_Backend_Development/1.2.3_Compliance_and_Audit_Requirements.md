# 1.2.3 Compliance and Audit Requirements

## The Critical Role of Logging in Regulatory Compliance

Compliance and audit requirements are fundamental drivers for enterprise logging strategies. Organizations must maintain detailed records of system activities, user actions, and data access to meet regulatory standards and demonstrate accountability.

## Understanding Compliance in the Context of Logging

### What is Compliance Logging?
Compliance logging is the systematic recording of events, transactions, and system activities to meet regulatory requirements, industry standards, and internal policies.

### Key Characteristics of Compliance Logs
- **Immutable**: Cannot be altered after creation
- **Complete**: Comprehensive coverage of required events
- **Accurate**: Precise and factual information
- **Accessible**: Available for audit and investigation
- **Secure**: Protected from unauthorized access
- **Timestamped**: Accurate time recording with proper time zones

## Major Compliance Frameworks and Their Logging Requirements

### 1. **SOX (Sarbanes-Oxley Act)**
**Focus**: Financial reporting and corporate governance

```javascript
// SOX-compliant financial transaction logging
class SOXCompliantTransactionLogger {
  constructor(logger) {
    this.logger = logger.child({ compliance: 'SOX' });
  }
  
  logFinancialTransaction(transaction, user) {
    const auditEntry = {
      eventType: 'financial_transaction',
      transactionId: transaction.id,
      
      // Who - User identification
      userId: user.id,
      userName: user.username,
      userRole: user.role,
      department: user.department,
      
      // What - Transaction details
      transactionType: transaction.type,
      amount: transaction.amount,
      currency: transaction.currency,
      account: {
        from: transaction.fromAccount,
        to: transaction.toAccount
      },
      
      // When - Precise timing
      timestamp: new Date().toISOString(),
      fiscalPeriod: this.getCurrentFiscalPeriod(),
      
      // Where - System context
      systemId: process.env.SYSTEM_ID,
      applicationVersion: process.env.APP_VERSION,
      sourceIP: user.ipAddress,
      
      // Why - Business justification
      businessReason: transaction.reason,
      approvalChain: transaction.approvals,
      
      // Integrity
      hash: this.calculateHash(transaction),
      digitalSignature: this.signTransaction(transaction)
    };
    
    this.logger.info('SOX financial transaction', auditEntry);
    
    // Also send to secure audit store
    this.sendToAuditStore(auditEntry);
  }
  
  logAccessControl(action, user, resource) {
    this.logger.info('SOX access control event', {
      eventType: 'access_control',
      action, // 'grant', 'revoke', 'modify'
      userId: user.id,
      targetResource: resource,
      timestamp: new Date().toISOString(),
      authorizedBy: user.authorizedBy,
      businessJustification: user.accessReason
    });
  }
}
```

### 2. **HIPAA (Health Insurance Portability and Accountability Act)**
**Focus**: Protected Health Information (PHI)

```javascript
// HIPAA-compliant PHI access logging
class HIPAALogger {
  constructor(logger) {
    this.logger = logger.child({ compliance: 'HIPAA' });
  }
  
  logPHIAccess(action, user, patient, dataElements) {
    const hipaaEvent = {
      eventType: 'phi_access',
      
      // Required HIPAA fields
      eventDateTime: new Date().toISOString(),
      userId: this.hashUserId(user.id), // Hash for privacy
      userRole: user.role,
      
      // Patient information (de-identified where possible)
      patientIdentifier: this.hashPatientId(patient.id),
      
      // What was accessed
      action, // 'view', 'create', 'update', 'delete', 'export'
      dataElements: dataElements.map(element => ({
        type: element.type,
        category: element.category,
        sensitive: element.isSensitive
      })),
      
      // Context
      purposeOfUse: user.purposeOfUse, // 'treatment', 'payment', 'operations'
      sourceSystem: process.env.SYSTEM_NAME,
      location: user.facility,
      
      // Audit trail
      eventResult: 'success', // 'success', 'failure'
      
      // Network information
      sourceIP: user.ipAddress,
      userAgent: user.userAgent
    };
    
    // Log based on sensitivity
    if (dataElements.some(e => e.isSensitive)) {
      this.logger.warn('Sensitive PHI accessed', hipaaEvent);
    } else {
      this.logger.info('PHI access', hipaaEvent);
    }
    
    // Send to HIPAA audit system
    this.sendToHIPAAAuditSystem(hipaaEvent);
  }
  
  logPHIBreach(incident) {
    this.logger.error('HIPAA breach incident', {
      eventType: 'phi_breach',
      incidentId: incident.id,
      discoveryDate: incident.discoveryDate,
      incidentDate: incident.incidentDate,
      affectedPatients: incident.affectedPatients.length,
      breachType: incident.type,
      mitigation: incident.mitigationSteps,
      reportedToHHS: incident.reportedToHHS,
      notificationSent: incident.patientNotificationSent
    });
  }
}
```

### 3. **PCI DSS (Payment Card Industry Data Security Standard)**
**Focus**: Cardholder data protection

```javascript
// PCI DSS compliant payment logging
class PCILogger {
  constructor(logger) {
    this.logger = logger.child({ compliance: 'PCI_DSS' });
  }
  
  logPaymentTransaction(transaction, user) {
    // Never log full card numbers - use tokens or masked values
    const pciEvent = {
      eventType: 'payment_transaction',
      transactionId: transaction.id,
      
      // PCI DSS required fields
      timestamp: new Date().toISOString(),
      userId: user.id,
      userRole: user.role,
      
      // Payment data (sanitized)
      cardToken: transaction.cardToken, // Tokenized, not actual card number
      maskedPAN: transaction.maskedCardNumber, // e.g., "****-****-****-1234"
      expiryMonth: transaction.expiryMonth,
      // Never log CVV, full PAN, or PIN
      
      // Transaction details
      amount: transaction.amount,
      currency: transaction.currency,
      merchantId: transaction.merchantId,
      
      // System information
      sourceIP: user.ipAddress,
      systemComponent: 'payment-processor',
      
      // Security context
      encryptionUsed: true,
      tlsVersion: transaction.tlsVersion,
      
      // Result
      result: transaction.status, // 'approved', 'declined', 'error'
      responseCode: transaction.responseCode,
      authorizationCode: transaction.authCode
    };
    
    if (transaction.status === 'declined' || transaction.status === 'error') {
      this.logger.warn('Payment transaction failed', pciEvent);
    } else {
      this.logger.info('Payment transaction processed', pciEvent);
    }
  }
  
  logCardDataAccess(user, action, dataType) {
    this.logger.warn('Cardholder data access', {
      eventType: 'cardholder_data_access',
      userId: user.id,
      action,
      dataType, // 'card_tokens', 'transaction_history', 'customer_profiles'
      timestamp: new Date().toISOString(),
      businessJustification: user.accessReason,
      authorizedBy: user.supervisor
    });
  }
}
```

### 4. **GDPR (General Data Protection Regulation)**
**Focus**: Personal data protection and privacy

```javascript
// GDPR-compliant personal data logging
class GDPRLogger {
  constructor(logger) {
    this.logger = logger.child({ compliance: 'GDPR' });
  }
  
  logPersonalDataProcessing(operation, dataSubject, processor, legalBasis) {
    const gdprEvent = {
      eventType: 'personal_data_processing',
      
      // GDPR Article 30 requirements
      timestamp: new Date().toISOString(),
      
      // Data subject information (pseudonymized)
      dataSubjectId: this.pseudonymizeId(dataSubject.id),
      dataSubjectCategory: dataSubject.category, // 'customer', 'employee', 'prospect'
      
      // Processing details
      processingOperation: operation, // 'collect', 'use', 'store', 'transfer', 'delete'
      purposeOfProcessing: processor.purpose,
      legalBasisForProcessing: legalBasis, // 'consent', 'contract', 'legal_obligation', etc.
      
      // Data categories
      personalDataCategories: processor.dataCategories,
      specialCategories: processor.specialCategories || [],
      
      // Processor information
      processorId: processor.id,
      processorRole: processor.role,
      
      // Recipients and transfers
      dataRecipients: processor.recipients || [],
      thirdCountryTransfer: processor.thirdCountryTransfer || false,
      
      // Retention
      retentionPeriod: processor.retentionPeriod,
      
      // Technical and organizational measures
      securityMeasures: processor.securityMeasures,
      encryptionUsed: processor.encryptionUsed
    };
    
    this.logger.info('GDPR personal data processing', gdprEvent);
  }
  
  logDataSubjectRights(request, dataSubject) {
    this.logger.info('GDPR data subject rights request', {
      eventType: 'data_subject_rights',
      requestId: request.id,
      dataSubjectId: this.pseudonymizeId(dataSubject.id),
      requestType: request.type, // 'access', 'rectification', 'erasure', 'portability', etc.
      requestDate: request.submittedAt,
      requestMethod: request.method, // 'web_form', 'email', 'phone', 'in_person'
      
      // Processing information
      processedBy: request.processedBy,
      completedAt: request.completedAt,
      status: request.status, // 'received', 'processing', 'completed', 'rejected'
      
      // Response details
      responseMethod: request.responseMethod,
      rejectionReason: request.rejectionReason,
      
      // Compliance timing
      daysToComplete: request.daysToComplete,
      withinSLA: request.daysToComplete <= 30 // GDPR 30-day requirement
    });
  }
}
```

## Implementing Comprehensive Audit Logging

### 1. **Audit Event Structure**
```javascript
// Standardized audit event structure
class AuditEventBuilder {
  constructor() {
    this.event = {
      // Core audit fields
      eventId: this.generateEventId(),
      timestamp: new Date().toISOString(),
      
      // Classification
      eventType: null,
      category: null,
      severity: 'info',
      
      // Actor (who)
      actor: {
        userId: null,
        userName: null,
        role: null,
        sessionId: null,
        ipAddress: null,
        userAgent: null
      },
      
      // Target (what)
      target: {
        resourceId: null,
        resourceType: null,
        resourceName: null,
        attributes: {}
      },
      
      // Action (how)
      action: {
        operation: null,
        method: null,
        parameters: {},
        result: null
      },
      
      // Context (where/when/why)
      context: {
        systemId: process.env.SYSTEM_ID,
        environment: process.env.NODE_ENV,
        applicationVersion: process.env.APP_VERSION,
        correlationId: null,
        businessContext: null
      },
      
      // Compliance tags
      compliance: {
        frameworks: [],
        dataClassification: null,
        retentionPolicy: null
      },
      
      // Integrity
      hash: null,
      signature: null
    };
  }
  
  setActor(userId, userName, role, sessionId, ipAddress) {
    this.event.actor = { userId, userName, role, sessionId, ipAddress };
    return this;
  }
  
  setTarget(resourceId, resourceType, resourceName) {
    this.event.target = { resourceId, resourceType, resourceName };
    return this;
  }
  
  setAction(operation, method, parameters, result) {
    this.event.action = { operation, method, parameters, result };
    return this;
  }
  
  setCompliance(frameworks, dataClassification, retentionPolicy) {
    this.event.compliance = { frameworks, dataClassification, retentionPolicy };
    return this;
  }
  
  build() {
    // Calculate integrity hash
    this.event.hash = this.calculateHash();
    return this.event;
  }
}
```

### 2. **Automated Compliance Reporting**
```javascript
// Compliance report generator
class ComplianceReporter {
  constructor(logger, auditStore) {
    this.logger = logger;
    this.auditStore = auditStore;
  }
  
  async generateSOXReport(startDate, endDate) {
    const soxEvents = await this.auditStore.query({
      'compliance.frameworks': 'SOX',
      timestamp: { $gte: startDate, $lte: endDate }
    });
    
    const report = {
      reportType: 'SOX_COMPLIANCE',
      period: { start: startDate, end: endDate },
      generatedAt: new Date().toISOString(),
      
      summary: {
        totalEvents: soxEvents.length,
        financialTransactions: soxEvents.filter(e => e.eventType === 'financial_transaction').length,
        accessControlEvents: soxEvents.filter(e => e.eventType === 'access_control').length,
        failedEvents: soxEvents.filter(e => e.action.result === 'failure').length
      },
      
      // Segregation of duties analysis
      segregationAnalysis: this.analyzeSeparationOfDuties(soxEvents),
      
      // Unauthorized access attempts
      securityEvents: soxEvents.filter(e => e.severity === 'warn' || e.severity === 'error'),
      
      // Data integrity verification
      integrityCheck: this.verifyEventIntegrity(soxEvents)
    };
    
    this.logger.info('SOX compliance report generated', {
      reportType: 'SOX',
      eventCount: soxEvents.length,
      period: report.period
    });
    
    return report;
  }
  
  async generateHIPAAReport(startDate, endDate) {
    const hipaaEvents = await this.auditStore.query({
      'compliance.frameworks': 'HIPAA',
      timestamp: { $gte: startDate, $lte: endDate }
    });
    
    const report = {
      reportType: 'HIPAA_COMPLIANCE',
      period: { start: startDate, end: endDate },
      generatedAt: new Date().toISOString(),
      
      summary: {
        totalPHIAccess: hipaaEvents.filter(e => e.eventType === 'phi_access').length,
        uniqueUsers: new Set(hipaaEvents.map(e => e.actor.userId)).size,
        uniquePatients: new Set(hipaaEvents.map(e => e.target.patientId)).size,
        breachIncidents: hipaaEvents.filter(e => e.eventType === 'phi_breach').length
      },
      
      // Access pattern analysis
      accessAnalysis: this.analyzeAccessPatterns(hipaaEvents),
      
      // Minimum necessary standard compliance
      minimumNecessaryCompliance: this.checkMinimumNecessary(hipaaEvents),
      
      // Audit log completeness
      completenessCheck: this.verifyAuditCompleteness(hipaaEvents)
    };
    
    return report;
  }
}
```

### 3. **Log Retention and Archival**
```javascript
// Compliance-aware log retention
class ComplianceRetentionManager {
  constructor(logger, storageService) {
    this.logger = logger;
    this.storageService = storageService;
    
    // Retention periods by compliance framework
    this.retentionPolicies = {
      SOX: { years: 7, immutable: true },
      HIPAA: { years: 6, immutable: true },
      PCI_DSS: { years: 1, immutable: true },
      GDPR: { years: 'as_needed', deletionRequired: true },
      DEFAULT: { years: 3, immutable: false }
    };
  }
  
  async archiveComplianceLogs(framework, olderThan) {
    const retentionPolicy = this.retentionPolicies[framework];
    const cutoffDate = new Date();
    cutoffDate.setFullYear(cutoffDate.getFullYear() - retentionPolicy.years);
    
    this.logger.info('Starting compliance log archival', {
      framework,
      cutoffDate: cutoffDate.toISOString(),
      retentionYears: retentionPolicy.years
    });
    
    try {
      // Query logs for archival
      const logsToArchive = await this.storageService.query({
        'compliance.frameworks': framework,
        timestamp: { $lt: cutoffDate }
      });
      
      // Create archive package
      const archivePackage = {
        framework,
        archiveDate: new Date().toISOString(),
        recordCount: logsToArchive.length,
        period: {
          start: logsToArchive[0]?.timestamp,
          end: logsToArchive[logsToArchive.length - 1]?.timestamp
        },
        integrity: {
          hash: this.calculateArchiveHash(logsToArchive),
          verification: this.verifyLogIntegrity(logsToArchive)
        },
        logs: logsToArchive
      };
      
      // Store in immutable archive
      const archiveId = await this.storageService.createArchive(archivePackage, {
        immutable: retentionPolicy.immutable,
        encryption: true,
        compression: true
      });
      
      // Remove from active storage (except for GDPR which may require deletion)
      if (framework !== 'GDPR') {
        await this.storageService.moveToArchive(logsToArchive.map(log => log.id));
      }
      
      this.logger.info('Compliance log archival completed', {
        framework,
        archiveId,
        recordsArchived: logsToArchive.length,
        archiveSize: archivePackage.size
      });
      
      return archiveId;
      
    } catch (error) {
      this.logger.error('Compliance log archival failed', {
        framework,
        error: error.message,
        cutoffDate: cutoffDate.toISOString()
      });
      throw error;
    }
  }
}
```

## Best Practices for Compliance Logging

### 1. **Log Completeness and Accuracy**
- Ensure all required events are captured
- Validate data accuracy and completeness
- Implement checksums and digital signatures
- Regular integrity verification

### 2. **Access Control and Security**
- Restrict access to audit logs
- Implement role-based access control
- Encrypt logs at rest and in transit
- Secure log transmission channels

### 3. **Immutability and Tamper-Evident Storage**
- Use write-once storage systems
- Implement cryptographic hash chains
- Regular backup and verification
- Secure time-stamping services

### 4. **Compliance Monitoring and Alerting**
- Real-time compliance violation detection
- Automated policy enforcement
- Regular compliance assessments
- Incident response procedures

### 5. **Documentation and Training**
- Maintain compliance logging procedures
- Regular staff training on requirements
- Document retention and disposal policies
- Keep up with regulatory changes

---

**Previous**: [1.2.2 Monitoring Application Health](./1.2.2_Monitoring_Application_Health.md)  
**Next**: [1.2.4 Performance Analysis](./1.2.4_Performance_Analysis.md)
