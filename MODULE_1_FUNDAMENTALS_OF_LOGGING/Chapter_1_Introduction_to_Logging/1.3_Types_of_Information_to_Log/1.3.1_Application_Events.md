# 1.3.1 Application Events

## Understanding Application Events in Logging

Application events represent the core business operations and technical processes that occur within your backend application. These events provide insight into how your application functions, what operations are being performed, and how different components interact with each other.

## Categories of Application Events

### 1. **Lifecycle Events**
Application startup, shutdown, and state transition events that track the overall health and status of your application.

```javascript
// Application startup logging
const logger = require('winston').createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'application.log' }),
    new winston.transports.Console()
  ]
});

class ApplicationLifecycleLogger {
  static logStartup(appConfig) {
    logger.info('Application starting up', {
      eventType: 'application_startup',
      timestamp: new Date().toISOString(),
      
      // Application information
      applicationName: appConfig.name,
      version: appConfig.version,
      environment: process.env.NODE_ENV || 'development',
      
      // Runtime environment
      nodeVersion: process.version,
      platform: process.platform,
      architecture: process.arch,
      processId: process.pid,
      
      // Configuration details
      port: appConfig.port,
      database: appConfig.database.host,
      logLevel: appConfig.logLevel,
      
      // Resource information
      memoryUsage: process.memoryUsage(),
      uptime: process.uptime(),
      
      // Dependencies
      dependencies: Object.keys(require('../../package.json').dependencies)
    });
  }
  
  static logShutdown(reason, graceful = true) {
    const shutdownEvent = {
      eventType: 'application_shutdown',
      timestamp: new Date().toISOString(),
      
      // Shutdown details
      reason,
      graceful,
      uptime: process.uptime(),
      
      // Final resource usage
      memoryUsage: process.memoryUsage(),
      cpuUsage: process.cpuUsage(),
      
      // Active connections
      activeConnections: this.getActiveConnections(),
      pendingOperations: this.getPendingOperations()
    };
    
    if (graceful) {
      logger.info('Application shutting down gracefully', shutdownEvent);
    } else {
      logger.error('Application shutting down unexpectedly', shutdownEvent);
    }
  }
  
  static logConfigurationChange(changes, initiator) {
    logger.warn('Application configuration changed', {
      eventType: 'configuration_change',
      timestamp: new Date().toISOString(),
      
      // Change details
      changes,
      changedBy: initiator.userId,
      initiatorRole: initiator.role,
      
      // Change metadata
      changeReason: changes.reason,
      approvalRequired: changes.requiresApproval,
      backupCreated: changes.backupConfig,
      
      // Impact assessment
      affectedComponents: this.analyzeConfigImpact(changes),
      restartRequired: changes.requiresRestart,
      
      // Audit information
      previousValues: changes.previousValues,
      newValues: changes.newValues
    });
  }
}
```

### 2. **Service Operation Events**
Events that track the core business operations and service functionalities within your application.

```javascript
// Service operation logging
class ServiceOperationLogger {
  constructor(serviceName, logger) {
    this.serviceName = serviceName;
    this.logger = logger.child({ service: serviceName });
  }
  
  logServiceOperation(operation, context, result) {
    const operationEvent = {
      eventType: 'service_operation',
      timestamp: new Date().toISOString(),
      
      // Operation details
      serviceName: this.serviceName,
      operation: operation.name,
      operationType: operation.type, // 'create', 'read', 'update', 'delete', 'process'
      
      // Context information
      requestId: context.requestId,
      userId: context.userId,
      sessionId: context.sessionId,
      correlationId: context.correlationId,
      
      // Operation parameters
      parameters: this.sanitizeParameters(operation.parameters),
      inputValidation: operation.inputValidation,
      
      // Execution details
      startTime: operation.startTime,
      endTime: operation.endTime,
      duration: operation.endTime - operation.startTime,
      
      // Result information
      success: result.success,
      resultSize: result.data ? JSON.stringify(result.data).length : 0,
      recordsAffected: result.recordsAffected,
      
      // Resource usage
      memoryUsed: result.memoryUsed,
      cpuTime: result.cpuTime,
      
      // Business metrics
      businessValue: operation.businessValue,
      customerImpact: operation.customerImpact
    };
    
    if (result.success) {
      this.logger.info('Service operation completed', operationEvent);
    } else {
      this.logger.error('Service operation failed', {
        ...operationEvent,
        error: result.error,
        errorCode: result.errorCode,
        stackTrace: result.stackTrace
      });
    }
    
    // Track slow operations
    if (operationEvent.duration > 5000) { // > 5 seconds
      this.logger.warn('Slow service operation detected', {
        ...operationEvent,
        performanceAlert: true,
        slowOperationThreshold: 5000
      });
    }
  }
  
  logBatchOperation(batchInfo, items, results) {
    const batchEvent = {
      eventType: 'batch_operation',
      timestamp: new Date().toISOString(),
      
      // Batch details
      batchId: batchInfo.id,
      batchType: batchInfo.type,
      totalItems: items.length,
      
      // Processing results
      successfulItems: results.successful.length,
      failedItems: results.failed.length,
      skippedItems: results.skipped.length,
      
      // Timing information
      startTime: batchInfo.startTime,
      endTime: batchInfo.endTime,
      totalDuration: batchInfo.endTime - batchInfo.startTime,
      averageItemTime: (batchInfo.endTime - batchInfo.startTime) / items.length,
      
      // Resource utilization
      peakMemoryUsage: batchInfo.peakMemoryUsage,
      totalCpuTime: batchInfo.totalCpuTime,
      
      // Error analysis
      errorDistribution: this.analyzeErrors(results.failed),
      retryableErrors: results.failed.filter(f => f.retryable).length,
      
      // Business impact
      businessImpact: batchInfo.businessImpact,
      affectedCustomers: batchInfo.affectedCustomers
    };
    
    if (results.failed.length === 0) {
      this.logger.info('Batch operation completed successfully', batchEvent);
    } else if (results.successful.length > results.failed.length) {
      this.logger.warn('Batch operation completed with some failures', batchEvent);
    } else {
      this.logger.error('Batch operation failed for majority of items', batchEvent);
    }
  }
}
```

### 3. **Integration Events**
Events that track interactions with external systems, APIs, databases, and third-party services.

```javascript
// External integration logging
class IntegrationEventLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'integration' });
  }
  
  logExternalAPICall(apiCall, response) {
    const integrationEvent = {
      eventType: 'external_api_call',
      timestamp: new Date().toISOString(),
      
      // API details
      serviceName: apiCall.serviceName,
      endpoint: apiCall.endpoint,
      method: apiCall.method,
      apiVersion: apiCall.version,
      
      // Request information
      requestId: apiCall.requestId,
      correlationId: apiCall.correlationId,
      requestSize: apiCall.requestSize,
      
      // Authentication
      authMethod: apiCall.authMethod,
      apiKeyUsed: apiCall.apiKeyUsed ? 'yes' : 'no',
      
      // Response details
      statusCode: response.statusCode,
      responseSize: response.responseSize,
      responseTime: response.responseTime,
      
      // Success/failure analysis
      success: response.statusCode >= 200 && response.statusCode < 300,
      retryAttempt: apiCall.retryAttempt || 0,
      
      // Rate limiting information
      rateLimitRemaining: response.headers['x-rate-limit-remaining'],
      rateLimitReset: response.headers['x-rate-limit-reset'],
      
      // Circuit breaker state
      circuitBreakerState: apiCall.circuitBreakerState,
      
      // Business context
      businessOperation: apiCall.businessOperation,
      criticalPath: apiCall.criticalPath
    };
    
    // Log based on response status
    if (response.statusCode >= 200 && response.statusCode < 300) {
      this.logger.info('External API call successful', integrationEvent);
    } else if (response.statusCode >= 400 && response.statusCode < 500) {
      this.logger.warn('External API call client error', integrationEvent);
    } else if (response.statusCode >= 500) {
      this.logger.error('External API call server error', integrationEvent);
    }
    
    // Alert on slow responses
    if (response.responseTime > 10000) { // > 10 seconds
      this.logger.warn('Slow external API response', {
        ...integrationEvent,
        slowResponseAlert: true,
        slowResponseThreshold: 10000
      });
    }
  }
  
  logDatabaseOperation(operation, result) {
    const dbEvent = {
      eventType: 'database_operation',
      timestamp: new Date().toISOString(),
      
      // Database details
      database: operation.database,
      collection: operation.collection || operation.table,
      operationType: operation.type, // 'query', 'insert', 'update', 'delete', 'transaction'
      
      // Query information
      queryType: operation.queryType,
      queryComplexity: operation.complexity,
      indexesUsed: operation.indexesUsed,
      
      // Performance metrics
      executionTime: result.executionTime,
      recordsExamined: result.recordsExamined,
      recordsReturned: result.recordsReturned,
      
      // Resource usage
      memoryUsage: result.memoryUsage,
      cpuTime: result.cpuTime,
      ioOperations: result.ioOperations,
      
      // Transaction details
      transactionId: operation.transactionId,
      isolationLevel: operation.isolationLevel,
      
      // Connection information
      connectionPool: operation.connectionPool,
      activeConnections: operation.activeConnections,
      
      // Result analysis
      success: result.success,
      recordsAffected: result.recordsAffected,
      warningsCount: result.warnings?.length || 0
    };
    
    if (result.success) {
      this.logger.info('Database operation completed', dbEvent);
    } else {
      this.logger.error('Database operation failed', {
        ...dbEvent,
        error: result.error,
        sqlState: result.sqlState
      });
    }
    
    // Performance warnings
    if (result.executionTime > 1000) { // > 1 second
      this.logger.warn('Slow database query detected', {
        ...dbEvent,
        performanceWarning: true,
        slowQueryThreshold: 1000
      });
    }
  }
}
```

### 4. **Workflow and Process Events**
Events that track multi-step processes, workflows, and business logic execution.

```javascript
// Workflow and process logging
class WorkflowEventLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'workflow' });
  }
  
  logWorkflowStart(workflow, context) {
    const workflowEvent = {
      eventType: 'workflow_started',
      timestamp: new Date().toISOString(),
      
      // Workflow identification
      workflowId: workflow.id,
      workflowName: workflow.name,
      workflowVersion: workflow.version,
      instanceId: workflow.instanceId,
      
      // Context information
      initiatedBy: context.userId,
      initiatorRole: context.userRole,
      triggerEvent: context.triggerEvent,
      
      // Workflow configuration
      totalSteps: workflow.steps.length,
      estimatedDuration: workflow.estimatedDuration,
      priority: workflow.priority,
      
      // Input parameters
      inputParameters: this.sanitizeWorkflowInputs(workflow.inputs),
      
      // Business context
      businessProcess: workflow.businessProcess,
      customerImpact: workflow.customerImpact,
      complianceRequired: workflow.complianceRequired
    };
    
    this.logger.info('Workflow started', workflowEvent);
  }
  
  logWorkflowStep(workflow, step, result) {
    const stepEvent = {
      eventType: 'workflow_step_completed',
      timestamp: new Date().toISOString(),
      
      // Workflow context
      workflowId: workflow.id,
      instanceId: workflow.instanceId,
      
      // Step details
      stepId: step.id,
      stepName: step.name,
      stepType: step.type,
      stepOrder: step.order,
      
      // Execution details
      startTime: step.startTime,
      endTime: step.endTime,
      duration: step.endTime - step.startTime,
      
      // Result information
      success: result.success,
      outputData: this.sanitizeStepOutputs(result.data),
      
      // Decision points
      conditions: step.conditions,
      nextStep: result.nextStep,
      branchTaken: result.branchTaken,
      
      // Error handling
      retryCount: step.retryCount || 0,
      errorHandling: step.errorHandling,
      
      // Resource usage
      resourcesUsed: result.resourcesUsed,
      externalCallsMade: result.externalCallsMade
    };
    
    if (result.success) {
      this.logger.info('Workflow step completed', stepEvent);
    } else {
      this.logger.error('Workflow step failed', {
        ...stepEvent,
        error: result.error,
        failureReason: result.failureReason
      });
    }
  }
  
  logWorkflowCompletion(workflow, finalResult) {
    const completionEvent = {
      eventType: 'workflow_completed',
      timestamp: new Date().toISOString(),
      
      // Workflow identification
      workflowId: workflow.id,
      instanceId: workflow.instanceId,
      
      // Completion details
      success: finalResult.success,
      completionTime: finalResult.completionTime,
      totalDuration: finalResult.totalDuration,
      
      // Execution summary
      stepsCompleted: finalResult.stepsCompleted,
      stepsFailed: finalResult.stepsFailed,
      stepsSkipped: finalResult.stepsSkipped,
      
      // Final outputs
      finalOutputs: this.sanitizeWorkflowOutputs(finalResult.outputs),
      
      // Performance metrics
      averageStepDuration: finalResult.totalDuration / finalResult.stepsCompleted,
      peakResourceUsage: finalResult.peakResourceUsage,
      
      // Business outcomes
      businessObjectivesMet: finalResult.businessObjectivesMet,
      customerSatisfaction: finalResult.customerSatisfaction,
      
      // Compliance and audit
      complianceChecksPassed: finalResult.complianceChecksPassed,
      auditTrailGenerated: finalResult.auditTrailGenerated
    };
    
    if (finalResult.success) {
      this.logger.info('Workflow completed successfully', completionEvent);
    } else {
      this.logger.error('Workflow failed', completionEvent);
    }
  }
}
```

## Best Practices for Application Event Logging

### 1. **Event Classification**
- Use consistent event types and naming conventions
- Include sufficient context for event correlation
- Maintain event hierarchy and relationships
- Tag events with business significance

### 2. **Data Consistency**
- Standardize timestamp formats across all events
- Use consistent field naming conventions
- Maintain data type consistency
- Include version information for event schemas

### 3. **Performance Considerations**
- Log asynchronously for high-volume operations
- Use structured logging for better parsing
- Implement sampling for very frequent events
- Balance detail with performance impact

### 4. **Contextual Information**
- Include correlation IDs for request tracking
- Add user and session context where relevant
- Provide enough context for debugging
- Link related events together

### 5. **Business Value**
- Align logging with business objectives
- Track key business metrics through events
- Enable business analytics through event data
- Support compliance and audit requirements

---

**Previous**: [1.2.5 Security Incident Investigation](../1.2_Why_Logging_Matters_in_Backend_Development/1.2.5_Security_Incident_Investigation.md)  
**Next**: [1.3.2 User Actions](./1.3.2_User_Actions.md)
