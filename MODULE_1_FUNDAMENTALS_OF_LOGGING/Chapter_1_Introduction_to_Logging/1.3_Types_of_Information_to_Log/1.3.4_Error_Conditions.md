# 1.3.4 Error Conditions

## Understanding Error Condition Logging

Error condition logging is one of the most critical aspects of backend logging. It involves capturing, categorizing, and analyzing various types of errors, exceptions, and failure scenarios that occur within your application and infrastructure. Effective error logging enables rapid debugging, proactive issue resolution, and system reliability improvement.

## Categories of Error Conditions

### 1. **Application Errors and Exceptions**
Capturing runtime errors, unhandled exceptions, and application-specific error conditions.

```javascript
// Comprehensive application error logging
class ApplicationErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'application-errors' });
    this.errorPatterns = new Map();
    this.errorFrequency = new Map();
    this.criticalErrors = new Set();
  }
  
  logApplicationError(error, context, severity = 'error') {
    const errorId = this.generateErrorId();
    
    const errorEvent = {
      eventType: 'application_error',
      timestamp: new Date().toISOString(),
      errorId,
      
      // Error classification
      errorType: error.constructor.name,
      errorCategory: this.categorizeError(error),
      severity, // 'low', 'medium', 'high', 'critical'
      errorCode: error.code || 'UNKNOWN',
      
      // Error details
      message: error.message,
      stackTrace: error.stack,
      fileName: this.extractFileName(error.stack),
      lineNumber: this.extractLineNumber(error.stack),
      functionName: this.extractFunctionName(error.stack),
      
      // Context information
      requestId: context.requestId,
      userId: context.userId,
      sessionId: context.sessionId,
      correlationId: context.correlationId,
      
      // Application context
      applicationName: context.applicationName,
      applicationVersion: context.applicationVersion,
      environment: process.env.NODE_ENV,
      hostname: require('os').hostname(),
      
      // Request context (if applicable)
      httpMethod: context.httpMethod,
      url: context.url,
      userAgent: context.userAgent,
      sourceIP: context.sourceIP,
      
      // System state
      memoryUsage: process.memoryUsage(),
      cpuUsage: process.cpuUsage(),
      uptime: process.uptime(),
      
      // Error context
      inputParameters: this.sanitizeParameters(context.inputParameters),
      systemState: context.systemState,
      externalDependencies: context.externalDependencies,
      
      // Error history
      firstOccurrence: this.getFirstOccurrence(error.message),
      occurrenceCount: this.getOccurrenceCount(error.message),
      lastOccurrence: this.getLastOccurrence(error.message),
      
      // Impact assessment
      userImpact: this.assessUserImpact(error, context),
      businessImpact: this.assessBusinessImpact(error, context),
      affectedFeatures: this.getAffectedFeatures(error, context),
      
      // Recovery information
      recoveryAction: this.getRecoveryAction(error),
      retryable: this.isRetryable(error),
      automaticRecovery: this.hasAutomaticRecovery(error)
    };
    
    // Update error tracking
    this.updateErrorTracking(error.message, errorEvent);
    
    // Log with appropriate level
    if (severity === 'critical' || this.isCriticalError(error)) {
      this.logger.error('Critical application error', errorEvent);
      this.triggerCriticalErrorAlert(errorEvent);
    } else if (severity === 'high' || this.isHighSeverityError(error)) {
      this.logger.error('High severity application error', errorEvent);
    } else if (severity === 'medium') {
      this.logger.warn('Medium severity application error', errorEvent);
    } else {
      this.logger.info('Low severity application error', errorEvent);
    }
    
    // Pattern analysis for recurring errors
    if (errorEvent.occurrenceCount > 10) {
      this.analyzeErrorPattern(errorEvent);
    }
    
    return errorEvent;
  }
  
  logUnhandledException(error, context) {
    const unhandledExceptionEvent = {
      eventType: 'unhandled_exception',
      timestamp: new Date().toISOString(),
      
      // Exception details
      exceptionType: error.constructor.name,
      message: error.message,
      stackTrace: error.stack,
      
      // Process information
      processId: process.pid,
      processTitle: process.title,
      processArgv: process.argv,
      processEnv: this.sanitizeEnvironment(process.env),
      
      // Memory and resource state
      memoryUsage: process.memoryUsage(),
      resourceUsage: process.resourceUsage(),
      
      // Active handles and requests
      activeHandles: process._getActiveHandles().length,
      activeRequests: process._getActiveRequests().length,
      
      // Context information
      context: this.sanitizeContext(context),
      
      // System state at time of crash
      uptime: process.uptime(),
      loadAverage: require('os').loadavg(),
      freeMemory: require('os').freemem(),
      
      // Application state
      lastRequestTime: this.getLastRequestTime(),
      activeConnections: this.getActiveConnections(),
      pendingOperations: this.getPendingOperations(),
      
      // Recovery information
      processWillExit: true,
      gracefulShutdown: false,
      restartAttempted: false
    };
    
    this.logger.fatal('Unhandled exception - process terminating', unhandledExceptionEvent);
    
    // Attempt graceful shutdown
    this.attemptGracefulShutdown(unhandledExceptionEvent);
  }
  
  logValidationError(validationResults, context) {
    const validationErrorEvent = {
      eventType: 'validation_error',
      timestamp: new Date().toISOString(),
      
      // Validation context
      validationType: validationResults.type, // 'input', 'business_rule', 'schema', 'constraint'
      validationTarget: validationResults.target,
      
      // Error details
      errors: validationResults.errors.map(error => ({
        field: error.field,
        value: this.sanitizeValue(error.value),
        rule: error.rule,
        message: error.message,
        severity: error.severity,
        errorCode: error.code
      })),
      
      // Request context
      requestId: context.requestId,
      userId: context.userId,
      endpoint: context.endpoint,
      httpMethod: context.httpMethod,
      
      // Input information
      inputSize: context.inputSize,
      inputType: context.inputType,
      inputSource: context.inputSource,
      
      // Validation summary
      totalErrors: validationResults.errors.length,
      criticalErrors: validationResults.errors.filter(e => e.severity === 'critical').length,
      warningCount: validationResults.errors.filter(e => e.severity === 'warning').length,
      
      // Business impact
      operationBlocked: validationResults.blocked,
      userExperience: validationResults.userExperience,
      dataIntegrity: validationResults.dataIntegrity,
      
      // Recovery suggestions
      userGuidance: validationResults.userGuidance,
      correctiveActions: validationResults.correctiveActions,
      retryPossible: validationResults.retryPossible
    };
    
    if (validationErrorEvent.criticalErrors > 0) {
      this.logger.error('Critical validation errors detected', validationErrorEvent);
    } else {
      this.logger.warn('Validation errors detected', validationErrorEvent);
    }
  }
}
```

### 2. **Integration and External Service Errors**
Capturing failures in external API calls, database connections, and third-party service integrations.

```javascript
// External service and integration error logging
class IntegrationErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'integration-errors' });
    this.serviceHealth = new Map();
    this.circuitBreakerStates = new Map();
  }
  
  logExternalServiceError(serviceCall, error, context) {
    const serviceErrorEvent = {
      eventType: 'external_service_error',
      timestamp: new Date().toISOString(),
      
      // Service identification
      serviceName: serviceCall.serviceName,
      serviceEndpoint: serviceCall.endpoint,
      serviceVersion: serviceCall.version,
      serviceProvider: serviceCall.provider,
      
      // Request details
      requestId: context.requestId,
      correlationId: context.correlationId,
      httpMethod: serviceCall.method,
      requestUrl: serviceCall.url,
      requestHeaders: this.sanitizeHeaders(serviceCall.headers),
      requestSize: serviceCall.requestSize,
      timeout: serviceCall.timeout,
      
      // Error information
      errorType: error.type, // 'timeout', 'connection', 'http_error', 'parse_error', 'auth_error'
      errorCode: error.code,
      errorMessage: error.message,
      httpStatusCode: error.statusCode,
      
      // Response details (if any)
      responseHeaders: this.sanitizeHeaders(error.responseHeaders),
      responseSize: error.responseSize,
      responseTime: error.responseTime,
      
      // Retry information
      retryAttempt: serviceCall.retryAttempt || 0,
      maxRetries: serviceCall.maxRetries,
      retryDelay: serviceCall.retryDelay,
      retryStrategy: serviceCall.retryStrategy,
      
      // Circuit breaker information
      circuitBreakerState: this.getCircuitBreakerState(serviceCall.serviceName),
      failureCount: this.getFailureCount(serviceCall.serviceName),
      lastSuccessTime: this.getLastSuccessTime(serviceCall.serviceName),
      
      // Service health context
      serviceHealth: this.getServiceHealth(serviceCall.serviceName),
      recentFailures: this.getRecentFailures(serviceCall.serviceName, '5m'),
      averageResponseTime: this.getAverageResponseTime(serviceCall.serviceName, '1h'),
      
      // Network context
      networkLatency: context.networkLatency,
      dnsResolutionTime: context.dnsResolutionTime,
      connectionEstablishTime: context.connectionEstablishTime,
      
      // Business context
      businessOperation: context.businessOperation,
      criticalPath: context.criticalPath,
      fallbackAvailable: context.fallbackAvailable,
      
      // Impact assessment
      userImpact: this.assessUserImpact(serviceCall, error),
      businessImpact: this.assessBusinessImpact(serviceCall, error),
      downstreamEffects: this.getDownstreamEffects(serviceCall.serviceName),
      
      // Recovery actions
      recoveryAction: this.getRecoveryAction(serviceCall, error),
      fallbackTriggered: context.fallbackTriggered,
      manualInterventionRequired: this.requiresManualIntervention(error)
    };
    
    // Update service health tracking
    this.updateServiceHealth(serviceCall.serviceName, serviceErrorEvent);
    
    // Log based on error severity and business impact
    if (error.type === 'timeout' || error.statusCode >= 500) {
      this.logger.error('External service error', serviceErrorEvent);
    } else if (error.statusCode >= 400) {
      this.logger.warn('External service client error', serviceErrorEvent);
    } else {
      this.logger.info('External service error', serviceErrorEvent);
    }
    
    // Trigger circuit breaker logic
    if (this.shouldTriggerCircuitBreaker(serviceCall.serviceName, error)) {
      this.triggerCircuitBreaker(serviceCall.serviceName, serviceErrorEvent);
    }
  }
  
  logDatabaseError(dbOperation, error, context) {
    const dbErrorEvent = {
      eventType: 'database_error',
      timestamp: new Date().toISOString(),
      
      // Database identification
      database: dbOperation.database,
      host: dbOperation.host,
      port: dbOperation.port,
      databaseType: dbOperation.type, // 'mysql', 'postgresql', 'mongodb', 'redis'
      
      // Operation details
      operationType: dbOperation.type, // 'query', 'insert', 'update', 'delete', 'transaction'
      tableName: dbOperation.table || dbOperation.collection,
      queryType: dbOperation.queryType,
      
      // Error information
      errorType: error.type, // 'connection', 'syntax', 'constraint', 'timeout', 'deadlock'
      errorCode: error.code,
      errorMessage: error.message,
      sqlState: error.sqlState,
      
      // Query information (sanitized)
      queryHash: this.hashQuery(dbOperation.query),
      queryLength: dbOperation.query?.length,
      queryComplexity: dbOperation.complexity,
      parametersCount: dbOperation.parameters?.length,
      
      // Performance context
      executionTime: dbOperation.executionTime,
      rowsExamined: dbOperation.rowsExamined,
      rowsAffected: dbOperation.rowsAffected,
      indexesUsed: dbOperation.indexesUsed,
      
      // Connection context
      connectionId: dbOperation.connectionId,
      connectionPool: dbOperation.connectionPool,
      activeConnections: this.getActiveConnections(dbOperation.database),
      maxConnections: this.getMaxConnections(dbOperation.database),
      
      // Transaction context
      transactionId: dbOperation.transactionId,
      isolationLevel: dbOperation.isolationLevel,
      lockWaitTime: dbOperation.lockWaitTime,
      
      // Context information
      requestId: context.requestId,
      userId: context.userId,
      applicationOperation: context.operation,
      
      // Database health
      databaseHealth: this.getDatabaseHealth(dbOperation.database),
      replicationLag: this.getReplicationLag(dbOperation.database),
      lockContentions: this.getLockContentions(dbOperation.database),
      
      // Impact assessment
      dataIntegrityRisk: this.assessDataIntegrityRisk(error),
      operationCriticality: context.criticality,
      rollbackRequired: this.requiresRollback(error),
      
      // Recovery information
      retryable: this.isRetryableDBError(error),
      recoveryAction: this.getDBRecoveryAction(error),
      maintenanceRequired: this.requiresMaintenance(error)
    };
    
    // Log based on error severity
    if (error.type === 'connection' || error.type === 'timeout') {
      this.logger.error('Database connectivity error', dbErrorEvent);
    } else if (error.type === 'deadlock' || error.type === 'constraint') {
      this.logger.warn('Database operation error', dbErrorEvent);
    } else {
      this.logger.info('Database error', dbErrorEvent);
    }
    
    // Alert on critical database issues
    if (this.isCriticalDBError(error)) {
      this.triggerDatabaseAlert(dbErrorEvent);
    }
  }
  
  logMessageQueueError(mqOperation, error, context) {
    const mqErrorEvent = {
      eventType: 'message_queue_error',
      timestamp: new Date().toISOString(),
      
      // Message queue identification
      queueSystem: mqOperation.system, // 'rabbitmq', 'kafka', 'redis', 'sqs', 'servicebus'
      queueName: mqOperation.queueName,
      topicName: mqOperation.topicName,
      brokerHost: mqOperation.brokerHost,
      
      // Operation details
      operationType: mqOperation.type, // 'publish', 'consume', 'subscribe', 'acknowledge'
      messageId: mqOperation.messageId,
      messageSize: mqOperation.messageSize,
      messageType: mqOperation.messageType,
      
      // Error information
      errorType: error.type, // 'connection', 'timeout', 'serialization', 'authentication', 'quota'
      errorCode: error.code,
      errorMessage: error.message,
      brokerErrorCode: error.brokerErrorCode,
      
      // Message context
      messageHeaders: this.sanitizeHeaders(mqOperation.headers),
      messageProperties: mqOperation.properties,
      deliveryAttempt: mqOperation.deliveryAttempt,
      maxDeliveryAttempts: mqOperation.maxDeliveryAttempts,
      
      // Queue health
      queueDepth: this.getQueueDepth(mqOperation.queueName),
      consumerCount: this.getConsumerCount(mqOperation.queueName),
      messageRate: this.getMessageRate(mqOperation.queueName),
      deadLetterCount: this.getDeadLetterCount(mqOperation.queueName),
      
      // Context information
      requestId: context.requestId,
      correlationId: context.correlationId,
      businessProcess: context.businessProcess,
      
      // Impact assessment
      messageImportance: mqOperation.importance,
      businessImpact: this.assessMQBusinessImpact(mqOperation, error),
      downstreamEffects: this.getMQDownstreamEffects(mqOperation),
      
      // Recovery information
      retryable: this.isRetryableMQError(error),
      deadLetterQueue: mqOperation.deadLetterQueue,
      manualRecoveryRequired: this.requiresManualMQRecovery(error),
      
      // Performance metrics
      connectionLatency: context.connectionLatency,
      publishLatency: context.publishLatency,
      acknowledgmentTime: context.acknowledgmentTime
    };
    
    // Log based on error impact
    if (error.type === 'connection' || mqOperation.importance === 'critical') {
      this.logger.error('Message queue error', mqErrorEvent);
    } else {
      this.logger.warn('Message queue error', mqErrorEvent);
    }
    
    // Handle dead letter queue routing
    if (mqOperation.deliveryAttempt >= mqOperation.maxDeliveryAttempts) {
      this.routeToDeadLetterQueue(mqOperation, mqErrorEvent);
    }
  }
}
```

### 3. **Security and Authentication Errors**
Capturing security-related errors, authentication failures, and authorization violations.

```javascript
// Security and authentication error logging
class SecurityErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'security-errors' });
    this.securityIncidents = new Map();
    this.threatDetection = new Map();
  }
  
  logAuthenticationError(authAttempt, error, context) {
    const authErrorEvent = {
      eventType: 'authentication_error',
      timestamp: new Date().toISOString(),
      
      // Authentication context
      authMethod: authAttempt.method, // 'password', 'oauth', 'saml', 'certificate', 'mfa'
      authProvider: authAttempt.provider,
      username: this.hashUsername(authAttempt.username),
      
      // Error details
      errorType: error.type, // 'invalid_credentials', 'account_locked', 'expired', 'suspended'
      errorCode: error.code,
      errorMessage: error.message,
      failureReason: error.reason,
      
      // Request context
      sourceIP: context.sourceIP,
      userAgent: context.userAgent,
      deviceFingerprint: context.deviceFingerprint,
      geoLocation: context.geoLocation,
      
      // Security analysis
      riskScore: this.calculateAuthRiskScore(authAttempt, context),
      threatIndicators: this.getThreatIndicators(context),
      suspiciousActivity: this.detectSuspiciousActivity(authAttempt, context),
      
      // Historical context
      recentFailures: this.getRecentAuthFailures(authAttempt.username),
      firstFailureTime: this.getFirstFailureTime(authAttempt.username),
      lastSuccessfulAuth: this.getLastSuccessfulAuth(authAttempt.username),
      
      // Account security
      accountStatus: this.getAccountStatus(authAttempt.username),
      lockoutThreshold: this.getLockoutThreshold(),
      lockoutDuration: this.getLockoutDuration(),
      passwordExpiry: this.getPasswordExpiry(authAttempt.username),
      
      // Network security
      vpnDetected: context.vpnDetected,
      proxyDetected: context.proxyDetected,
      knownMaliciousIP: this.isKnownMaliciousIP(context.sourceIP),
      ipReputation: this.getIPReputation(context.sourceIP),
      
      // Behavioral analysis
      typicalLoginTime: this.getTypicalLoginTime(authAttempt.username),
      typicalLocation: this.getTypicalLocation(authAttempt.username),
      deviceRecognition: this.isRecognizedDevice(authAttempt.username, context.deviceFingerprint),
      
      // Response actions
      accountLocked: error.accountLocked,
      securityAlert: error.securityAlert,
      additionalVerificationRequired: error.additionalVerification,
      
      // Compliance context
      complianceFrameworks: ['SOX', 'PCI-DSS', 'HIPAA'],
      auditRequired: true,
      incidentResponse: this.requiresIncidentResponse(error, context)
    };
    
    // Update failure tracking
    this.updateAuthFailureTracking(authAttempt.username, context.sourceIP);
    
    // Log based on risk level
    if (authErrorEvent.riskScore > 0.8 || authErrorEvent.suspiciousActivity.length > 0) {
      this.logger.error('High-risk authentication failure', authErrorEvent);
      this.triggerSecurityAlert(authErrorEvent);
    } else if (authErrorEvent.recentFailures > 3) {
      this.logger.warn('Repeated authentication failures', authErrorEvent);
    } else {
      this.logger.info('Authentication failure', authErrorEvent);
    }
  }
  
  logAuthorizationError(authzAttempt, error, context) {
    const authzErrorEvent = {
      eventType: 'authorization_error',
      timestamp: new Date().toISOString(),
      
      // User context
      userId: context.userId,
      username: context.username,
      userRole: context.userRole,
      userGroups: context.userGroups,
      
      // Resource context
      resourceType: authzAttempt.resourceType,
      resourceId: authzAttempt.resourceId,
      resourceOwner: authzAttempt.resourceOwner,
      resourceClassification: authzAttempt.resourceClassification,
      
      // Permission context
      requestedAction: authzAttempt.action, // 'read', 'write', 'delete', 'execute', 'admin'
      requiredPermissions: authzAttempt.requiredPermissions,
      userPermissions: context.userPermissions,
      permissionGap: this.calculatePermissionGap(authzAttempt.requiredPermissions, context.userPermissions),
      
      // Error details
      errorType: error.type, // 'insufficient_permissions', 'resource_not_found', 'access_denied'
      errorCode: error.code,
      errorMessage: error.message,
      
      // Context information
      requestId: context.requestId,
      sessionId: context.sessionId,
      sourceIP: context.sourceIP,
      
      // Business context
      businessJustification: authzAttempt.businessJustification,
      emergencyAccess: authzAttempt.emergencyAccess,
      dataClassification: authzAttempt.dataClassification,
      
      // Security analysis
      privilegeEscalation: this.detectPrivilegeEscalation(authzAttempt, context),
      accessPattern: this.analyzeAccessPattern(context.userId, authzAttempt),
      anomalousRequest: this.isAnomalousRequest(authzAttempt, context),
      
      // Compliance context
      complianceImpact: this.assessComplianceImpact(authzAttempt),
      auditTrailRequired: true,
      dataGovernance: this.getDataGovernanceRules(authzAttempt.resourceType),
      
      // Response information
      fallbackOptions: this.getFallbackOptions(authzAttempt),
      approvalWorkflow: this.getApprovalWorkflow(authzAttempt),
      temporaryAccess: this.canGrantTemporaryAccess(authzAttempt)
    };
    
    // Log based on security significance
    if (authzErrorEvent.privilegeEscalation || authzErrorEvent.anomalousRequest) {
      this.logger.error('Suspicious authorization attempt', authzErrorEvent);
      this.triggerSecurityIncident(authzErrorEvent);
    } else if (authzAttempt.resourceClassification === 'sensitive') {
      this.logger.warn('Unauthorized access to sensitive resource', authzErrorEvent);
    } else {
      this.logger.info('Authorization denied', authzErrorEvent);
    }
  }
  
  logSecurityViolation(violationType, details, context) {
    const securityViolationEvent = {
      eventType: 'security_violation',
      timestamp: new Date().toISOString(),
      
      // Violation details
      violationType, // 'injection_attempt', 'malicious_upload', 'rate_limit_abuse', 'data_exfiltration'
      severity: details.severity,
      confidence: details.confidence,
      
      // Attack information
      attackVector: details.attackVector,
      attackSignature: details.attackSignature,
      maliciousPayload: this.sanitizePayload(details.payload),
      threatCategory: details.threatCategory,
      
      // Source information
      sourceIP: context.sourceIP,
      userAgent: context.userAgent,
      userId: context.userId,
      sessionId: context.sessionId,
      
      // Target information
      targetEndpoint: details.targetEndpoint,
      targetParameter: details.targetParameter,
      targetSystem: details.targetSystem,
      
      // Detection information
      detectionMethod: details.detectionMethod, // 'signature', 'anomaly', 'rule', 'ml'
      detectionRule: details.detectionRule,
      detectionTime: details.detectionTime,
      
      // Threat intelligence
      threatIntelligence: {
        knownThreatActor: this.getKnownThreatActor(context.sourceIP),
        threatCampaign: this.getThreatCampaign(details),
        iocMatches: this.getIOCMatches(details),
        cveReferences: details.cveReferences
      },
      
      // Impact assessment
      potentialImpact: details.potentialImpact,
      dataAtRisk: details.dataAtRisk,
      systemsAffected: details.systemsAffected,
      businessImpact: details.businessImpact,
      
      // Response actions
      automaticBlocking: details.automaticBlocking,
      responseActions: details.responseActions,
      alertsTriggered: details.alertsTriggered,
      investigationRequired: details.investigationRequired,
      
      // Context information
      requestHeaders: this.sanitizeHeaders(context.headers),
      networkContext: context.networkContext,
      geolocation: context.geolocation,
      
      // Forensic information
      forensicEvidence: details.forensicEvidence,
      evidencePreserved: details.evidencePreserved,
      chainOfCustody: details.chainOfCustody
    };
    
    // Always log security violations as errors or critical
    if (details.severity === 'critical' || details.confidence > 0.9) {
      this.logger.error('Critical security violation detected', securityViolationEvent);
      this.triggerSecurityIncident(securityViolationEvent);
    } else {
      this.logger.error('Security violation detected', securityViolationEvent);
    }
    
    // Trigger automated response
    if (details.automaticBlocking) {
      this.triggerAutomaticBlocking(context.sourceIP, securityViolationEvent);
    }
  }
}
```

### 4. **Business Logic and Workflow Errors**
Capturing errors in business processes, workflow failures, and data consistency issues.

```javascript
// Business logic and workflow error logging
class BusinessLogicErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'business-logic-errors' });
    this.workflowStates = new Map();
    this.businessRuleViolations = new Map();
  }
  
  logBusinessRuleViolation(rule, violation, context) {
    const ruleViolationEvent = {
      eventType: 'business_rule_violation',
      timestamp: new Date().toISOString(),
      
      // Rule identification
      ruleId: rule.id,
      ruleName: rule.name,
      ruleCategory: rule.category,
      ruleVersion: rule.version,
      
      // Violation details
      violationType: violation.type, // 'constraint', 'validation', 'policy', 'compliance'
      violationSeverity: violation.severity,
      violationMessage: violation.message,
      
      // Business context
      businessProcess: context.businessProcess,
      workflowId: context.workflowId,
      transactionId: context.transactionId,
      
      // Data context
      entityType: violation.entityType,
      entityId: violation.entityId,
      violatingData: this.sanitizeBusinessData(violation.data),
      expectedValues: violation.expectedValues,
      actualValues: violation.actualValues,
      
      // User context
      userId: context.userId,
      userRole: context.userRole,
      userDepartment: context.userDepartment,
      
      // Operation context
      operation: context.operation,
      operationParameters: this.sanitizeParameters(context.parameters),
      requestId: context.requestId,
      
      // Compliance context
      complianceFramework: rule.complianceFramework,
      regulatoryRequirement: rule.regulatoryRequirement,
      auditRequired: rule.auditRequired,
      
      // Impact assessment
      businessImpact: this.assessBusinessImpact(violation),
      customerImpact: this.assessCustomerImpact(violation),
      financialImpact: this.assessFinancialImpact(violation),
      complianceRisk: this.assessComplianceRisk(violation),
      
      // Resolution information
      resolutionRequired: violation.resolutionRequired,
      approvalNeeded: violation.approvalNeeded,
      escalationPath: violation.escalationPath,
      remedialActions: violation.remedialActions,
      
      // Historical context
      previousViolations: this.getPreviousViolations(rule.id, violation.entityId),
      patternDetected: this.detectViolationPattern(rule.id, context.userId),
      
      // System state
      systemLoad: this.getSystemLoad(),
      dataConsistencyCheck: this.performDataConsistencyCheck(violation.entityId)
    };
    
    // Log based on violation severity and compliance impact
    if (violation.severity === 'critical' || rule.complianceFramework.length > 0) {
      this.logger.error('Critical business rule violation', ruleViolationEvent);
      this.triggerComplianceAlert(ruleViolationEvent);
    } else if (violation.severity === 'high') {
      this.logger.warn('High-severity business rule violation', ruleViolationEvent);
    } else {
      this.logger.info('Business rule violation', ruleViolationEvent);
    }
    
    // Update violation tracking
    this.updateViolationTracking(rule.id, ruleViolationEvent);
  }
  
  logWorkflowError(workflow, step, error, context) {
    const workflowErrorEvent = {
      eventType: 'workflow_error',
      timestamp: new Date().toISOString(),
      
      // Workflow identification
      workflowId: workflow.id,
      workflowName: workflow.name,
      workflowVersion: workflow.version,
      instanceId: workflow.instanceId,
      
      // Step information
      stepId: step.id,
      stepName: step.name,
      stepType: step.type,
      stepOrder: step.order,
      
      // Error details
      errorType: error.type, // 'execution', 'timeout', 'dependency', 'validation', 'resource'
      errorCode: error.code,
      errorMessage: error.message,
      stackTrace: error.stackTrace,
      
      // Execution context
      executionStartTime: step.startTime,
      executionEndTime: step.endTime,
      executionDuration: step.endTime - step.startTime,
      retryAttempt: step.retryAttempt || 0,
      maxRetries: step.maxRetries,
      
      // Workflow state
      currentState: workflow.currentState,
      previousState: workflow.previousState,
      stepsCompleted: workflow.stepsCompleted,
      stepsRemaining: workflow.stepsRemaining,
      
      // Input/Output data
      stepInputs: this.sanitizeWorkflowData(step.inputs),
      stepOutputs: this.sanitizeWorkflowData(step.outputs),
      expectedOutputs: step.expectedOutputs,
      
      // Dependencies
      dependencyStatus: this.checkDependencyStatus(step.dependencies),
      externalServices: step.externalServices,
      resourceRequirements: step.resourceRequirements,
      
      // Business context
      businessProcess: workflow.businessProcess,
      businessValue: workflow.businessValue,
      customerImpact: workflow.customerImpact,
      priority: workflow.priority,
      
      // User context
      initiatedBy: workflow.initiatedBy,
      currentOwner: step.owner,
      stakeholders: workflow.stakeholders,
      
      // Recovery information
      rollbackRequired: this.requiresRollback(workflow, step, error),
      rollbackStrategy: step.rollbackStrategy,
      compensationRequired: this.requiresCompensation(workflow, step, error),
      
      // Impact assessment
      workflowImpact: this.assessWorkflowImpact(workflow, error),
      downstreamImpact: this.getDownstreamImpact(workflow, step),
      slaImpact: this.assessSLAImpact(workflow, error),
      
      // Resolution options
      retryable: this.isRetryableWorkflowError(error),
      skipPossible: this.canSkipStep(step, error),
      alternativeSteps: this.getAlternativeSteps(step),
      manualInterventionRequired: this.requiresManualIntervention(error)
    };
    
    // Update workflow state tracking
    this.updateWorkflowState(workflow.id, 'error', workflowErrorEvent);
    
    // Log based on error impact
    if (error.type === 'critical' || workflow.priority === 'high') {
      this.logger.error('Critical workflow error', workflowErrorEvent);
      this.triggerWorkflowAlert(workflowErrorEvent);
    } else if (workflowErrorEvent.retryAttempt >= 3) {
      this.logger.warn('Repeated workflow failures', workflowErrorEvent);
    } else {
      this.logger.info('Workflow step error', workflowErrorEvent);
    }
    
    // Trigger recovery mechanisms
    if (workflowErrorEvent.retryable && step.retryAttempt < step.maxRetries) {
      this.scheduleWorkflowRetry(workflow, step, workflowErrorEvent);
    }
  }
  
  logDataConsistencyError(consistencyCheck, error, context) {
    const consistencyErrorEvent = {
      eventType: 'data_consistency_error',
      timestamp: new Date().toISOString(),
      
      // Consistency check details
      checkId: consistencyCheck.id,
      checkType: consistencyCheck.type, // 'referential_integrity', 'data_validation', 'cross_system'
      checkName: consistencyCheck.name,
      checkFrequency: consistencyCheck.frequency,
      
      // Error details
      inconsistencyType: error.type, // 'orphaned_records', 'duplicate_keys', 'invalid_references', 'data_mismatch'
      severity: error.severity,
      errorCount: error.count,
      
      // Data context
      affectedTables: error.affectedTables,
      affectedRecords: error.affectedRecords,
      dataSource: error.dataSource,
      dataDestination: error.dataDestination,
      
      // Inconsistency details
      inconsistentData: this.sanitizeInconsistentData(error.data),
      expectedValues: error.expectedValues,
      actualValues: error.actualValues,
      
      // Detection information
      detectionMethod: consistencyCheck.method,
      detectionQuery: this.hashQuery(consistencyCheck.query),
      checkDuration: consistencyCheck.duration,
      
      // Business impact
      businessImpact: this.assessDataInconsistencyImpact(error),
      affectedProcesses: this.getAffectedProcesses(error.affectedTables),
      customerImpact: this.getCustomerImpact(error),
      
      // Resolution information
      autoRepairPossible: this.canAutoRepair(error),
      repairStrategy: this.getRepairStrategy(error),
      manualReviewRequired: this.requiresManualReview(error),
      dataBackupRequired: this.requiresDataBackup(error),
      
      // Historical context
      previousInconsistencies: this.getPreviousInconsistencies(consistencyCheck.id),
      trendAnalysis: this.analyzeTrend(consistencyCheck.id),
      
      // System context
      systemLoad: this.getSystemLoad(),
      replicationLag: this.getReplicationLag(),
      lastBackupTime: this.getLastBackupTime(),
      
      // Compliance implications
      complianceImpact: this.assessComplianceImpact(error),
      auditRequired: true,
      reportingRequired: this.requiresExternalReporting(error)
    };
    
    // Log based on severity and business impact
    if (error.severity === 'critical' || consistencyErrorEvent.customerImpact === 'high') {
      this.logger.error('Critical data consistency error', consistencyErrorEvent);
      this.triggerDataAlert(consistencyErrorEvent);
    } else if (error.severity === 'high') {
      this.logger.warn('Data consistency issue detected', consistencyErrorEvent);
    } else {
      this.logger.info('Data consistency check result', consistencyErrorEvent);
    }
    
    // Trigger automated repair if possible
    if (consistencyErrorEvent.autoRepairPossible) {
      this.triggerAutomatedRepair(error, consistencyErrorEvent);
    }
  }
}
```

## Best Practices for Error Condition Logging

### 1. **Comprehensive Error Capture**
- Log all error types: application, integration, security, and business logic
- Include sufficient context for debugging and root cause analysis
- Capture error trends and patterns for proactive issue resolution
- Maintain error correlation across distributed systems

### 2. **Error Classification and Severity**
- Implement consistent error categorization schemes
- Use appropriate log levels based on error impact
- Consider business impact when determining severity
- Enable escalation based on error patterns and frequency

### 3. **Security and Privacy**
- Sanitize sensitive data in error logs
- Implement secure error handling for security violations
- Maintain audit trails for compliance requirements
- Protect error logs with appropriate access controls

### 4. **Recovery and Resolution**
- Include recovery suggestions and next steps
- Enable automatic retry mechanisms where appropriate
- Provide clear escalation paths for critical errors
- Maintain incident response procedures

### 5. **Monitoring and Alerting**
- Set up real-time monitoring for critical errors
- Implement intelligent alerting to reduce noise
- Enable trend analysis for proactive issue detection
- Integrate with incident management systems

---

**Previous**: [1.3.3 System Events](./1.3.3_System_Events.md)  
**Next**: [1.3.5 Performance Metrics](./1.3.5_Performance_Metrics.md)
