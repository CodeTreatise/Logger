# 1.3.5 Performance Metrics

## Understanding Performance Metrics in Logging

Performance metrics logging involves capturing quantitative measurements that indicate how well your backend application and infrastructure are performing. These metrics are essential for identifying bottlenecks, optimizing resource usage, capacity planning, and ensuring optimal user experience through proactive performance management.

## Categories of Performance Metrics

### 1. **Application Performance Metrics**
Measuring response times, throughput, resource utilization, and application-specific performance indicators.

```javascript
// Application performance metrics logging
class ApplicationPerformanceLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'app-performance' });
    this.performanceBaselines = new Map();
    this.performanceThresholds = {
      responseTime: { warning: 1000, critical: 5000 }, // milliseconds
      throughput: { warning: 100, critical: 50 }, // requests per second
      errorRate: { warning: 1, critical: 5 }, // percentage
      cpuUsage: { warning: 70, critical: 90 }, // percentage
      memoryUsage: { warning: 80, critical: 95 } // percentage
    };
  }
  
  logRequestPerformance(request, response, metrics, context) {
    const performanceEvent = {
      eventType: 'request_performance',
      timestamp: new Date().toISOString(),
      
      // Request identification
      requestId: context.requestId,
      correlationId: context.correlationId,
      
      // Request details
      method: request.method,
      endpoint: request.endpoint,
      route: request.route,
      statusCode: response.statusCode,
      
      // Timing metrics
      totalResponseTime: metrics.totalResponseTime,
      processingTime: metrics.processingTime,
      queueTime: metrics.queueTime,
      networkTime: metrics.networkTime,
      
      // Detailed timing breakdown
      timings: {
        dnsLookup: metrics.timings.dnsLookup,
        tcpConnection: metrics.timings.tcpConnection,
        tlsHandshake: metrics.timings.tlsHandshake,
        firstByte: metrics.timings.firstByte,
        contentTransfer: metrics.timings.contentTransfer,
        
        // Application timing
        authentication: metrics.timings.authentication,
        authorization: metrics.timings.authorization,
        businessLogic: metrics.timings.businessLogic,
        dataAccess: metrics.timings.dataAccess,
        responseGeneration: metrics.timings.responseGeneration
      },
      
      // Throughput metrics
      requestSize: request.size,
      responseSize: response.size,
      compressionRatio: response.compressionRatio,
      
      // Resource utilization during request
      resourceUsage: {
        cpuTime: metrics.cpuTime,
        memoryUsed: metrics.memoryUsed,
        ioOperations: metrics.ioOperations,
        networkCalls: metrics.networkCalls,
        databaseQueries: metrics.databaseQueries
      },
      
      // User context
      userId: context.userId,
      userAgent: context.userAgent,
      sourceIP: context.sourceIP,
      
      // Performance analysis
      performanceGrade: this.calculatePerformanceGrade(metrics),
      isSlowRequest: metrics.totalResponseTime > this.performanceThresholds.responseTime.warning,
      bottleneckDetected: this.detectBottleneck(metrics),
      
      // Comparison with baselines
      baseline: this.getPerformanceBaseline(request.endpoint),
      percentileRank: this.calculatePercentileRank(request.endpoint, metrics.totalResponseTime),
      deviationFromBaseline: this.calculateDeviation(request.endpoint, metrics),
      
      // External dependencies
      externalCalls: metrics.externalCalls.map(call => ({
        serviceName: call.serviceName,
        endpoint: call.endpoint,
        responseTime: call.responseTime,
        statusCode: call.statusCode,
        retryCount: call.retryCount
      })),
      
      // Cache performance
      cacheHits: metrics.cacheHits,
      cacheMisses: metrics.cacheMisses,
      cacheHitRatio: metrics.cacheHits / (metrics.cacheHits + metrics.cacheMisses),
      
      // Error context
      errorsEncountered: metrics.errorsEncountered,
      warningsGenerated: metrics.warningsGenerated,
      
      // Business metrics
      businessOperation: context.businessOperation,
      featureUsed: context.feature,
      conversionEvent: context.conversionEvent
    };
    
    // Update performance baselines
    this.updatePerformanceBaseline(request.endpoint, performanceEvent);
    
    // Log based on performance thresholds
    if (performanceEvent.isSlowRequest) {
      if (metrics.totalResponseTime > this.performanceThresholds.responseTime.critical) {
        this.logger.error('Critical response time threshold exceeded', performanceEvent);
        this.triggerPerformanceAlert(performanceEvent);
      } else {
        this.logger.warn('Slow response time detected', performanceEvent);
      }
    } else {
      this.logger.info('Request performance metrics', performanceEvent);
    }
    
    // Detect performance anomalies
    if (this.isPerformanceAnomaly(request.endpoint, metrics)) {
      this.logPerformanceAnomaly(performanceEvent);
    }
  }
  
  logThroughputMetrics(timeWindow, metrics) {
    const throughputEvent = {
      eventType: 'throughput_metrics',
      timestamp: new Date().toISOString(),
      timeWindow, // '1m', '5m', '15m', '1h'
      
      // Request metrics
      totalRequests: metrics.totalRequests,
      successfulRequests: metrics.successfulRequests,
      failedRequests: metrics.failedRequests,
      requestsPerSecond: metrics.requestsPerSecond,
      
      // Response metrics by status code
      statusCodeDistribution: metrics.statusCodeDistribution,
      errorRate: (metrics.failedRequests / metrics.totalRequests) * 100,
      
      // Response time statistics
      responseTimeStats: {
        min: metrics.responseTime.min,
        max: metrics.responseTime.max,
        mean: metrics.responseTime.mean,
        median: metrics.responseTime.median,
        p95: metrics.responseTime.p95,
        p99: metrics.responseTime.p99,
        standardDeviation: metrics.responseTime.standardDeviation
      },
      
      // Endpoint-specific metrics
      endpointMetrics: metrics.endpointMetrics.map(endpoint => ({
        path: endpoint.path,
        method: endpoint.method,
        requestCount: endpoint.requestCount,
        averageResponseTime: endpoint.averageResponseTime,
        errorRate: endpoint.errorRate,
        throughput: endpoint.throughput
      })),
      
      // Resource utilization
      resourceUtilization: {
        avgCpuUsage: metrics.avgCpuUsage,
        avgMemoryUsage: metrics.avgMemoryUsage,
        avgDiskUsage: metrics.avgDiskUsage,
        avgNetworkUsage: metrics.avgNetworkUsage
      },
      
      // Concurrency metrics
      concurrency: {
        maxConcurrentRequests: metrics.maxConcurrentRequests,
        avgConcurrentRequests: metrics.avgConcurrentRequests,
        queueLength: metrics.queueLength,
        activeConnections: metrics.activeConnections
      },
      
      // Cache performance
      cacheMetrics: {
        hitRate: metrics.cacheHitRate,
        missRate: metrics.cacheMissRate,
        evictionRate: metrics.cacheEvictionRate,
        memoryUsage: metrics.cacheMemoryUsage
      },
      
      // Database performance
      databaseMetrics: {
        queryCount: metrics.dbQueryCount,
        avgQueryTime: metrics.avgDbQueryTime,
        slowQueries: metrics.slowQueries,
        connectionPoolUsage: metrics.dbConnectionPoolUsage
      },
      
      // External service performance
      externalServiceMetrics: metrics.externalServices.map(service => ({
        serviceName: service.name,
        callCount: service.callCount,
        avgResponseTime: service.avgResponseTime,
        errorRate: service.errorRate,
        availability: service.availability
      })),
      
      // Trend analysis
      trends: {
        requestTrend: this.calculateTrend(metrics.requestsPerSecond, timeWindow),
        responseTrend: this.calculateTrend(metrics.responseTime.mean, timeWindow),
        errorTrend: this.calculateTrend(metrics.errorRate, timeWindow),
        resourceTrend: this.calculateTrend(metrics.avgCpuUsage, timeWindow)
      },
      
      // Capacity indicators
      capacity: {
        utilizationLevel: this.calculateUtilizationLevel(metrics),
        headroom: this.calculateHeadroom(metrics),
        scalingRecommendation: this.getScalingRecommendation(metrics),
        bottleneckIndicators: this.identifyBottlenecks(metrics)
      }
    };
    
    // Log based on performance indicators
    if (throughputEvent.errorRate > this.performanceThresholds.errorRate.critical) {
      this.logger.error('Critical error rate detected', throughputEvent);
    } else if (throughputEvent.requestsPerSecond < this.performanceThresholds.throughput.critical) {
      this.logger.warn('Low throughput detected', throughputEvent);
    } else {
      this.logger.info('Throughput metrics', throughputEvent);
    }
    
    // Trigger capacity planning alerts
    if (throughputEvent.capacity.headroom < 20) {
      this.triggerCapacityAlert(throughputEvent);
    }
  }
  
  logResourcePerformance(resourceType, metrics, context) {
    const resourcePerformanceEvent = {
      eventType: 'resource_performance',
      timestamp: new Date().toISOString(),
      resourceType, // 'cpu', 'memory', 'disk', 'network', 'database', 'cache'
      
      // Current metrics
      current: {
        usage: metrics.current.usage,
        utilization: metrics.current.utilization,
        saturation: metrics.current.saturation,
        errors: metrics.current.errors
      },
      
      // Time-series metrics
      timeSeries: {
        '1m': metrics.timeSeries['1m'],
        '5m': metrics.timeSeries['5m'],
        '15m': metrics.timeSeries['15m'],
        '1h': metrics.timeSeries['1h']
      },
      
      // Statistical analysis
      statistics: {
        min: metrics.statistics.min,
        max: metrics.statistics.max,
        mean: metrics.statistics.mean,
        median: metrics.statistics.median,
        standardDeviation: metrics.statistics.standardDeviation,
        variance: metrics.statistics.variance
      },
      
      // Performance indicators
      performanceIndicators: {
        efficiency: this.calculateResourceEfficiency(resourceType, metrics),
        reliability: this.calculateResourceReliability(resourceType, metrics),
        availability: this.calculateResourceAvailability(resourceType, metrics),
        responsiveness: this.calculateResourceResponsiveness(resourceType, metrics)
      },
      
      // Threshold analysis
      thresholds: {
        warningThreshold: this.performanceThresholds[resourceType]?.warning,
        criticalThreshold: this.performanceThresholds[resourceType]?.critical,
        thresholdExceeded: metrics.current.utilization > this.performanceThresholds[resourceType]?.warning,
        timeAboveThreshold: metrics.timeAboveThreshold
      },
      
      // Capacity planning
      capacity: {
        totalCapacity: metrics.capacity.total,
        usedCapacity: metrics.capacity.used,
        availableCapacity: metrics.capacity.available,
        projectedUsage: this.projectResourceUsage(resourceType, metrics),
        timeToCapacity: this.calculateTimeToCapacity(resourceType, metrics)
      },
      
      // Performance patterns
      patterns: {
        dailyPattern: metrics.patterns.daily,
        weeklyPattern: metrics.patterns.weekly,
        seasonality: metrics.patterns.seasonal,
        anomalies: this.detectResourceAnomalies(resourceType, metrics)
      },
      
      // Resource-specific metrics
      specificMetrics: this.getResourceSpecificMetrics(resourceType, metrics),
      
      // Context information
      hostname: require('os').hostname(),
      environment: process.env.NODE_ENV,
      applicationLoad: context.applicationLoad,
      activeUsers: context.activeUsers,
      
      // Optimization recommendations
      recommendations: this.getOptimizationRecommendations(resourceType, metrics),
      
      // Health score
      healthScore: this.calculateResourceHealthScore(resourceType, metrics)
    };
    
    // Log based on resource health and utilization
    if (resourcePerformanceEvent.thresholds.thresholdExceeded) {
      if (metrics.current.utilization > this.performanceThresholds[resourceType]?.critical) {
        this.logger.error(`Critical ${resourceType} utilization`, resourcePerformanceEvent);
        this.triggerResourceAlert(resourceType, resourcePerformanceEvent);
      } else {
        this.logger.warn(`High ${resourceType} utilization`, resourcePerformanceEvent);
      }
    } else {
      this.logger.info(`${resourceType} performance metrics`, resourcePerformanceEvent);
    }
    
    // Predictive alerts
    if (resourcePerformanceEvent.capacity.timeToCapacity && 
        resourcePerformanceEvent.capacity.timeToCapacity < 24 * 60 * 60 * 1000) { // 24 hours
      this.triggerPredictiveAlert(resourceType, resourcePerformanceEvent);
    }
  }
}
```

### 2. **Database Performance Metrics**
Monitoring query performance, connection pool utilization, and database-specific metrics.

```javascript
// Database performance metrics logging
class DatabasePerformanceLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'database-performance' });
    this.queryBaselines = new Map();
    this.slowQueryThreshold = 1000; // 1 second
  }
  
  logQueryPerformance(query, metrics, context) {
    const queryPerformanceEvent = {
      eventType: 'database_query_performance',
      timestamp: new Date().toISOString(),
      
      // Query identification
      queryId: this.generateQueryId(query.sql),
      queryHash: this.hashQuery(query.sql),
      queryType: query.type, // 'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'PROCEDURE'
      queryCategory: this.categorizeQuery(query.sql),
      
      // Query details (sanitized)
      queryLength: query.sql.length,
      parameterCount: query.parameters?.length || 0,
      tableCount: this.extractTableCount(query.sql),
      joinCount: this.extractJoinCount(query.sql),
      
      // Performance metrics
      executionTime: metrics.executionTime,
      cpuTime: metrics.cpuTime,
      ioTime: metrics.ioTime,
      lockWaitTime: metrics.lockWaitTime,
      networkTime: metrics.networkTime,
      
      // Data metrics
      rowsExamined: metrics.rowsExamined,
      rowsReturned: metrics.rowsReturned,
      selectivityRatio: metrics.rowsReturned / Math.max(metrics.rowsExamined, 1),
      dataSize: metrics.dataSize,
      
      // Execution plan metrics
      indexesUsed: metrics.indexesUsed,
      fullTableScans: metrics.fullTableScans,
      temporaryTablesCreated: metrics.temporaryTablesCreated,
      sortOperations: metrics.sortOperations,
      joinOperations: metrics.joinOperations,
      
      // Resource utilization
      memoryUsed: metrics.memoryUsed,
      diskReads: metrics.diskReads,
      diskWrites: metrics.diskWrites,
      bufferPoolHits: metrics.bufferPoolHits,
      bufferPoolMisses: metrics.bufferPoolMisses,
      
      // Connection context
      connectionId: context.connectionId,
      connectionPool: context.connectionPool,
      transactionId: context.transactionId,
      isolationLevel: context.isolationLevel,
      
      // Database context
      database: context.database,
      schema: context.schema,
      host: context.host,
      
      // Application context
      requestId: context.requestId,
      userId: context.userId,
      applicationFeature: context.feature,
      
      // Performance analysis
      isSlowQuery: metrics.executionTime > this.slowQueryThreshold,
      performanceRating: this.rateQueryPerformance(metrics),
      optimizationOpportunities: this.identifyOptimizationOpportunities(query, metrics),
      
      // Baseline comparison
      baseline: this.getQueryBaseline(query.sql),
      performanceDeviation: this.calculatePerformanceDeviation(query.sql, metrics),
      trendAnalysis: this.analyzePerformanceTrend(query.sql, metrics),
      
      // Lock information
      locksAcquired: metrics.locksAcquired,
      locksWaited: metrics.locksWaited,
      deadlocksDetected: metrics.deadlocksDetected,
      lockEscalations: metrics.lockEscalations,
      
      // Cache performance
      cacheHits: metrics.cacheHits,
      cacheMisses: metrics.cacheMisses,
      cacheHitRatio: metrics.cacheHits / (metrics.cacheHits + metrics.cacheMisses),
      
      // Error information
      warnings: metrics.warnings,
      errors: metrics.errors,
      retryCount: metrics.retryCount
    };
    
    // Update query baselines
    this.updateQueryBaseline(query.sql, queryPerformanceEvent);
    
    // Log based on performance characteristics
    if (queryPerformanceEvent.isSlowQuery) {
      this.logger.warn('Slow query detected', queryPerformanceEvent);
      this.analyzeSlowQuery(queryPerformanceEvent);
    } else if (metrics.fullTableScans > 0 || metrics.temporaryTablesCreated > 0) {
      this.logger.info('Query with optimization opportunities', queryPerformanceEvent);
    } else {
      this.logger.debug('Query performance metrics', queryPerformanceEvent);
    }
    
    // Performance alerts
    if (metrics.executionTime > this.slowQueryThreshold * 5) { // 5x threshold
      this.triggerSlowQueryAlert(queryPerformanceEvent);
    }
  }
  
  logConnectionPoolPerformance(poolName, metrics, context) {
    const poolPerformanceEvent = {
      eventType: 'connection_pool_performance',
      timestamp: new Date().toISOString(),
      poolName,
      
      // Pool configuration
      configuration: {
        minConnections: metrics.config.minConnections,
        maxConnections: metrics.config.maxConnections,
        connectionTimeout: metrics.config.connectionTimeout,
        idleTimeout: metrics.config.idleTimeout,
        maxLifetime: metrics.config.maxLifetime,
        validationQuery: metrics.config.validationQuery
      },
      
      // Current pool state
      currentState: {
        activeConnections: metrics.activeConnections,
        idleConnections: metrics.idleConnections,
        totalConnections: metrics.totalConnections,
        pendingRequests: metrics.pendingRequests,
        waitingTime: metrics.waitingTime
      },
      
      // Utilization metrics
      utilization: {
        poolUtilization: (metrics.activeConnections / metrics.config.maxConnections) * 100,
        peakUtilization: metrics.peakUtilization,
        averageUtilization: metrics.averageUtilization,
        utilizationTrend: this.calculateUtilizationTrend(poolName, metrics)
      },
      
      // Performance metrics
      performance: {
        connectionAcquisitionTime: metrics.connectionAcquisitionTime,
        connectionCreationTime: metrics.connectionCreationTime,
        connectionValidationTime: metrics.connectionValidationTime,
        queryExecutionTime: metrics.queryExecutionTime
      },
      
      // Lifecycle metrics
      lifecycle: {
        connectionsCreated: metrics.connectionsCreated,
        connectionsDestroyed: metrics.connectionsDestroyed,
        connectionsValidated: metrics.connectionsValidated,
        connectionsTimedOut: metrics.connectionsTimedOut,
        connectionLeaks: metrics.connectionLeaks
      },
      
      // Error metrics
      errors: {
        connectionFailures: metrics.connectionFailures,
        validationFailures: metrics.validationFailures,
        timeoutErrors: metrics.timeoutErrors,
        networkErrors: metrics.networkErrors
      },
      
      // Wait statistics
      waitStatistics: {
        totalWaitTime: metrics.totalWaitTime,
        averageWaitTime: metrics.averageWaitTime,
        maxWaitTime: metrics.maxWaitTime,
        waitingThreads: metrics.waitingThreads
      },
      
      // Health indicators
      health: {
        healthScore: this.calculatePoolHealthScore(metrics),
        isHealthy: this.isPoolHealthy(metrics),
        warningIndicators: this.getPoolWarningIndicators(metrics),
        criticalIndicators: this.getPoolCriticalIndicators(metrics)
      },
      
      // Capacity analysis
      capacity: {
        capacityUtilization: metrics.capacityUtilization,
        projectedDemand: this.projectPoolDemand(poolName, metrics),
        recommendedSize: this.calculateRecommendedPoolSize(metrics),
        scaleUpRequired: this.shouldScaleUp(metrics),
        scaleDownPossible: this.canScaleDown(metrics)
      },
      
      // Database context
      database: context.database,
      host: context.host,
      environment: context.environment,
      
      // Application context
      applicationLoad: context.applicationLoad,
      activeUsers: context.activeUsers,
      peakHours: context.peakHours
    };
    
    // Log based on pool health and utilization
    if (!poolPerformanceEvent.health.isHealthy) {
      this.logger.error('Connection pool health issues detected', poolPerformanceEvent);
      this.triggerPoolHealthAlert(poolPerformanceEvent);
    } else if (poolPerformanceEvent.utilization.poolUtilization > 80) {
      this.logger.warn('High connection pool utilization', poolPerformanceEvent);
    } else {
      this.logger.info('Connection pool performance metrics', poolPerformanceEvent);
    }
    
    // Capacity planning alerts
    if (poolPerformanceEvent.capacity.scaleUpRequired) {
      this.triggerCapacityAlert(poolPerformanceEvent);
    }
  }
  
  logDatabaseSystemPerformance(systemMetrics, context) {
    const systemPerformanceEvent = {
      eventType: 'database_system_performance',
      timestamp: new Date().toISOString(),
      
      // Database identification
      database: context.database,
      version: context.version,
      host: context.host,
      port: context.port,
      
      // Performance counters
      performanceCounters: {
        transactionsPerSecond: systemMetrics.transactionsPerSecond,
        queriesPerSecond: systemMetrics.queriesPerSecond,
        connectionsPerSecond: systemMetrics.connectionsPerSecond,
        operationsPerSecond: systemMetrics.operationsPerSecond
      },
      
      // Throughput metrics
      throughput: {
        readThroughput: systemMetrics.readThroughput,
        writeThroughput: systemMetrics.writeThroughput,
        networkThroughput: systemMetrics.networkThroughput,
        diskThroughput: systemMetrics.diskThroughput
      },
      
      // Latency metrics
      latency: {
        averageQueryLatency: systemMetrics.averageQueryLatency,
        averageTransactionLatency: systemMetrics.averageTransactionLatency,
        replicationLatency: systemMetrics.replicationLatency,
        diskLatency: systemMetrics.diskLatency
      },
      
      // Resource utilization
      resources: {
        cpuUtilization: systemMetrics.cpuUtilization,
        memoryUtilization: systemMetrics.memoryUtilization,
        diskUtilization: systemMetrics.diskUtilization,
        networkUtilization: systemMetrics.networkUtilization,
        bufferPoolUtilization: systemMetrics.bufferPoolUtilization
      },
      
      // Cache performance
      cacheMetrics: {
        bufferCacheHitRatio: systemMetrics.bufferCacheHitRatio,
        planCacheHitRatio: systemMetrics.planCacheHitRatio,
        dataCacheHitRatio: systemMetrics.dataCacheHitRatio,
        cacheEvictions: systemMetrics.cacheEvictions
      },
      
      // Lock and contention metrics
      locking: {
        lockWaits: systemMetrics.lockWaits,
        deadlocks: systemMetrics.deadlocks,
        blockingProcesses: systemMetrics.blockingProcesses,
        averageLockWaitTime: systemMetrics.averageLockWaitTime
      },
      
      // I/O metrics
      ioMetrics: {
        logicalReads: systemMetrics.logicalReads,
        physicalReads: systemMetrics.physicalReads,
        writes: systemMetrics.writes,
        ioWaitTime: systemMetrics.ioWaitTime
      },
      
      // Replication metrics (if applicable)
      replication: {
        replicationLag: systemMetrics.replicationLag,
        replicationErrors: systemMetrics.replicationErrors,
        slaveConnections: systemMetrics.slaveConnections,
        binlogPosition: systemMetrics.binlogPosition
      },
      
      // Health indicators
      health: {
        overallHealth: this.calculateDatabaseHealth(systemMetrics),
        uptime: systemMetrics.uptime,
        availabilityPercentage: systemMetrics.availabilityPercentage,
        errorRate: systemMetrics.errorRate
      },
      
      // Growth trends
      trends: {
        dataGrowthRate: systemMetrics.dataGrowthRate,
        transactionGrowthRate: systemMetrics.transactionGrowthRate,
        userGrowthRate: systemMetrics.userGrowthRate,
        capacityTrend: systemMetrics.capacityTrend
      },
      
      // Maintenance metrics
      maintenance: {
        lastBackup: systemMetrics.lastBackup,
        lastVacuum: systemMetrics.lastVacuum,
        lastAnalyze: systemMetrics.lastAnalyze,
        fragmentationLevel: systemMetrics.fragmentationLevel
      }
    };
    
    // Log based on system health
    if (systemPerformanceEvent.health.overallHealth < 70) {
      this.logger.error('Database system performance degraded', systemPerformanceEvent);
    } else if (systemPerformanceEvent.health.overallHealth < 85) {
      this.logger.warn('Database system performance warnings', systemPerformanceEvent);
    } else {
      this.logger.info('Database system performance metrics', systemPerformanceEvent);
    }
  }
}
```

### 3. **External Service Performance Metrics**
Monitoring the performance of external APIs, third-party services, and network dependencies.

```javascript
// External service performance metrics logging
class ExternalServicePerformanceLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'external-service-performance' });
    this.serviceBaselines = new Map();
    this.slaThresholds = new Map();
  }
  
  logServiceCallPerformance(serviceCall, metrics, context) {
    const servicePerformanceEvent = {
      eventType: 'external_service_performance',
      timestamp: new Date().toISOString(),
      
      // Service identification
      serviceName: serviceCall.serviceName,
      endpoint: serviceCall.endpoint,
      method: serviceCall.method,
      serviceVersion: serviceCall.version,
      serviceProvider: serviceCall.provider,
      
      // Request context
      requestId: context.requestId,
      correlationId: context.correlationId,
      retryAttempt: serviceCall.retryAttempt || 0,
      
      // Performance metrics
      timing: {
        totalTime: metrics.totalTime,
        dnsLookupTime: metrics.dnsLookupTime,
        connectionTime: metrics.connectionTime,
        tlsHandshakeTime: metrics.tlsHandshakeTime,
        requestTime: metrics.requestTime,
        waitTime: metrics.waitTime,
        receiveTime: metrics.receiveTime,
        processingTime: metrics.processingTime
      },
      
      // Data transfer metrics
      dataTransfer: {
        requestSize: metrics.requestSize,
        responseSize: metrics.responseSize,
        compressionRatio: metrics.compressionRatio,
        transferRate: metrics.transferRate
      },
      
      // Response details
      response: {
        statusCode: metrics.statusCode,
        success: metrics.success,
        contentType: metrics.contentType,
        cacheStatus: metrics.cacheStatus // 'hit', 'miss', 'expired'
      },
      
      // Network performance
      network: {
        latency: metrics.networkLatency,
        jitter: metrics.jitter,
        packetLoss: metrics.packetLoss,
        bandwidth: metrics.bandwidth,
        connectionReused: metrics.connectionReused
      },
      
      // Service health indicators
      serviceHealth: {
        availability: this.calculateServiceAvailability(serviceCall.serviceName),
        reliability: this.calculateServiceReliability(serviceCall.serviceName),
        responseTimeConsistency: this.calculateResponseTimeConsistency(serviceCall.serviceName),
        errorRate: this.calculateServiceErrorRate(serviceCall.serviceName)
      },
      
      // SLA compliance
      slaCompliance: {
        slaTarget: this.getSLATarget(serviceCall.serviceName),
        slaActual: metrics.totalTime,
        slaCompliant: this.isSLACompliant(serviceCall.serviceName, metrics.totalTime),
        slaBuffer: this.calculateSLABuffer(serviceCall.serviceName, metrics.totalTime)
      },
      
      // Circuit breaker status
      circuitBreaker: {
        state: this.getCircuitBreakerState(serviceCall.serviceName),
        failureCount: this.getFailureCount(serviceCall.serviceName),
        lastFailureTime: this.getLastFailureTime(serviceCall.serviceName),
        nextRetryTime: this.getNextRetryTime(serviceCall.serviceName)
      },
      
      // Rate limiting
      rateLimiting: {
        remainingRequests: metrics.rateLimitRemaining,
        limitResetTime: metrics.rateLimitReset,
        rateLimited: metrics.rateLimited,
        retryAfter: metrics.retryAfter
      },
      
      // Authentication performance
      authentication: {
        authTime: metrics.authTime,
        tokenValid: metrics.tokenValid,
        authRefreshRequired: metrics.authRefreshRequired,
        authMethod: serviceCall.authMethod
      },
      
      // Baseline comparison
      baseline: this.getServiceBaseline(serviceCall.serviceName, serviceCall.endpoint),
      performanceScore: this.calculatePerformanceScore(serviceCall, metrics),
      deviation: this.calculateDeviation(serviceCall, metrics),
      
      // Business context
      businessContext: {
        businessOperation: context.businessOperation,
        criticality: context.criticality,
        userImpact: context.userImpact,
        featureUsed: context.feature
      },
      
      // Error analysis
      errorAnalysis: {
        errorType: metrics.errorType,
        errorCategory: this.categorizeError(metrics),
        retryable: this.isRetryableError(metrics),
        fallbackAvailable: context.fallbackAvailable
      }
    };
    
    // Update service baselines
    this.updateServiceBaseline(serviceCall.serviceName, serviceCall.endpoint, servicePerformanceEvent);
    
    // Log based on performance and SLA compliance
    if (!servicePerformanceEvent.slaCompliance.slaCompliant) {
      this.logger.warn('SLA violation detected', servicePerformanceEvent);
      this.triggerSLAAlert(servicePerformanceEvent);
    } else if (servicePerformanceEvent.performanceScore < 70) {
      this.logger.warn('Poor service performance detected', servicePerformanceEvent);
    } else {
      this.logger.info('External service performance', servicePerformanceEvent);
    }
    
    // Circuit breaker decisions
    if (this.shouldTriggerCircuitBreaker(serviceCall.serviceName, metrics)) {
      this.triggerCircuitBreaker(serviceCall.serviceName, servicePerformanceEvent);
    }
  }
  
  logServiceAvailabilityMetrics(serviceName, metrics, timeWindow) {
    const availabilityEvent = {
      eventType: 'service_availability_metrics',
      timestamp: new Date().toISOString(),
      serviceName,
      timeWindow, // '5m', '15m', '1h', '24h'
      
      // Availability metrics
      availability: {
        uptime: metrics.uptime,
        downtime: metrics.downtime,
        availabilityPercentage: (metrics.uptime / (metrics.uptime + metrics.downtime)) * 100,
        mtbf: metrics.meanTimeBetweenFailures,
        mttr: metrics.meanTimeToRecover
      },
      
      // Request statistics
      requests: {
        totalRequests: metrics.totalRequests,
        successfulRequests: metrics.successfulRequests,
        failedRequests: metrics.failedRequests,
        timeoutRequests: metrics.timeoutRequests,
        errorRate: (metrics.failedRequests / metrics.totalRequests) * 100
      },
      
      // Response time statistics
      responseTime: {
        average: metrics.averageResponseTime,
        median: metrics.medianResponseTime,
        p95: metrics.p95ResponseTime,
        p99: metrics.p99ResponseTime,
        slowestRequest: metrics.slowestRequest,
        fastestRequest: metrics.fastestRequest
      },
      
      // Incident analysis
      incidents: {
        incidentCount: metrics.incidentCount,
        criticalIncidents: metrics.criticalIncidents,
        averageIncidentDuration: metrics.averageIncidentDuration,
        longestIncident: metrics.longestIncident,
        shortestIncident: metrics.shortestIncident
      },
      
      // Error distribution
      errorDistribution: {
        by4xx: metrics.error4xxCount,
        by5xx: metrics.error5xxCount,
        byTimeout: metrics.timeoutCount,
        byConnection: metrics.connectionErrorCount,
        byOther: metrics.otherErrorCount
      },
      
      // Performance trends
      trends: {
        availabilityTrend: this.calculateAvailabilityTrend(serviceName, timeWindow),
        responseTrend: this.calculateResponseTimeTrend(serviceName, timeWindow),
        errorTrend: this.calculateErrorRateTrend(serviceName, timeWindow),
        throughputTrend: this.calculateThroughputTrend(serviceName, timeWindow)
      },
      
      // SLA performance
      slaPerformance: {
        slaTarget: this.getSLATarget(serviceName),
        slaActual: metrics.availabilityPercentage,
        slaCompliance: metrics.availabilityPercentage >= this.getSLATarget(serviceName),
        slaCreditsEarned: this.calculateSLACredits(serviceName, metrics),
        slaRisk: this.assessSLARisk(serviceName, metrics)
      },
      
      // Capacity indicators
      capacity: {
        peakLoad: metrics.peakLoad,
        averageLoad: metrics.averageLoad,
        loadVariance: metrics.loadVariance,
        capacityUtilization: metrics.capacityUtilization,
        headroom: metrics.headroom
      },
      
      // Dependencies
      dependencies: {
        upstreamServices: this.getUpstreamServices(serviceName),
        downstreamServices: this.getDownstreamServices(serviceName),
        dependencyFailures: metrics.dependencyFailures,
        cascadingFailures: metrics.cascadingFailures
      },
      
      // Recovery metrics
      recovery: {
        automaticRecoveries: metrics.automaticRecoveries,
        manualInterventions: metrics.manualInterventions,
        averageRecoveryTime: metrics.averageRecoveryTime,
        recoverySuccess: metrics.recoverySuccessRate
      }
    };
    
    // Log based on availability performance
    if (availabilityEvent.availability.availabilityPercentage < 95) {
      this.logger.error('Poor service availability detected', availabilityEvent);
      this.triggerAvailabilityAlert(availabilityEvent);
    } else if (availabilityEvent.availability.availabilityPercentage < 99) {
      this.logger.warn('Service availability below target', availabilityEvent);
    } else {
      this.logger.info('Service availability metrics', availabilityEvent);
    }
    
    // SLA compliance monitoring
    if (!availabilityEvent.slaPerformance.slaCompliance) {
      this.triggerSLAViolationAlert(availabilityEvent);
    }
  }
}
```

### 4. **Infrastructure Performance Metrics**
Monitoring server, network, and cloud infrastructure performance metrics.

```javascript
// Infrastructure performance metrics logging
class InfrastructurePerformanceLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'infrastructure-performance' });
    this.infrastructureBaselines = new Map();
  }
  
  logServerPerformance(serverMetrics, context) {
    const serverPerformanceEvent = {
      eventType: 'server_performance',
      timestamp: new Date().toISOString(),
      
      // Server identification
      hostname: context.hostname,
      serverId: context.serverId,
      serverType: context.serverType, // 'web', 'app', 'db', 'cache', 'load_balancer'
      location: context.location,
      
      // CPU metrics
      cpu: {
        usage: serverMetrics.cpu.usage,
        userTime: serverMetrics.cpu.userTime,
        systemTime: serverMetrics.cpu.systemTime,
        idleTime: serverMetrics.cpu.idleTime,
        iowaitTime: serverMetrics.cpu.iowaitTime,
        loadAverage: serverMetrics.cpu.loadAverage,
        coreCount: serverMetrics.cpu.coreCount,
        frequency: serverMetrics.cpu.frequency,
        contextSwitches: serverMetrics.cpu.contextSwitches,
        interrupts: serverMetrics.cpu.interrupts
      },
      
      // Memory metrics
      memory: {
        total: serverMetrics.memory.total,
        used: serverMetrics.memory.used,
        free: serverMetrics.memory.free,
        cached: serverMetrics.memory.cached,
        buffers: serverMetrics.memory.buffers,
        swapTotal: serverMetrics.memory.swapTotal,
        swapUsed: serverMetrics.memory.swapUsed,
        pageFaults: serverMetrics.memory.pageFaults,
        pageIns: serverMetrics.memory.pageIns,
        pageOuts: serverMetrics.memory.pageOuts
      },
      
      // Disk metrics
      disk: {
        usage: serverMetrics.disk.usage,
        readIOPS: serverMetrics.disk.readIOPS,
        writeIOPS: serverMetrics.disk.writeIOPS,
        readThroughput: serverMetrics.disk.readThroughput,
        writeThroughput: serverMetrics.disk.writeThroughput,
        readLatency: serverMetrics.disk.readLatency,
        writeLatency: serverMetrics.disk.writeLatency,
        queueDepth: serverMetrics.disk.queueDepth,
        utilization: serverMetrics.disk.utilization
      },
      
      // Network metrics
      network: {
        bytesReceived: serverMetrics.network.bytesReceived,
        bytesSent: serverMetrics.network.bytesSent,
        packetsReceived: serverMetrics.network.packetsReceived,
        packetsSent: serverMetrics.network.packetsSent,
        errors: serverMetrics.network.errors,
        drops: serverMetrics.network.drops,
        collisions: serverMetrics.network.collisions,
        bandwidth: serverMetrics.network.bandwidth,
        latency: serverMetrics.network.latency
      },
      
      // Process metrics
      processes: {
        total: serverMetrics.processes.total,
        running: serverMetrics.processes.running,
        sleeping: serverMetrics.processes.sleeping,
        zombie: serverMetrics.processes.zombie,
        stopped: serverMetrics.processes.stopped,
        threads: serverMetrics.processes.threads
      },
      
      // System health indicators
      health: {
        uptime: serverMetrics.uptime,
        temperature: serverMetrics.temperature,
        powerStatus: serverMetrics.powerStatus,
        fanSpeed: serverMetrics.fanSpeed,
        hardwareErrors: serverMetrics.hardwareErrors,
        systemErrors: serverMetrics.systemErrors
      },
      
      // Performance indicators
      performance: {
        responseTime: this.calculateServerResponseTime(serverMetrics),
        throughput: this.calculateServerThroughput(serverMetrics),
        efficiency: this.calculateServerEfficiency(serverMetrics),
        capacity: this.calculateServerCapacity(serverMetrics)
      },
      
      // Resource saturation
      saturation: {
        cpuSaturation: this.calculateCPUSaturation(serverMetrics),
        memorySaturation: this.calculateMemorySaturation(serverMetrics),
        diskSaturation: this.calculateDiskSaturation(serverMetrics),
        networkSaturation: this.calculateNetworkSaturation(serverMetrics)
      },
      
      // Application metrics
      applications: {
        activeConnections: serverMetrics.applications.activeConnections,
        requestRate: serverMetrics.applications.requestRate,
        errorRate: serverMetrics.applications.errorRate,
        averageResponseTime: serverMetrics.applications.averageResponseTime
      },
      
      // Security metrics
      security: {
        failedLogins: serverMetrics.security.failedLogins,
        unauthorizedAccess: serverMetrics.security.unauthorizedAccess,
        firewallBlocks: serverMetrics.security.firewallBlocks,
        securityAlerts: serverMetrics.security.securityAlerts
      }
    };
    
    // Calculate overall server health
    const healthScore = this.calculateServerHealthScore(serverPerformanceEvent);
    serverPerformanceEvent.overallHealth = healthScore;
    
    // Log based on server health
    if (healthScore < 70) {
      this.logger.error('Critical server performance issues', serverPerformanceEvent);
      this.triggerServerAlert(serverPerformanceEvent);
    } else if (healthScore < 85) {
      this.logger.warn('Server performance degradation', serverPerformanceEvent);
    } else {
      this.logger.info('Server performance metrics', serverPerformanceEvent);
    }
  }
  
  logNetworkPerformance(networkMetrics, context) {
    const networkPerformanceEvent = {
      eventType: 'network_performance',
      timestamp: new Date().toISOString(),
      
      // Network identification
      networkSegment: context.networkSegment,
      networkDevice: context.networkDevice,
      interfaceName: context.interfaceName,
      
      // Latency metrics
      latency: {
        rtt: networkMetrics.latency.roundTripTime,
        oneWayLatency: networkMetrics.latency.oneWay,
        jitter: networkMetrics.latency.jitter,
        variation: networkMetrics.latency.variation
      },
      
      // Throughput metrics
      throughput: {
        bandwidth: networkMetrics.throughput.bandwidth,
        utilization: networkMetrics.throughput.utilization,
        goodput: networkMetrics.throughput.goodput,
        effectiveThroughput: networkMetrics.throughput.effective
      },
      
      // Packet metrics
      packets: {
        sent: networkMetrics.packets.sent,
        received: networkMetrics.packets.received,
        lost: networkMetrics.packets.lost,
        lossRate: networkMetrics.packets.lossRate,
        duplicate: networkMetrics.packets.duplicate,
        outOfOrder: networkMetrics.packets.outOfOrder
      },
      
      // Error metrics
      errors: {
        transmissionErrors: networkMetrics.errors.transmission,
        receptionErrors: networkMetrics.errors.reception,
        checksumErrors: networkMetrics.errors.checksum,
        timeoutErrors: networkMetrics.errors.timeout,
        congestionErrors: networkMetrics.errors.congestion
      },
      
      // Quality metrics
      quality: {
        availability: networkMetrics.quality.availability,
        reliability: networkMetrics.quality.reliability,
        mtu: networkMetrics.quality.mtu,
        fragmentationRate: networkMetrics.quality.fragmentationRate
      },
      
      // Performance baselines
      baselines: this.getNetworkBaselines(context.networkSegment),
      deviations: this.calculateNetworkDeviations(networkMetrics, context.networkSegment),
      
      // Health indicators
      health: {
        score: this.calculateNetworkHealthScore(networkMetrics),
        issues: this.identifyNetworkIssues(networkMetrics),
        recommendations: this.getNetworkRecommendations(networkMetrics)
      }
    };
    
    // Log based on network health
    if (networkPerformanceEvent.health.score < 70) {
      this.logger.error('Critical network performance issues', networkPerformanceEvent);
    } else if (networkPerformanceEvent.health.score < 85) {
      this.logger.warn('Network performance degradation', networkPerformanceEvent);
    } else {
      this.logger.info('Network performance metrics', networkPerformanceEvent);
    }
  }
}
```

## Best Practices for Performance Metrics Logging

### 1. **Comprehensive Metric Collection**
- Monitor all critical performance indicators
- Include both technical and business metrics
- Capture baseline measurements for comparison
- Track trends and patterns over time

### 2. **Performance Threshold Management**
- Define appropriate warning and critical thresholds
- Implement dynamic threshold adjustment
- Use percentile-based thresholds for better accuracy
- Consider business impact when setting thresholds

### 3. **Efficient Data Collection**
- Use sampling for high-frequency metrics
- Implement efficient aggregation techniques
- Minimize performance impact of monitoring
- Balance detail with storage requirements

### 4. **Actionable Insights**
- Provide context for performance measurements
- Include recommendations for optimization
- Enable root cause analysis capabilities
- Support capacity planning decisions

### 5. **Integration and Alerting**
- Integrate with monitoring and alerting systems
- Enable predictive performance monitoring
- Support real-time performance dashboards
- Facilitate automated response to performance issues

---

**Previous**: [1.3.4 Error Conditions](./1.3.4_Error_Conditions.md)  
**Next**: [1.3.6 Business Logic Events](./1.3.6_Business_Logic_Events.md)
