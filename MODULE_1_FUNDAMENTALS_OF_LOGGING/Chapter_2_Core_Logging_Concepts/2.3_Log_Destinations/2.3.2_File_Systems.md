# 2.3.2 File Systems

## Understanding File-Based Logging

File system logging is the foundation of persistent log storage, providing durability, searchability, and long-term retention capabilities. This section covers advanced file logging techniques, rotation strategies, compression, and enterprise-grade file management systems.

## Advanced File Logging Implementation

### 1. **Comprehensive File Logger**
Enterprise-grade file logging system with rotation, compression, and advanced management features.

```javascript
// Advanced file logging system
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');
const zlib = require('zlib');
const { Transform, Writable } = require('stream');
const { promisify } = require('util');

class AdvancedFileLogger {
  constructor(options = {}) {
    this.options = {
      baseDir: options.baseDir || './logs',
      filename: options.filename || 'application.log',
      maxFileSize: options.maxFileSize || 100 * 1024 * 1024, // 100MB
      maxFiles: options.maxFiles || 10,
      compression: options.compression !== false,
      compressionLevel: options.compressionLevel || 6,
      rotationStrategy: options.rotationStrategy || 'size', // 'size', 'time', 'custom'
      rotationInterval: options.rotationInterval || '1d', // '1h', '1d', '1w', '1M'
      bufferSize: options.bufferSize || 64 * 1024, // 64KB
      flushInterval: options.flushInterval || 1000, // 1s
      encoding: options.encoding || 'utf8',
      fileMode: options.fileMode || 0o644,
      dirMode: options.dirMode || 0o755,
      createDirs: options.createDirs !== false,
      syncOnWrite: options.syncOnWrite || false,
      watchFiles: options.watchFiles || false,
      auditTrail: options.auditTrail || false,
      encryption: options.encryption || null,
      ...options
    };
    
    this.currentFile = null;
    this.currentStream = null;
    this.writeBuffer = [];
    this.flushTimer = null;
    this.rotationTimer = null;
    this.fileWatcher = null;
    this.metrics = this.initializeMetrics();
    this.encryptor = this.setupEncryption();
    this.rotationManager = this.setupRotationManager();
    this.compressionManager = this.setupCompressionManager();
    this.auditManager = this.setupAuditManager();
    
    this.initialize();
  }
  
  initializeMetrics() {
    return {
      filesCreated: 0,
      filesRotated: 0,
      filesCompressed: 0,
      bytesWritten: 0,
      logsWritten: 0,
      errors: 0,
      averageWriteTime: 0,
      bufferUtilization: 0,
      diskSpace: {
        total: 0,
        free: 0,
        used: 0
      },
      startTime: Date.now()
    };
  }
  
  setupEncryption() {
    if (!this.options.encryption) return null;
    
    const crypto = require('crypto');
    
    return {
      algorithm: this.options.encryption.algorithm || 'aes-256-gcm',
      key: this.options.encryption.key,
      
      encrypt: (data) => {
        const iv = crypto.randomBytes(16);
        const cipher = crypto.createCipher(this.encryptor.algorithm, this.encryptor.key);
        cipher.setAAD(Buffer.from('logging-data'));
        
        let encrypted = cipher.update(data, 'utf8', 'hex');
        encrypted += cipher.final('hex');
        
        const authTag = cipher.getAuthTag();
        
        return {
          iv: iv.toString('hex'),
          encrypted,
          authTag: authTag.toString('hex')
        };
      },
      
      decrypt: (encryptedData) => {
        const decipher = crypto.createDecipher(this.encryptor.algorithm, this.encryptor.key);
        decipher.setAAD(Buffer.from('logging-data'));
        decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
        
        let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
        decrypted += decipher.final('utf8');
        
        return decrypted;
      }
    };
  }
  
  setupRotationManager() {
    return {
      // Check if rotation is needed
      needsRotation: async () => {
        if (!this.currentFile) return false;
        
        try {
          const stats = await fs.stat(this.currentFile);
          
          switch (this.options.rotationStrategy) {
            case 'size':
              return stats.size >= this.options.maxFileSize;
              
            case 'time':
              return this.isTimeRotationDue(stats.mtime);
              
            case 'custom':
              return this.options.customRotationCheck ? 
                this.options.customRotationCheck(stats, this.currentFile) : false;
              
            default:
              return false;
          }
        } catch (error) {
          console.error('Error checking rotation needs:', error);
          return false;
        }
      },
      
      // Perform file rotation
      rotate: async () => {
        const startTime = Date.now();
        
        try {
          // Close current stream
          if (this.currentStream) {
            await this.closeCurrentStream();
          }
          
          // Generate rotation filename
          const rotatedFilename = this.generateRotatedFilename();
          const rotatedPath = path.join(this.options.baseDir, rotatedFilename);
          
          // Move current file to rotated filename
          if (this.currentFile && fsSync.existsSync(this.currentFile)) {
            await fs.rename(this.currentFile, rotatedPath);
            
            // Compress if enabled
            if (this.options.compression) {
              await this.compressionManager.compressFile(rotatedPath);
            }
          }
          
          // Clean up old files
          await this.cleanupOldFiles();
          
          // Create new file
          await this.createNewFile();
          
          // Update metrics
          this.metrics.filesRotated++;
          
          // Audit trail
          if (this.options.auditTrail) {
            this.auditManager.recordRotation(rotatedFilename, Date.now() - startTime);
          }
          
          console.log(`Log file rotated: ${rotatedFilename}`);
          
        } catch (error) {
          console.error('Error during file rotation:', error);
          this.metrics.errors++;
          throw error;
        }
      },
      
      // Setup automatic rotation timers
      setupAutoRotation: () => {
        if (this.options.rotationStrategy === 'time') {
          const interval = this.parseTimeInterval(this.options.rotationInterval);
          
          this.rotationTimer = setInterval(() => {
            this.rotationManager.needsRotation().then(needs => {
              if (needs) {
                this.rotationManager.rotate();
              }
            });
          }, Math.min(interval, 60000)); // Check at least every minute
        }
      },
      
      // Generate filename for rotated file
      generateRotatedFilename: () => {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const basename = path.basename(this.options.filename, path.extname(this.options.filename));
        const extension = path.extname(this.options.filename);
        
        return `${basename}.${timestamp}${extension}`;
      }
    };
  }
  
  setupCompressionManager() {
    return {
      // Compress a file
      compressFile: async (filePath) => {
        const compressedPath = filePath + '.gz';
        
        return new Promise((resolve, reject) => {
          const readStream = fsSync.createReadStream(filePath);
          const writeStream = fsSync.createWriteStream(compressedPath);
          const gzipStream = zlib.createGzip({ level: this.options.compressionLevel });
          
          readStream
            .pipe(gzipStream)
            .pipe(writeStream)
            .on('finish', async () => {
              try {
                // Remove original file after successful compression
                await fs.unlink(filePath);
                this.metrics.filesCompressed++;
                
                // Calculate compression ratio
                const originalStats = await fs.stat(filePath).catch(() => ({ size: 0 }));
                const compressedStats = await fs.stat(compressedPath);
                const ratio = (1 - compressedStats.size / originalStats.size) * 100;
                
                console.log(`File compressed: ${path.basename(compressedPath)} (${ratio.toFixed(1)}% reduction)`);
                resolve(compressedPath);
              } catch (error) {
                reject(error);
              }
            })
            .on('error', reject);
        });
      },
      
      // Decompress a file
      decompressFile: async (compressedPath) => {
        const originalPath = compressedPath.replace(/\.gz$/, '');
        
        return new Promise((resolve, reject) => {
          const readStream = fsSync.createReadStream(compressedPath);
          const writeStream = fsSync.createWriteStream(originalPath);
          const gunzipStream = zlib.createGunzip();
          
          readStream
            .pipe(gunzipStream)
            .pipe(writeStream)
            .on('finish', () => resolve(originalPath))
            .on('error', reject);
        });
      },
      
      // Batch compress old files
      batchCompress: async (directory, pattern) => {
        try {
          const files = await fs.readdir(directory);
          const logFiles = files.filter(file => 
            pattern.test(file) && !file.endsWith('.gz')
          );
          
          const compressionPromises = logFiles.map(file => 
            this.compressionManager.compressFile(path.join(directory, file))
          );
          
          const results = await Promise.allSettled(compressionPromises);
          
          return {
            total: logFiles.length,
            successful: results.filter(r => r.status === 'fulfilled').length,
            failed: results.filter(r => r.status === 'rejected').length,
            errors: results
              .filter(r => r.status === 'rejected')
              .map(r => r.reason)
          };
        } catch (error) {
          console.error('Batch compression error:', error);
          throw error;
        }
      }
    };
  }
  
  setupAuditManager() {
    if (!this.options.auditTrail) return null;
    
    const auditFile = path.join(this.options.baseDir, 'audit.log');
    
    return {
      auditFile,
      
      // Record audit event
      record: async (event, details) => {
        const auditEntry = {
          timestamp: new Date().toISOString(),
          event,
          details,
          pid: process.pid,
          hostname: require('os').hostname()
        };
        
        try {
          await fs.appendFile(
            this.auditFile,
            JSON.stringify(auditEntry) + '\n',
            'utf8'
          );
        } catch (error) {
          console.error('Audit logging error:', error);
        }
      },
      
      // Record file creation
      recordCreation: (filename) => {
        this.auditManager.record('file_created', { filename });
      },
      
      // Record file rotation
      recordRotation: (filename, duration) => {
        this.auditManager.record('file_rotated', { filename, duration });
      },
      
      // Record file deletion
      recordDeletion: (filename, reason) => {
        this.auditManager.record('file_deleted', { filename, reason });
      },
      
      // Get audit history
      getHistory: async (limit = 100) => {
        try {
          const content = await fs.readFile(this.auditFile, 'utf8');
          const lines = content.trim().split('\n');
          
          return lines
            .slice(-limit)
            .map(line => JSON.parse(line))
            .reverse();
        } catch (error) {
          return [];
        }
      }
    };
  }
  
  async initialize() {
    try {
      // Create base directory
      if (this.options.createDirs) {
        await this.ensureDirectory(this.options.baseDir);
      }
      
      // Create initial file
      await this.createNewFile();
      
      // Setup automatic rotation
      this.rotationManager.setupAutoRotation();
      
      // Setup buffer flushing
      this.setupBufferFlushing();
      
      // Setup file watching
      if (this.options.watchFiles) {
        this.setupFileWatching();
      }
      
      // Update disk space metrics
      await this.updateDiskSpaceMetrics();
      
      console.log(`File logger initialized: ${this.currentFile}`);
      
    } catch (error) {
      console.error('Failed to initialize file logger:', error);
      throw error;
    }
  }
  
  async ensureDirectory(dirPath) {
    try {
      await fs.mkdir(dirPath, { 
        recursive: true, 
        mode: this.options.dirMode 
      });
    } catch (error) {
      if (error.code !== 'EEXIST') {
        throw error;
      }
    }
  }
  
  async createNewFile() {
    this.currentFile = path.join(this.options.baseDir, this.options.filename);
    
    // Create write stream
    this.currentStream = fsSync.createWriteStream(this.currentFile, {
      flags: 'a',
      encoding: this.options.encoding,
      mode: this.options.fileMode,
      highWaterMark: this.options.bufferSize
    });
    
    // Handle stream events
    this.currentStream.on('error', (error) => {
      console.error('File stream error:', error);
      this.metrics.errors++;
    });
    
    this.currentStream.on('drain', () => {
      // Stream is ready for more data
    });
    
    this.metrics.filesCreated++;
    
    // Audit trail
    if (this.options.auditTrail) {
      this.auditManager.recordCreation(this.options.filename);
    }
  }
  
  setupBufferFlushing() {
    if (this.options.flushInterval > 0) {
      this.flushTimer = setInterval(() => {
        this.flush();
      }, this.options.flushInterval);
    }
  }
  
  setupFileWatching() {
    if (!this.currentFile) return;
    
    try {
      this.fileWatcher = fsSync.watch(this.currentFile, (eventType, filename) => {
        if (eventType === 'rename') {
          console.warn('Log file was renamed or deleted:', filename);
          // Recreate file
          this.createNewFile();
        }
      });
    } catch (error) {
      console.error('Failed to setup file watching:', error);
    }
  }
  
  async updateDiskSpaceMetrics() {
    try {
      const stats = await fs.statfs ? fs.statfs(this.options.baseDir) : null;
      
      if (stats) {
        this.metrics.diskSpace = {
          total: stats.bavail * stats.bsize,
          free: stats.bfree * stats.bsize,
          used: (stats.blocks - stats.bfree) * stats.bsize
        };
      }
    } catch (error) {
      // statfs might not be available on all systems
    }
  }
  
  async log(level, message, metadata = {}) {
    const startTime = Date.now();
    
    try {
      // Create log entry
      const logEntry = {
        timestamp: new Date().toISOString(),
        level: level.toUpperCase(),
        message,
        metadata,
        pid: process.pid
      };
      
      // Convert to string
      let logString = JSON.stringify(logEntry) + '\n';
      
      // Encrypt if enabled
      if (this.encryptor) {
        const encrypted = this.encryptor.encrypt(logString);
        logString = JSON.stringify(encrypted) + '\n';
      }
      
      // Add to buffer or write directly
      if (this.options.bufferSize > 0) {
        this.writeBuffer.push(logString);
        this.metrics.bufferUtilization = 
          (this.writeBuffer.length * logString.length) / this.options.bufferSize;
        
        if (this.writeBuffer.length >= 100) { // Flush when buffer has 100 entries
          await this.flush();
        }
      } else {
        await this.writeToFile(logString);
      }
      
      // Update metrics
      this.metrics.logsWritten++;
      this.metrics.bytesWritten += logString.length;
      
      const writeTime = Date.now() - startTime;
      this.metrics.averageWriteTime = 
        (this.metrics.averageWriteTime * (this.metrics.logsWritten - 1) + writeTime) / 
        this.metrics.logsWritten;
      
      // Check for rotation
      if (await this.rotationManager.needsRotation()) {
        await this.rotationManager.rotate();
      }
      
    } catch (error) {
      console.error('File logging error:', error);
      this.metrics.errors++;
      throw error;
    }
  }
  
  async writeToFile(data) {
    if (!this.currentStream) {
      throw new Error('No active file stream');
    }
    
    return new Promise((resolve, reject) => {
      const written = this.currentStream.write(data, this.options.encoding, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
      
      if (!written) {
        // Handle backpressure
        this.currentStream.once('drain', resolve);
      }
      
      // Sync to disk if required
      if (this.options.syncOnWrite) {
        this.currentStream.once('finish', () => {
          fsSync.fsync(this.currentStream.fd, (error) => {
            if (error) reject(error);
            else resolve();
          });
        });
      }
    });
  }
  
  async flush() {
    if (this.writeBuffer.length === 0) return;
    
    const buffer = [...this.writeBuffer];
    this.writeBuffer = [];
    
    const data = buffer.join('');
    await this.writeToFile(data);
    
    this.metrics.bufferUtilization = 0;
  }
  
  async closeCurrentStream() {
    if (!this.currentStream) return;
    
    return new Promise((resolve) => {
      this.currentStream.end(() => {
        this.currentStream = null;
        resolve();
      });
    });
  }
  
  async cleanupOldFiles() {
    try {
      const files = await fs.readdir(this.options.baseDir);
      const logFiles = files
        .filter(file => file.startsWith(path.basename(this.options.filename, path.extname(this.options.filename))))
        .filter(file => file !== this.options.filename)
        .map(file => ({
          name: file,
          path: path.join(this.options.baseDir, file),
          stats: null
        }));
      
      // Get file stats
      for (const file of logFiles) {
        try {
          file.stats = await fs.stat(file.path);
        } catch (error) {
          // File might have been deleted
        }
      }
      
      // Sort by modification time (oldest first)
      logFiles
        .filter(file => file.stats)
        .sort((a, b) => a.stats.mtime - b.stats.mtime);
      
      // Remove excess files
      if (logFiles.length > this.options.maxFiles) {
        const filesToDelete = logFiles.slice(0, logFiles.length - this.options.maxFiles);
        
        for (const file of filesToDelete) {
          try {
            await fs.unlink(file.path);
            console.log(`Cleaned up old log file: ${file.name}`);
            
            // Audit trail
            if (this.options.auditTrail) {
              this.auditManager.recordDeletion(file.name, 'cleanup');
            }
          } catch (error) {
            console.error(`Failed to delete file ${file.name}:`, error);
          }
        }
      }
    } catch (error) {
      console.error('Error during cleanup:', error);
    }
  }
  
  isTimeRotationDue(lastModified) {
    const now = Date.now();
    const interval = this.parseTimeInterval(this.options.rotationInterval);
    
    return (now - lastModified.getTime()) >= interval;
  }
  
  parseTimeInterval(interval) {
    const units = {
      's': 1000,
      'm': 60 * 1000,
      'h': 60 * 60 * 1000,
      'd': 24 * 60 * 60 * 1000,
      'w': 7 * 24 * 60 * 60 * 1000,
      'M': 30 * 24 * 60 * 60 * 1000
    };
    
    const match = interval.match(/^(\d+)([smhdwM])$/);
    if (!match) {
      throw new Error(`Invalid time interval: ${interval}`);
    }
    
    const [, number, unit] = match;
    return parseInt(number) * units[unit];
  }
  
  // Convenience methods
  trace(message, metadata) { return this.log('trace', message, metadata); }
  debug(message, metadata) { return this.log('debug', message, metadata); }
  info(message, metadata) { return this.log('info', message, metadata); }
  warn(message, metadata) { return this.log('warn', message, metadata); }
  error(message, metadata) { return this.log('error', message, metadata); }
  fatal(message, metadata) { return this.log('fatal', message, metadata); }
  
  // File management methods
  async listLogFiles() {
    try {
      const files = await fs.readdir(this.options.baseDir);
      const logFiles = [];
      
      for (const file of files) {
        const filePath = path.join(this.options.baseDir, file);
        const stats = await fs.stat(filePath);
        
        if (stats.isFile() && (
          file === this.options.filename ||
          file.startsWith(path.basename(this.options.filename, path.extname(this.options.filename)))
        )) {
          logFiles.push({
            name: file,
            path: filePath,
            size: stats.size,
            created: stats.birthtime,
            modified: stats.mtime,
            compressed: file.endsWith('.gz')
          });
        }
      }
      
      return logFiles.sort((a, b) => b.modified - a.modified);
    } catch (error) {
      console.error('Error listing log files:', error);
      return [];
    }
  }
  
  async readLogFile(filename, options = {}) {
    const filePath = path.join(this.options.baseDir, filename);
    
    try {
      let content;
      
      if (filename.endsWith('.gz')) {
        // Decompress and read
        if (options.decompress !== false) {
          const tempFile = await this.compressionManager.decompressFile(filePath);
          content = await fs.readFile(tempFile, 'utf8');
          await fs.unlink(tempFile); // Clean up temp file
        } else {
          throw new Error('Compressed file requires decompression');
        }
      } else {
        content = await fs.readFile(filePath, 'utf8');
      }
      
      // Decrypt if needed
      if (this.encryptor && options.decrypt !== false) {
        const lines = content.split('\n').filter(line => line.trim());
        const decryptedLines = lines.map(line => {
          try {
            const encryptedData = JSON.parse(line);
            return this.encryptor.decrypt(encryptedData);
          } catch (error) {
            return line; // Not encrypted
          }
        });
        content = decryptedLines.join('\n');
      }
      
      // Parse log entries if requested
      if (options.parse) {
        const lines = content.split('\n').filter(line => line.trim());
        return lines.map(line => {
          try {
            return JSON.parse(line);
          } catch (error) {
            return { raw: line };
          }
        });
      }
      
      return content;
    } catch (error) {
      console.error(`Error reading log file ${filename}:`, error);
      throw error;
    }
  }
  
  async searchLogs(query, options = {}) {
    const files = await this.listLogFiles();
    const results = [];
    
    for (const file of files) {
      try {
        const content = await this.readLogFile(file.name, { 
          parse: true, 
          decompress: true,
          decrypt: true 
        });
        
        const matches = content.filter(entry => {
          if (typeof entry === 'object' && entry.message) {
            return entry.message.toLowerCase().includes(query.toLowerCase()) ||
                   entry.level.toLowerCase().includes(query.toLowerCase()) ||
                   JSON.stringify(entry.metadata).toLowerCase().includes(query.toLowerCase());
          }
          return false;
        });
        
        if (matches.length > 0) {
          results.push({
            file: file.name,
            matches: matches.length,
            entries: options.includeEntries ? matches : undefined
          });
        }
      } catch (error) {
        console.error(`Error searching file ${file.name}:`, error);
      }
    }
    
    return results;
  }
  
  // Statistics and monitoring
  getStatistics() {
    const uptime = Date.now() - this.metrics.startTime;
    
    return {
      ...this.metrics,
      uptime,
      logsPerSecond: this.metrics.logsWritten / (uptime / 1000),
      bytesPerSecond: this.metrics.bytesWritten / (uptime / 1000),
      currentFile: this.currentFile,
      bufferSize: this.writeBuffer.length,
      streamWritable: this.currentStream ? this.currentStream.writable : false
    };
  }
  
  // Cleanup and shutdown
  async destroy() {
    try {
      // Clear timers
      if (this.flushTimer) {
        clearInterval(this.flushTimer);
      }
      
      if (this.rotationTimer) {
        clearInterval(this.rotationTimer);
      }
      
      // Close file watcher
      if (this.fileWatcher) {
        this.fileWatcher.close();
      }
      
      // Flush remaining buffer
      if (this.writeBuffer.length > 0) {
        await this.flush();
      }
      
      // Close current stream
      if (this.currentStream) {
        await this.closeCurrentStream();
      }
      
      console.log('File logger destroyed');
    } catch (error) {
      console.error('Error during file logger destruction:', error);
    }
  }
}
```

### 2. **Log File Rotation Strategies**
Advanced rotation strategies for managing log file lifecycle and storage optimization.

```javascript
// Advanced log rotation system
class LogRotationManager {
  constructor(options = {}) {
    this.options = {
      strategies: options.strategies || ['size', 'time', 'count'],
      sizeThreshold: options.sizeThreshold || 100 * 1024 * 1024, // 100MB
      timeThreshold: options.timeThreshold || '1d',
      countThreshold: options.countThreshold || 10000,
      maxFiles: options.maxFiles || 30,
      archiveOldFiles: options.archiveOldFiles !== false,
      compressionDelay: options.compressionDelay || 300000, // 5 minutes
      cleanupInterval: options.cleanupInterval || 3600000, // 1 hour
      customRotationRules: options.customRotationRules || [],
      ...options
    };
    
    this.rotationHistory = [];
    this.scheduledRotations = new Map();
    this.compressionQueue = [];
    this.metrics = this.initializeRotationMetrics();
    
    this.setupScheduledRotations();
    this.setupCompressionQueue();
    this.setupCleanupTasks();
  }
  
  initializeRotationMetrics() {
    return {
      totalRotations: 0,
      sizeBasedRotations: 0,
      timeBasedRotations: 0,
      countBasedRotations: 0,
      customRotations: 0,
      averageRotationTime: 0,
      totalBytesRotated: 0,
      compressionRatio: 0,
      lastRotation: null
    };
  }
  
  // Size-based rotation strategy
  createSizeRotationStrategy() {
    return {
      name: 'size',
      shouldRotate: async (filePath) => {
        try {
          const stats = await fs.stat(filePath);
          return stats.size >= this.options.sizeThreshold;
        } catch (error) {
          return false;
        }
      },
      
      execute: async (filePath, logger) => {
        const startTime = Date.now();
        const stats = await fs.stat(filePath);
        
        console.log(`Rotating file due to size: ${stats.size} bytes`);
        
        const rotatedFile = await this.performRotation(filePath, 'size');
        
        this.metrics.sizeBasedRotations++;
        this.metrics.totalBytesRotated += stats.size;
        
        return {
          reason: 'size',
          originalSize: stats.size,
          rotatedFile,
          duration: Date.now() - startTime
        };
      }
    };
  }
  
  // Time-based rotation strategy
  createTimeRotationStrategy() {
    return {
      name: 'time',
      shouldRotate: async (filePath) => {
        try {
          const stats = await fs.stat(filePath);
          const age = Date.now() - stats.mtime.getTime();
          const threshold = this.parseTimeInterval(this.options.timeThreshold);
          
          return age >= threshold;
        } catch (error) {
          return false;
        }
      },
      
      execute: async (filePath, logger) => {
        const startTime = Date.now();
        const stats = await fs.stat(filePath);
        
        console.log(`Rotating file due to age: ${stats.mtime}`);
        
        const rotatedFile = await this.performRotation(filePath, 'time');
        
        this.metrics.timeBasedRotations++;
        
        return {
          reason: 'time',
          fileAge: Date.now() - stats.mtime.getTime(),
          rotatedFile,
          duration: Date.now() - startTime
        };
      }
    };
  }
  
  // Count-based rotation strategy
  createCountRotationStrategy() {
    return {
      name: 'count',
      lineCount: 0,
      
      shouldRotate: async (filePath) => {
        // This strategy needs to track line count externally
        return this.lineCount >= this.options.countThreshold;
      },
      
      incrementCount: () => {
        this.lineCount++;
      },
      
      resetCount: () => {
        this.lineCount = 0;
      },
      
      execute: async (filePath, logger) => {
        const startTime = Date.now();
        
        console.log(`Rotating file due to line count: ${this.lineCount} lines`);
        
        const rotatedFile = await this.performRotation(filePath, 'count');
        
        this.resetCount();
        this.metrics.countBasedRotations++;
        
        return {
          reason: 'count',
          lineCount: this.lineCount,
          rotatedFile,
          duration: Date.now() - startTime
        };
      }
    };
  }
  
  // Custom rotation strategies
  createCustomRotationStrategy(rule) {
    return {
      name: `custom_${rule.name}`,
      rule,
      
      shouldRotate: async (filePath) => {
        try {
          const stats = await fs.stat(filePath);
          const context = {
            filePath,
            stats,
            currentTime: Date.now(),
            fileAge: Date.now() - stats.mtime.getTime(),
            fileSize: stats.size
          };
          
          return rule.condition(context);
        } catch (error) {
          return false;
        }
      },
      
      execute: async (filePath, logger) => {
        const startTime = Date.now();
        
        console.log(`Rotating file due to custom rule: ${rule.name}`);
        
        const rotatedFile = await this.performRotation(filePath, `custom_${rule.name}`);
        
        this.metrics.customRotations++;
        
        const result = {
          reason: `custom_${rule.name}`,
          rotatedFile,
          duration: Date.now() - startTime
        };
        
        // Execute custom post-rotation action if defined
        if (rule.postRotation) {
          await rule.postRotation(result);
        }
        
        return result;
      }
    };
  }
  
  setupScheduledRotations() {
    // Schedule time-based rotations
    if (this.options.strategies.includes('time')) {
      const interval = this.parseTimeInterval(this.options.timeThreshold);
      
      // Calculate next rotation time
      const now = new Date();
      const nextRotation = new Date(now.getTime() + interval);
      
      this.scheduleRotation('time', nextRotation);
    }
    
    // Schedule custom timed rotations
    this.options.customRotationRules.forEach(rule => {
      if (rule.schedule) {
        this.scheduleCustomRotation(rule);
      }
    });
  }
  
  scheduleRotation(type, scheduledTime) {
    const timeout = scheduledTime.getTime() - Date.now();
    
    if (timeout > 0) {
      const timeoutId = setTimeout(() => {
        this.triggerScheduledRotation(type);
      }, timeout);
      
      this.scheduledRotations.set(type, {
        timeoutId,
        scheduledTime,
        type
      });
      
      console.log(`Scheduled ${type} rotation for ${scheduledTime.toISOString()}`);
    }
  }
  
  scheduleCustomRotation(rule) {
    if (rule.schedule.cron) {
      // Implement cron-style scheduling
      const cronParser = require('cron-parser');
      const interval = cronParser.parseExpression(rule.schedule.cron);
      const nextDate = interval.next().toDate();
      
      this.scheduleRotation(`custom_${rule.name}`, nextDate);
    } else if (rule.schedule.interval) {
      const interval = this.parseTimeInterval(rule.schedule.interval);
      const nextDate = new Date(Date.now() + interval);
      
      this.scheduleRotation(`custom_${rule.name}`, nextDate);
    }
  }
  
  async triggerScheduledRotation(type) {
    try {
      console.log(`Triggering scheduled rotation: ${type}`);
      
      // Trigger rotation on all registered loggers
      await this.rotateAllLoggers(type);
      
      // Reschedule if it's a recurring rotation
      if (type === 'time' || type.startsWith('custom_')) {
        this.rescheduleRotation(type);
      }
    } catch (error) {
      console.error(`Error in scheduled rotation ${type}:`, error);
    }
  }
  
  rescheduleRotation(type) {
    if (type === 'time') {
      const interval = this.parseTimeInterval(this.options.timeThreshold);
      const nextRotation = new Date(Date.now() + interval);
      this.scheduleRotation(type, nextRotation);
    } else if (type.startsWith('custom_')) {
      const ruleName = type.replace('custom_', '');
      const rule = this.options.customRotationRules.find(r => r.name === ruleName);
      
      if (rule && rule.schedule) {
        this.scheduleCustomRotation(rule);
      }
    }
  }
  
  setupCompressionQueue() {
    this.compressionProcessor = {
      queue: [],
      processing: false,
      
      add: (filePath) => {
        this.compressionProcessor.queue.push({
          filePath,
          addedAt: Date.now()
        });
        
        // Start processing if not already running
        if (!this.compressionProcessor.processing) {
          setTimeout(() => {
            this.compressionProcessor.process();
          }, this.options.compressionDelay);
        }
      },
      
      process: async () => {
        if (this.compressionProcessor.processing || this.compressionProcessor.queue.length === 0) {
          return;
        }
        
        this.compressionProcessor.processing = true;
        
        try {
          while (this.compressionProcessor.queue.length > 0) {
            const item = this.compressionProcessor.queue.shift();
            
            try {
              await this.compressFile(item.filePath);
              console.log(`Compressed rotated file: ${item.filePath}`);
            } catch (error) {
              console.error(`Failed to compress ${item.filePath}:`, error);
            }
          }
        } finally {
          this.compressionProcessor.processing = false;
        }
      }
    };
  }
  
  setupCleanupTasks() {
    // Regular cleanup of old rotated files
    setInterval(async () => {
      await this.cleanupOldFiles();
    }, this.options.cleanupInterval);
  }
  
  async performRotation(filePath, reason) {
    const startTime = Date.now();
    
    try {
      // Generate rotated filename
      const rotatedFilename = this.generateRotatedFilename(filePath, reason);
      const rotatedPath = path.join(path.dirname(filePath), rotatedFilename);
      
      // Move/copy file
      await fs.rename(filePath, rotatedPath);
      
      // Add to compression queue if archiving is enabled
      if (this.options.archiveOldFiles) {
        this.compressionProcessor.add(rotatedPath);
      }
      
      // Record rotation history
      const rotationRecord = {
        originalFile: path.basename(filePath),
        rotatedFile: rotatedFilename,
        reason,
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime
      };
      
      this.rotationHistory.push(rotationRecord);
      
      // Keep only last 100 rotation records
      if (this.rotationHistory.length > 100) {
        this.rotationHistory = this.rotationHistory.slice(-100);
      }
      
      // Update metrics
      this.metrics.totalRotations++;
      this.metrics.lastRotation = Date.now();
      
      const avgTime = this.metrics.averageRotationTime;
      const total = this.metrics.totalRotations;
      this.metrics.averageRotationTime = 
        (avgTime * (total - 1) + (Date.now() - startTime)) / total;
      
      return rotatedFilename;
    } catch (error) {
      console.error('Error during file rotation:', error);
      throw error;
    }
  }
  
  generateRotatedFilename(filePath, reason) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const basename = path.basename(filePath, path.extname(filePath));
    const extension = path.extname(filePath);
    
    return `${basename}.${timestamp}.${reason}${extension}`;
  }
  
  async compressFile(filePath) {
    const gzPath = filePath + '.gz';
    
    return new Promise((resolve, reject) => {
      const readStream = fsSync.createReadStream(filePath);
      const writeStream = fsSync.createWriteStream(gzPath);
      const gzipStream = zlib.createGzip({ level: 9 });
      
      let originalSize = 0;
      let compressedSize = 0;
      
      readStream.on('data', (chunk) => {
        originalSize += chunk.length;
      });
      
      writeStream.on('finish', async () => {
        try {
          const stats = await fs.stat(gzPath);
          compressedSize = stats.size;
          
          // Calculate compression ratio
          const ratio = (1 - compressedSize / originalSize) * 100;
          this.metrics.compressionRatio = 
            (this.metrics.compressionRatio + ratio) / 2; // Running average
          
          // Remove original file
          await fs.unlink(filePath);
          
          resolve(gzPath);
        } catch (error) {
          reject(error);
        }
      });
      
      readStream
        .pipe(gzipStream)
        .pipe(writeStream)
        .on('error', reject);
    });
  }
  
  async cleanupOldFiles() {
    try {
      // Implementation depends on specific cleanup strategy
      console.log('Performing cleanup of old log files...');
      
      // This would typically involve:
      // 1. Finding all rotated log files
      // 2. Sorting by age
      // 3. Removing files exceeding maxFiles limit
      // 4. Removing files older than retention period
      
    } catch (error) {
      console.error('Error during cleanup:', error);
    }
  }
  
  parseTimeInterval(interval) {
    const units = {
      's': 1000,
      'm': 60 * 1000,
      'h': 60 * 60 * 1000,
      'd': 24 * 60 * 60 * 1000,
      'w': 7 * 24 * 60 * 60 * 1000,
      'M': 30 * 24 * 60 * 60 * 1000
    };
    
    const match = interval.match(/^(\d+)([smhdwM])$/);
    if (!match) {
      throw new Error(`Invalid time interval: ${interval}`);
    }
    
    const [, number, unit] = match;
    return parseInt(number) * units[unit];
  }
  
  getRotationHistory() {
    return [...this.rotationHistory];
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
  
  // Cleanup
  destroy() {
    // Clear all scheduled rotations
    this.scheduledRotations.forEach(({ timeoutId }) => {
      clearTimeout(timeoutId);
    });
    
    this.scheduledRotations.clear();
  }
}
```

## File System Best Practices

### **Production File Logging Configuration**
```javascript
// Production-ready file logging setup
class ProductionFileLogger {
  constructor(options = {}) {
    this.environment = process.env.NODE_ENV || 'development';
    this.serviceName = process.env.SERVICE_NAME || 'app';
    this.instanceId = process.env.INSTANCE_ID || require('os').hostname();
    
    this.fileLogger = new AdvancedFileLogger({
      baseDir: options.baseDir || `/var/log/${this.serviceName}`,
      filename: `${this.serviceName}-${this.instanceId}.log`,
      
      // Production settings
      maxFileSize: 500 * 1024 * 1024, // 500MB
      maxFiles: 50,
      compression: true,
      compressionLevel: 9,
      
      // Rotation strategy
      rotationStrategy: 'size',
      rotationInterval: '1d',
      
      // Performance settings
      bufferSize: 256 * 1024, // 256KB
      flushInterval: 5000, // 5 seconds
      
      // Security settings
      fileMode: 0o640, // Read/write for owner, read for group
      dirMode: 0o750,
      
      // Monitoring
      auditTrail: true,
      watchFiles: true,
      
      // Environment-specific encryption
      encryption: this.environment === 'production' ? {
        algorithm: 'aes-256-gcm',
        key: process.env.LOG_ENCRYPTION_KEY
      } : null
    });
    
    this.rotationManager = new LogRotationManager({
      sizeThreshold: 500 * 1024 * 1024,
      timeThreshold: '1d',
      maxFiles: 50,
      archiveOldFiles: true,
      compressionDelay: 300000, // 5 minutes
      
      // Custom rotation rules
      customRotationRules: [
        {
          name: 'error_threshold',
          condition: (context) => {
            // Rotate if file contains too many errors
            return this.checkErrorThreshold(context.filePath);
          },
          postRotation: async (result) => {
            // Alert on error-triggered rotation
            await this.alertOnErrorRotation(result);
          }
        },
        {
          name: 'daily_archive',
          schedule: {
            cron: '0 0 * * *' // Daily at midnight
          }
        }
      ]
    });
    
    this.setupHealthMonitoring();
    this.setupGracefulShutdown();
  }
  
  async checkErrorThreshold(filePath) {
    try {
      // Read last 1000 lines and check error ratio
      const content = await this.fileLogger.readLogFile(
        path.basename(filePath), 
        { parse: true }
      );
      
      const recent = content.slice(-1000);
      const errorCount = recent.filter(entry => 
        entry.level === 'ERROR' || entry.level === 'FATAL'
      ).length;
      
      return errorCount / recent.length > 0.1; // 10% error threshold
    } catch (error) {
      return false;
    }
  }
  
  async alertOnErrorRotation(result) {
    // Send alert through monitoring system
    console.error('Log rotated due to high error rate:', result);
    
    // Could integrate with alerting systems like:
    // - PagerDuty
    // - Slack
    // - Email
    // - Monitoring dashboards
  }
  
  setupHealthMonitoring() {
    // Monitor disk space
    setInterval(async () => {
      const stats = this.fileLogger.getStatistics();
      
      if (stats.diskSpace.free < 1024 * 1024 * 1024) { // 1GB
        console.error('Low disk space warning:', stats.diskSpace);
      }
      
      if (stats.errors > 10) {
        console.error('High error rate in file logger:', stats.errors);
      }
    }, 60000); // Check every minute
  }
  
  setupGracefulShutdown() {
    const shutdown = async () => {
      console.log('Shutting down file logger...');
      await this.fileLogger.destroy();
      await this.rotationManager.destroy();
      process.exit(0);
    };
    
    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);
    process.on('uncaughtException', async (error) => {
      console.error('Uncaught exception:', error);
      await this.fileLogger.error('Uncaught exception', { error: error.stack });
      await shutdown();
    });
  }
  
  // Logging methods with production enhancements
  async log(level, message, metadata = {}) {
    const enrichedMetadata = {
      ...metadata,
      service: this.serviceName,
      instance: this.instanceId,
      environment: this.environment,
      version: process.env.APP_VERSION,
      requestId: metadata.requestId || this.generateRequestId(),
      userId: metadata.userId,
      sessionId: metadata.sessionId
    };
    
    await this.fileLogger.log(level, message, enrichedMetadata);
  }
  
  generateRequestId() {
    return Math.random().toString(36).substring(2, 15) + 
           Math.random().toString(36).substring(2, 15);
  }
  
  // Convenience methods
  info(message, metadata) { return this.log('info', message, metadata); }
  warn(message, metadata) { return this.log('warn', message, metadata); }
  error(message, metadata) { return this.log('error', message, metadata); }
  debug(message, metadata) { return this.log('debug', message, metadata); }
  
  // Administrative methods
  async getLogFiles() {
    return this.fileLogger.listLogFiles();
  }
  
  async searchLogs(query, options) {
    return this.fileLogger.searchLogs(query, options);
  }
  
  getHealthStatus() {
    return {
      fileLogger: this.fileLogger.getStatistics(),
      rotationManager: this.rotationManager.getMetrics(),
      environment: this.environment,
      service: this.serviceName,
      instance: this.instanceId
    };
  }
}

// Usage example
const logger = new ProductionFileLogger({
  baseDir: '/var/log/myapp'
});

// Application logging
logger.info('Application started', { port: 3000 });
logger.error('Database connection failed', { 
  error: 'Connection timeout',
  database: 'primary',
  retryAttempt: 3 
});

// Health monitoring
setInterval(() => {
  const health = logger.getHealthStatus();
  console.log('Logger health:', health);
}, 300000); // Every 5 minutes
```

---

**Previous**: [2.3.1 Console Output](./2.3.1_Console_Output.md)  
**Next**: [2.3.3 Network Endpoints](./2.3.3_Network_Endpoints.md)
