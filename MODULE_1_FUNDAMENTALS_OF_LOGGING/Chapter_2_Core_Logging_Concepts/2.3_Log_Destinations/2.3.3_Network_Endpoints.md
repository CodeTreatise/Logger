# 2.3.3 Network Endpoints

## Understanding Network-Based Logging

Network endpoints enable distributed logging architectures where log data is transmitted over networks to centralized collectors, remote services, or cloud platforms. This section covers advanced network logging protocols, transport mechanisms, and enterprise-grade network logging implementations.

## Advanced Network Logging Implementation

### 1. **Comprehensive Network Logger**
Enterprise-grade network logging system supporting multiple protocols and transport mechanisms.

```javascript
// Advanced network logging implementation
const net = require('net');
const http = require('http');
const https = require('https');
const dgram = require('dgram');
const tls = require('tls');
const { EventEmitter } = require('events');
const zlib = require('zlib');
const crypto = require('crypto');

class AdvancedNetworkLogger extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.options = {
      protocol: options.protocol || 'http', // 'http', 'https', 'tcp', 'udp', 'syslog', 'websocket'
      host: options.host || 'localhost',
      port: options.port || this.getDefaultPort(options.protocol),
      path: options.path || '/logs',
      
      // Connection settings
      timeout: options.timeout || 30000,
      keepAlive: options.keepAlive !== false,
      keepAliveInitialDelay: options.keepAliveInitialDelay || 0,
      maxConnections: options.maxConnections || 10,
      connectionRetries: options.connectionRetries || 3,
      retryDelay: options.retryDelay || 1000,
      
      // Security settings
      ssl: options.ssl || {},
      authentication: options.authentication || null,
      apiKey: options.apiKey || null,
      
      // Performance settings
      batchSize: options.batchSize || 100,
      batchTimeout: options.batchTimeout || 5000,
      compression: options.compression || false,
      compressionLevel: options.compressionLevel || 6,
      
      // Message formatting
      format: options.format || 'json', // 'json', 'text', 'syslog', 'custom'
      encoding: options.encoding || 'utf8',
      
      // Error handling
      errorThreshold: options.errorThreshold || 10,
      circuitBreakerTimeout: options.circuitBreakerTimeout || 60000,
      
      // Monitoring
      enableMetrics: options.enableMetrics !== false,
      metricsInterval: options.metricsInterval || 60000,
      
      ...options
    };
    
    this.connectionPool = new Map();
    this.messageQueue = [];
    this.batchTimer = null;
    this.metrics = this.initializeMetrics();
    this.circuitBreaker = this.initializeCircuitBreaker();
    this.protocolHandlers = this.setupProtocolHandlers();
    this.authManager = this.setupAuthenticationManager();
    this.compressionManager = this.setupCompressionManager();
    this.retryManager = this.setupRetryManager();
    
    this.initialize();
  }
  
  getDefaultPort(protocol) {
    const defaultPorts = {
      http: 80,
      https: 443,
      tcp: 9999,
      udp: 514,
      syslog: 514,
      websocket: 80,
      secure_websocket: 443
    };
    
    return defaultPorts[protocol] || 9999;
  }
  
  initializeMetrics() {
    return {
      messagesSent: 0,
      messagesQueued: 0,
      messagesFailed: 0,
      bytesTransmitted: 0,
      connectionsCreated: 0,
      connectionsFailed: 0,
      retriesAttempted: 0,
      compressionRatio: 0,
      averageLatency: 0,
      circuitBreakerTrips: 0,
      startTime: Date.now(),
      lastTransmission: null,
      errorCounts: new Map(),
      protocolStats: new Map()
    };
  }
  
  initializeCircuitBreaker() {
    return {
      state: 'CLOSED', // 'CLOSED', 'OPEN', 'HALF_OPEN'
      failureCount: 0,
      lastFailureTime: null,
      nextAttemptTime: null,
      
      recordSuccess: () => {
        this.circuitBreaker.failureCount = 0;
        this.circuitBreaker.state = 'CLOSED';
      },
      
      recordFailure: () => {
        this.circuitBreaker.failureCount++;
        this.circuitBreaker.lastFailureTime = Date.now();
        
        if (this.circuitBreaker.failureCount >= this.options.errorThreshold) {
          this.circuitBreaker.state = 'OPEN';
          this.circuitBreaker.nextAttemptTime = 
            Date.now() + this.options.circuitBreakerTimeout;
          this.metrics.circuitBreakerTrips++;
          
          console.warn('Circuit breaker opened due to failures');
          this.emit('circuitBreakerOpen', {
            failureCount: this.circuitBreaker.failureCount,
            nextAttemptTime: this.circuitBreaker.nextAttemptTime
          });
        }
      },
      
      canAttempt: () => {
        if (this.circuitBreaker.state === 'CLOSED') return true;
        if (this.circuitBreaker.state === 'HALF_OPEN') return true;
        
        if (this.circuitBreaker.state === 'OPEN') {
          if (Date.now() >= this.circuitBreaker.nextAttemptTime) {
            this.circuitBreaker.state = 'HALF_OPEN';
            console.log('Circuit breaker transitioning to half-open');
            return true;
          }
        }
        
        return false;
      }
    };
  }
  
  setupProtocolHandlers() {
    return {
      // HTTP/HTTPS Protocol Handler
      http: {
        send: async (messages) => {
          const client = this.options.protocol === 'https' ? https : http;
          const data = this.formatMessages(messages);
          
          const requestOptions = {
            hostname: this.options.host,
            port: this.options.port,
            path: this.options.path,
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(data),
              'User-Agent': 'AdvancedNetworkLogger/1.0'
            },
            timeout: this.options.timeout
          };
          
          // Add authentication headers
          if (this.options.authentication) {
            Object.assign(requestOptions.headers, 
              await this.authManager.getHeaders());
          }
          
          if (this.options.apiKey) {
            requestOptions.headers['X-API-Key'] = this.options.apiKey;
          }
          
          // Add SSL options for HTTPS
          if (this.options.protocol === 'https') {
            Object.assign(requestOptions, this.options.ssl);
          }
          
          return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            const req = client.request(requestOptions, (res) => {
              let responseData = '';
              
              res.on('data', (chunk) => {
                responseData += chunk;
              });
              
              res.on('end', () => {
                const latency = Date.now() - startTime;
                this.updateLatencyMetrics(latency);
                
                if (res.statusCode >= 200 && res.statusCode < 300) {
                  resolve({
                    statusCode: res.statusCode,
                    responseData,
                    latency
                  });
                } else {
                  reject(new Error(`HTTP ${res.statusCode}: ${responseData}`));
                }
              });
            });
            
            req.on('error', reject);
            req.on('timeout', () => {
              req.destroy();
              reject(new Error('Request timeout'));
            });
            
            req.write(data);
            req.end();
          });
        }
      },
      
      // TCP Protocol Handler
      tcp: {
        connections: new Map(),
        
        getConnection: async () => {
          const connectionKey = `${this.options.host}:${this.options.port}`;
          
          if (this.protocolHandlers.tcp.connections.has(connectionKey)) {
            const conn = this.protocolHandlers.tcp.connections.get(connectionKey);
            if (!conn.destroyed) {
              return conn;
            } else {
              this.protocolHandlers.tcp.connections.delete(connectionKey);
            }
          }
          
          return new Promise((resolve, reject) => {
            const socket = new net.Socket();
            
            socket.connect(this.options.port, this.options.host, () => {
              this.protocolHandlers.tcp.connections.set(connectionKey, socket);
              this.metrics.connectionsCreated++;
              resolve(socket);
            });
            
            socket.on('error', (error) => {
              this.metrics.connectionsFailed++;
              reject(error);
            });
            
            socket.on('close', () => {
              this.protocolHandlers.tcp.connections.delete(connectionKey);
            });
            
            socket.setTimeout(this.options.timeout, () => {
              socket.destroy();
              reject(new Error('TCP connection timeout'));
            });
          });
        },
        
        send: async (messages) => {
          const data = this.formatMessages(messages) + '\n';
          const socket = await this.protocolHandlers.tcp.getConnection();
          
          return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            socket.write(data, this.options.encoding, (error) => {
              const latency = Date.now() - startTime;
              this.updateLatencyMetrics(latency);
              
              if (error) {
                reject(error);
              } else {
                resolve({ latency });
              }
            });
          });
        }
      },
      
      // UDP Protocol Handler
      udp: {
        client: null,
        
        getClient: () => {
          if (!this.protocolHandlers.udp.client) {
            this.protocolHandlers.udp.client = dgram.createSocket('udp4');
            
            this.protocolHandlers.udp.client.on('error', (error) => {
              console.error('UDP client error:', error);
              this.metrics.connectionsFailed++;
            });
          }
          
          return this.protocolHandlers.udp.client;
        },
        
        send: async (messages) => {
          const data = this.formatMessages(messages);
          const client = this.protocolHandlers.udp.getClient();
          
          return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            client.send(
              data,
              0,
              data.length,
              this.options.port,
              this.options.host,
              (error) => {
                const latency = Date.now() - startTime;
                this.updateLatencyMetrics(latency);
                
                if (error) {
                  reject(error);
                } else {
                  resolve({ latency });
                }
              }
            );
          });
        }
      },
      
      // Syslog Protocol Handler
      syslog: {
        send: async (messages) => {
          const formattedMessages = messages.map(msg => 
            this.formatSyslogMessage(msg)
          );
          
          // Use UDP for syslog by default
          return this.protocolHandlers.udp.send(formattedMessages);
        }
      },
      
      // WebSocket Protocol Handler
      websocket: {
        connection: null,
        reconnectTimer: null,
        
        connect: async () => {
          const WebSocket = require('ws');
          const protocol = this.options.ssl ? 'wss' : 'ws';
          const url = `${protocol}://${this.options.host}:${this.options.port}${this.options.path}`;
          
          return new Promise((resolve, reject) => {
            const ws = new WebSocket(url, this.options.ssl);
            
            ws.on('open', () => {
              this.protocolHandlers.websocket.connection = ws;
              this.metrics.connectionsCreated++;
              console.log('WebSocket connected');
              resolve(ws);
            });
            
            ws.on('error', (error) => {
              this.metrics.connectionsFailed++;
              reject(error);
            });
            
            ws.on('close', () => {
              this.protocolHandlers.websocket.connection = null;
              console.log('WebSocket disconnected');
              
              // Auto-reconnect
              if (!this.protocolHandlers.websocket.reconnectTimer) {
                this.protocolHandlers.websocket.reconnectTimer = setTimeout(() => {
                  this.protocolHandlers.websocket.reconnectTimer = null;
                  this.protocolHandlers.websocket.connect().catch(console.error);
                }, this.options.retryDelay);
              }
            });
            
            ws.on('message', (data) => {
              // Handle server responses
              try {
                const response = JSON.parse(data);
                this.emit('serverResponse', response);
              } catch (error) {
                // Ignore non-JSON messages
              }
            });
          });
        },
        
        send: async (messages) => {
          if (!this.protocolHandlers.websocket.connection) {
            await this.protocolHandlers.websocket.connect();
          }
          
          const data = this.formatMessages(messages);
          
          return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            this.protocolHandlers.websocket.connection.send(data, (error) => {
              const latency = Date.now() - startTime;
              this.updateLatencyMetrics(latency);
              
              if (error) {
                reject(error);
              } else {
                resolve({ latency });
              }
            });
          });
        }
      }
    };
  }
  
  setupAuthenticationManager() {
    return {
      getHeaders: async () => {
        const auth = this.options.authentication;
        
        if (!auth) return {};
        
        switch (auth.type) {
          case 'basic':
            const credentials = Buffer.from(`${auth.username}:${auth.password}`).toString('base64');
            return { 'Authorization': `Basic ${credentials}` };
            
          case 'bearer':
            return { 'Authorization': `Bearer ${auth.token}` };
            
          case 'oauth2':
            const token = await this.authManager.getOAuth2Token();
            return { 'Authorization': `Bearer ${token}` };
            
          case 'custom':
            return auth.getHeaders ? await auth.getHeaders() : {};
            
          default:
            return {};
        }
      },
      
      getOAuth2Token: async () => {
        const auth = this.options.authentication;
        
        // Simple OAuth2 client credentials flow
        if (auth.tokenEndpoint && auth.clientId && auth.clientSecret) {
          const tokenData = await this.requestOAuth2Token(auth);
          return tokenData.access_token;
        }
        
        throw new Error('OAuth2 configuration incomplete');
      },
      
      requestOAuth2Token: async (auth) => {
        // Implementation would depend on OAuth2 provider
        // This is a simplified example
        const postData = `grant_type=client_credentials&client_id=${auth.clientId}&client_secret=${auth.clientSecret}`;
        
        // Make HTTP request to token endpoint
        // Return parsed token response
        return { access_token: 'example_token', expires_in: 3600 };
      }
    };
  }
  
  setupCompressionManager() {
    return {
      compress: async (data) => {
        if (!this.options.compression) return data;
        
        return new Promise((resolve, reject) => {
          zlib.gzip(data, { level: this.options.compressionLevel }, (error, compressed) => {
            if (error) {
              reject(error);
            } else {
              const ratio = 1 - (compressed.length / data.length);
              this.metrics.compressionRatio = 
                (this.metrics.compressionRatio + ratio) / 2;
              
              resolve(compressed);
            }
          });
        });
      },
      
      decompress: async (compressedData) => {
        return new Promise((resolve, reject) => {
          zlib.gunzip(compressedData, (error, decompressed) => {
            if (error) {
              reject(error);
            } else {
              resolve(decompressed);
            }
          });
        });
      }
    };
  }
  
  setupRetryManager() {
    return {
      execute: async (operation, maxRetries = this.options.connectionRetries) => {
        let lastError;
        
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          try {
            const result = await operation();
            
            if (attempt > 0) {
              console.log(`Operation succeeded after ${attempt} retries`);
            }
            
            return result;
          } catch (error) {
            lastError = error;
            this.metrics.retriesAttempted++;
            
            if (attempt < maxRetries) {
              const delay = this.calculateRetryDelay(attempt);
              console.warn(`Operation failed (attempt ${attempt + 1}/${maxRetries + 1}), retrying in ${delay}ms:`, error.message);
              
              await this.sleep(delay);
            }
          }
        }
        
        throw lastError;
      },
      
      calculateRetryDelay: (attempt) => {
        // Exponential backoff with jitter
        const baseDelay = this.options.retryDelay;
        const exponentialDelay = Math.pow(2, attempt) * baseDelay;
        const jitter = Math.random() * baseDelay;
        
        return Math.min(exponentialDelay + jitter, 30000); // Max 30 seconds
      }
    };
  }
  
  async initialize() {
    try {
      // Setup periodic metrics reporting
      if (this.options.enableMetrics) {
        this.metricsTimer = setInterval(() => {
          this.emitMetrics();
        }, this.options.metricsInterval);
      }
      
      // Setup batch processing
      this.setupBatchProcessing();
      
      // Test initial connection
      await this.testConnection();
      
      console.log(`Network logger initialized: ${this.options.protocol}://${this.options.host}:${this.options.port}`);
      
    } catch (error) {
      console.error('Failed to initialize network logger:', error);
      throw error;
    }
  }
  
  setupBatchProcessing() {
    this.batchProcessor = {
      add: (message) => {
        this.messageQueue.push({
          ...message,
          timestamp: Date.now()
        });
        
        this.metrics.messagesQueued++;
        
        // Trigger batch if size limit reached
        if (this.messageQueue.length >= this.options.batchSize) {
          this.processBatch();
        } else if (!this.batchTimer) {
          // Start timer for batch timeout
          this.batchTimer = setTimeout(() => {
            this.processBatch();
          }, this.options.batchTimeout);
        }
      },
      
      process: async () => {
        if (this.messageQueue.length === 0) return;
        
        const batch = [...this.messageQueue];
        this.messageQueue = [];
        
        if (this.batchTimer) {
          clearTimeout(this.batchTimer);
          this.batchTimer = null;
        }
        
        try {
          await this.sendBatch(batch);
        } catch (error) {
          console.error('Batch processing failed:', error);
          
          // Re-queue messages on failure
          this.messageQueue.unshift(...batch);
          this.metrics.messagesFailed += batch.length;
        }
      }
    };
  }
  
  async testConnection() {
    const testMessage = {
      level: 'INFO',
      message: 'Network logger connection test',
      timestamp: new Date().toISOString()
    };
    
    try {
      await this.sendMessage(testMessage);
      console.log('Network connection test successful');
    } catch (error) {
      console.warn('Network connection test failed:', error.message);
      // Don't throw - allow logger to work in degraded mode
    }
  }
  
  async log(level, message, metadata = {}) {
    if (!this.circuitBreaker.canAttempt()) {
      console.warn('Circuit breaker open, dropping log message');
      return;
    }
    
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message,
      metadata: this.sanitizeMetadata(metadata),
      hostname: require('os').hostname(),
      pid: process.pid
    };
    
    // Add to batch queue
    this.batchProcessor.add(logEntry);
  }
  
  async sendMessage(message) {
    return this.sendBatch([message]);
  }
  
  async sendBatch(messages) {
    const startTime = Date.now();
    
    try {
      const handler = this.protocolHandlers[this.options.protocol];
      
      if (!handler) {
        throw new Error(`Unsupported protocol: ${this.options.protocol}`);
      }
      
      const result = await this.retryManager.execute(() => 
        handler.send(messages)
      );
      
      // Update metrics
      this.metrics.messagesSent += messages.length;
      this.metrics.lastTransmission = Date.now();
      
      // Calculate bytes transmitted
      const dataSize = JSON.stringify(messages).length;
      this.metrics.bytesTransmitted += dataSize;
      
      // Record success for circuit breaker
      this.circuitBreaker.recordSuccess();
      
      // Update protocol-specific stats
      const protocolStats = this.metrics.protocolStats.get(this.options.protocol) || 
        { requests: 0, bytes: 0, latency: 0 };
      
      protocolStats.requests++;
      protocolStats.bytes += dataSize;
      protocolStats.latency = result.latency || 0;
      
      this.metrics.protocolStats.set(this.options.protocol, protocolStats);
      
      return result;
      
    } catch (error) {
      this.handleSendError(error, messages);
      throw error;
    }
  }
  
  handleSendError(error, messages) {
    this.metrics.messagesFailed += messages.length;
    this.circuitBreaker.recordFailure();
    
    // Track error types
    const errorType = error.code || error.constructor.name;
    const errorCount = this.metrics.errorCounts.get(errorType) || 0;
    this.metrics.errorCounts.set(errorType, errorCount + 1);
    
    // Emit error event
    this.emit('error', {
      error,
      messages,
      timestamp: Date.now()
    });
  }
  
  async processBatch() {
    return this.batchProcessor.process();
  }
  
  formatMessages(messages) {
    switch (this.options.format) {
      case 'json':
        return JSON.stringify(messages.length === 1 ? messages[0] : messages);
        
      case 'text':
        return messages.map(msg => 
          `${msg.timestamp} [${msg.level}] ${msg.message}`
        ).join('\n');
        
      case 'syslog':
        return messages.map(msg => this.formatSyslogMessage(msg)).join('\n');
        
      case 'custom':
        return this.options.customFormatter ? 
          this.options.customFormatter(messages) : 
          JSON.stringify(messages);
        
      default:
        return JSON.stringify(messages);
    }
  }
  
  formatSyslogMessage(message) {
    // RFC 3164 Syslog format
    const facility = 16; // Local use 0
    const severity = this.getSyslogSeverity(message.level);
    const priority = facility * 8 + severity;
    
    const timestamp = new Date(message.timestamp).toISOString();
    const hostname = message.hostname || require('os').hostname();
    const tag = 'nodejs';
    
    return `<${priority}>${timestamp} ${hostname} ${tag}: ${message.message}`;
  }
  
  getSyslogSeverity(level) {
    const severityMap = {
      'FATAL': 0,   // Emergency
      'ERROR': 3,   // Error
      'WARN': 4,    // Warning
      'INFO': 6,    // Informational
      'DEBUG': 7,   // Debug
      'TRACE': 7    // Debug
    };
    
    return severityMap[level.toUpperCase()] || 6;
  }
  
  updateLatencyMetrics(latency) {
    const currentAvg = this.metrics.averageLatency;
    const count = this.metrics.messagesSent + 1;
    
    this.metrics.averageLatency = 
      (currentAvg * (count - 1) + latency) / count;
  }
  
  sanitizeMetadata(metadata) {
    if (typeof metadata !== 'object' || metadata === null) {
      return metadata;
    }
    
    const sanitized = {};
    const sensitiveKeys = ['password', 'token', 'apikey', 'secret', 'auth'];
    
    Object.entries(metadata).forEach(([key, value]) => {
      const lowerKey = key.toLowerCase();
      
      if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {
        sanitized[key] = '[REDACTED]';
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeMetadata(value);
      } else {
        sanitized[key] = value;
      }
    });
    
    return sanitized;
  }
  
  emitMetrics() {
    const uptime = Date.now() - this.metrics.startTime;
    const metricsSnapshot = {
      ...this.metrics,
      uptime,
      messagesPerSecond: this.metrics.messagesSent / (uptime / 1000),
      bytesPerSecond: this.metrics.bytesTransmitted / (uptime / 1000),
      errorRate: this.metrics.messagesFailed / (this.metrics.messagesSent + this.metrics.messagesFailed) * 100,
      queueSize: this.messageQueue.length,
      circuitBreakerState: this.circuitBreaker.state,
      protocolStats: Object.fromEntries(this.metrics.protocolStats),
      errorBreakdown: Object.fromEntries(this.metrics.errorCounts)
    };
    
    this.emit('metrics', metricsSnapshot);
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // Convenience methods
  trace(message, metadata) { return this.log('trace', message, metadata); }
  debug(message, metadata) { return this.log('debug', message, metadata); }
  info(message, metadata) { return this.log('info', message, metadata); }
  warn(message, metadata) { return this.log('warn', message, metadata); }
  error(message, metadata) { return this.log('error', message, metadata); }
  fatal(message, metadata) { return this.log('fatal', message, metadata); }
  
  // Management methods
  async flush() {
    return this.processBatch();
  }
  
  getMetrics() {
    return { ...this.metrics };
  }
  
  getConnectionStatus() {
    return {
      circuitBreakerState: this.circuitBreaker.state,
      queueSize: this.messageQueue.length,
      activeConnections: this.connectionPool.size,
      lastTransmission: this.metrics.lastTransmission
    };
  }
  
  // Cleanup
  async destroy() {
    try {
      // Flush remaining messages
      await this.flush();
      
      // Clear timers
      if (this.batchTimer) {
        clearTimeout(this.batchTimer);
      }
      
      if (this.metricsTimer) {
        clearInterval(this.metricsTimer);
      }
      
      // Close connections
      this.connectionPool.forEach(connection => {
        if (connection.destroy) {
          connection.destroy();
        } else if (connection.close) {
          connection.close();
        }
      });
      
      // Close protocol-specific connections
      if (this.protocolHandlers.udp.client) {
        this.protocolHandlers.udp.client.close();
      }
      
      if (this.protocolHandlers.websocket.connection) {
        this.protocolHandlers.websocket.connection.close();
      }
      
      console.log('Network logger destroyed');
    } catch (error) {
      console.error('Error during network logger destruction:', error);
    }
  }
}
```

### 2. **Protocol-Specific Implementations**
Specialized implementations for different network protocols and logging standards.

```javascript
// Specialized network protocol implementations
class ProtocolSpecificLoggers {
  
  // GELF (Graylog Extended Log Format) Implementation
  static createGELFLogger(options = {}) {
    return new AdvancedNetworkLogger({
      ...options,
      protocol: 'udp',
      port: options.port || 12201,
      format: 'custom',
      customFormatter: (messages) => {
        return messages.map(msg => {
          const gelfMessage = {
            version: '1.1',
            host: require('os').hostname(),
            short_message: msg.message,
            full_message: msg.message,
            timestamp: Date.parse(msg.timestamp) / 1000,
            level: ProtocolSpecificLoggers.getGELFLevel(msg.level),
            facility: 'nodejs',
            ...msg.metadata
          };
          
          return JSON.stringify(gelfMessage);
        }).join('\n');
      }
    });
  }
  
  static getGELFLevel(level) {
    const levelMap = {
      'FATAL': 0,
      'ERROR': 3,
      'WARN': 4,
      'INFO': 6,
      'DEBUG': 7,
      'TRACE': 7
    };
    
    return levelMap[level.toUpperCase()] || 6;
  }
  
  // Fluentd Forward Protocol Implementation
  static createFluentdLogger(options = {}) {
    const msgpack = require('msgpack5')();
    
    return new AdvancedNetworkLogger({
      ...options,
      protocol: 'tcp',
      port: options.port || 24224,
      format: 'custom',
      customFormatter: (messages) => {
        const events = messages.map(msg => [
          options.tag || 'app',
          Math.floor(Date.parse(msg.timestamp) / 1000),
          {
            level: msg.level,
            message: msg.message,
            ...msg.metadata
          }
        ]);
        
        return msgpack.encode(events);
      }
    });
  }
  
  // Logstash TCP Input Implementation
  static createLogstashLogger(options = {}) {
    return new AdvancedNetworkLogger({
      ...options,
      protocol: 'tcp',
      port: options.port || 5000,
      format: 'custom',
      customFormatter: (messages) => {
        return messages.map(msg => {
          const logstashEvent = {
            '@timestamp': msg.timestamp,
            '@version': '1',
            level: msg.level,
            message: msg.message,
            host: require('os').hostname(),
            ...msg.metadata
          };
          
          return JSON.stringify(logstashEvent);
        }).join('\n');
      }
    });
  }
  
  // Elasticsearch Direct Implementation
  static createElasticsearchLogger(options = {}) {
    return new AdvancedNetworkLogger({
      ...options,
      protocol: 'https',
      port: options.port || 9200,
      path: `/${options.index || 'logs'}/_bulk`,
      format: 'custom',
      authentication: options.authentication,
      customFormatter: (messages) => {
        const bulkData = [];
        
        messages.forEach(msg => {
          // Index operation
          bulkData.push(JSON.stringify({
            index: {
              _index: options.index || 'logs',
              _type: '_doc'
            }
          }));
          
          // Document
          bulkData.push(JSON.stringify({
            '@timestamp': msg.timestamp,
            level: msg.level,
            message: msg.message,
            host: require('os').hostname(),
            ...msg.metadata
          }));
        });
        
        return bulkData.join('\n') + '\n';
      }
    });
  }
  
  // Splunk HEC (HTTP Event Collector) Implementation
  static createSplunkLogger(options = {}) {
    return new AdvancedNetworkLogger({
      ...options,
      protocol: 'https',
      port: options.port || 8088,
      path: '/services/collector/event',
      format: 'custom',
      authentication: {
        type: 'bearer',
        token: options.hecToken
      },
      customFormatter: (messages) => {
        const events = messages.map(msg => ({
          time: Date.parse(msg.timestamp) / 1000,
          host: require('os').hostname(),
          source: options.source || 'nodejs',
          sourcetype: options.sourcetype || 'json',
          index: options.index,
          event: {
            level: msg.level,
            message: msg.message,
            ...msg.metadata
          }
        }));
        
        // Splunk expects one JSON object per line
        return events.map(event => JSON.stringify(event)).join('\n');
      }
    });
  }
  
  // CloudWatch Logs Implementation
  static createCloudWatchLogger(options = {}) {
    const AWS = require('aws-sdk');
    
    class CloudWatchNetworkLogger extends AdvancedNetworkLogger {
      constructor(cwOptions) {
        super({
          ...cwOptions,
          protocol: 'custom'
        });
        
        this.cloudWatchLogs = new AWS.CloudWatchLogs({
          region: cwOptions.region || 'us-east-1',
          accessKeyId: cwOptions.accessKeyId,
          secretAccessKey: cwOptions.secretAccessKey
        });
        
        this.logGroupName = cwOptions.logGroupName;
        this.logStreamName = cwOptions.logStreamName || 
          `${require('os').hostname()}-${Date.now()}`;
        
        this.sequenceToken = null;
        
        this.setupCloudWatchStream();
      }
      
      async setupCloudWatchStream() {
        try {
          // Create log group if it doesn't exist
          await this.cloudWatchLogs.createLogGroup({
            logGroupName: this.logGroupName
          }).promise();
        } catch (error) {
          if (error.code !== 'ResourceAlreadyExistsException') {
            throw error;
          }
        }
        
        try {
          // Create log stream
          await this.cloudWatchLogs.createLogStream({
            logGroupName: this.logGroupName,
            logStreamName: this.logStreamName
          }).promise();
        } catch (error) {
          if (error.code !== 'ResourceAlreadyExistsException') {
            throw error;
          }
        }
      }
      
      async sendBatch(messages) {
        const logEvents = messages.map(msg => ({
          timestamp: Date.parse(msg.timestamp),
          message: JSON.stringify({
            level: msg.level,
            message: msg.message,
            ...msg.metadata
          })
        }));
        
        const params = {
          logGroupName: this.logGroupName,
          logStreamName: this.logStreamName,
          logEvents
        };
        
        if (this.sequenceToken) {
          params.sequenceToken = this.sequenceToken;
        }
        
        try {
          const result = await this.cloudWatchLogs.putLogEvents(params).promise();
          this.sequenceToken = result.nextSequenceToken;
          
          return { latency: 0, messages: messages.length };
        } catch (error) {
          if (error.code === 'InvalidSequenceTokenException') {
            // Update sequence token and retry
            this.sequenceToken = error.expectedSequenceToken;
            return this.sendBatch(messages);
          }
          
          throw error;
        }
      }
    }
    
    return new CloudWatchNetworkLogger(options);
  }
  
  // Azure Monitor Implementation
  static createAzureMonitorLogger(options = {}) {
    return new AdvancedNetworkLogger({
      ...options,
      protocol: 'https',
      host: `${options.workspaceId}.ods.opinsights.azure.com`,
      port: 443,
      path: `/api/logs?api-version=2016-04-01`,
      format: 'custom',
      authentication: {
        type: 'custom',
        getHeaders: async () => {
          const date = new Date().toUTCString();
          const signature = ProtocolSpecificLoggers.buildAzureSignature(
            options.sharedKey,
            date,
            JSON.stringify([])
          );
          
          return {
            'Authorization': `SharedKey ${options.workspaceId}:${signature}`,
            'Log-Type': options.logType || 'ApplicationLog',
            'x-ms-date': date,
            'Content-Type': 'application/json'
          };
        }
      },
      customFormatter: (messages) => {
        return JSON.stringify(messages.map(msg => ({
          TimeGenerated: msg.timestamp,
          Level: msg.level,
          Message: msg.message,
          Computer: require('os').hostname(),
          ...msg.metadata
        })));
      }
    });
  }
  
  static buildAzureSignature(sharedKey, date, content) {
    const crypto = require('crypto');
    
    const stringToHash = [
      'POST',
      content.length,
      'application/json',
      `x-ms-date:${date}`,
      '/api/logs'
    ].join('\n');
    
    const key = Buffer.from(sharedKey, 'base64');
    const signature = crypto.createHmac('sha256', key)
      .update(stringToHash, 'utf8')
      .digest('base64');
    
    return signature;
  }
}
```

## Network Logging Best Practices

### **Production Network Logging Configuration**
```javascript
// Production-ready network logging setup
class ProductionNetworkLogger {
  constructor(options = {}) {
    this.environment = process.env.NODE_ENV || 'development';
    this.primaryLogger = this.createPrimaryLogger(options.primary);
    this.fallbackLogger = this.createFallbackLogger(options.fallback);
    this.bufferLogger = this.createBufferLogger();
    
    this.setupHealthChecks();
    this.setupFailover();
    this.setupMonitoring();
  }
  
  createPrimaryLogger(options) {
    const loggerType = options.type || 'elasticsearch';
    
    switch (loggerType) {
      case 'elasticsearch':
        return ProtocolSpecificLoggers.createElasticsearchLogger({
          host: options.host || 'elasticsearch.internal',
          port: options.port || 9200,
          index: `logs-${this.environment}-${new Date().toISOString().slice(0, 7)}`,
          authentication: {
            type: 'basic',
            username: process.env.ES_USERNAME,
            password: process.env.ES_PASSWORD
          },
          compression: true,
          batchSize: 100,
          batchTimeout: 5000,
          connectionRetries: 3,
          retryDelay: 1000
        });
        
      case 'splunk':
        return ProtocolSpecificLoggers.createSplunkLogger({
          host: options.host || 'splunk.internal',
          port: options.port || 8088,
          hecToken: process.env.SPLUNK_HEC_TOKEN,
          source: process.env.SERVICE_NAME,
          sourcetype: 'json',
          index: `${this.environment}_logs`
        });
        
      case 'cloudwatch':
        return ProtocolSpecificLoggers.createCloudWatchLogger({
          region: process.env.AWS_REGION || 'us-east-1',
          logGroupName: `/aws/application/${process.env.SERVICE_NAME}`,
          logStreamName: `${require('os').hostname()}-${Date.now()}`
        });
        
      default:
        throw new Error(`Unsupported logger type: ${loggerType}`);
    }
  }
  
  createFallbackLogger(options) {
    // Always use file system as fallback
    const fs = require('fs');
    const path = require('path');
    
    return {
      log: async (level, message, metadata) => {
        const logEntry = {
          timestamp: new Date().toISOString(),
          level,
          message,
          metadata,
          source: 'fallback'
        };
        
        const logDir = options.logDir || '/var/log/app';
        const logFile = path.join(logDir, 'fallback.log');
        
        try {
          await fs.promises.appendFile(
            logFile,
            JSON.stringify(logEntry) + '\n'
          );
        } catch (error) {
          console.error('Fallback logging failed:', error);
        }
      }
    };
  }
  
  createBufferLogger() {
    return {
      buffer: [],
      maxSize: 10000,
      
      add: (level, message, metadata) => {
        if (this.bufferLogger.buffer.length >= this.bufferLogger.maxSize) {
          this.bufferLogger.buffer.shift(); // Remove oldest
        }
        
        this.bufferLogger.buffer.push({
          timestamp: new Date().toISOString(),
          level,
          message,
          metadata
        });
      },
      
      flush: async (targetLogger) => {
        const entries = [...this.bufferLogger.buffer];
        this.bufferLogger.buffer = [];
        
        for (const entry of entries) {
          try {
            await targetLogger.log(entry.level, entry.message, entry.metadata);
          } catch (error) {
            console.error('Buffer flush failed for entry:', error);
          }
        }
        
        console.log(`Flushed ${entries.length} buffered log entries`);
      },
      
      getSize: () => this.bufferLogger.buffer.length
    };
  }
  
  setupHealthChecks() {
    this.healthChecker = {
      primaryHealthy: true,
      lastHealthCheck: Date.now(),
      
      check: async () => {
        try {
          const testMessage = {
            level: 'INFO',
            message: 'Health check',
            metadata: { healthCheck: true }
          };
          
          await this.primaryLogger.sendMessage(testMessage);
          
          if (!this.healthChecker.primaryHealthy) {
            console.log('Primary logger recovered');
            
            // Flush buffer when primary recovers
            await this.bufferLogger.flush(this.primaryLogger);
          }
          
          this.healthChecker.primaryHealthy = true;
          this.healthChecker.lastHealthCheck = Date.now();
          
        } catch (error) {
          console.warn('Primary logger health check failed:', error.message);
          this.healthChecker.primaryHealthy = false;
        }
      }
    };
    
    // Check health every 30 seconds
    setInterval(() => {
      this.healthChecker.check();
    }, 30000);
  }
  
  setupFailover() {
    this.failoverManager = {
      failoverActive: false,
      
      activate: () => {
        if (!this.failoverManager.failoverActive) {
          this.failoverManager.failoverActive = true;
          console.warn('Activating logging failover mode');
        }
      },
      
      deactivate: () => {
        if (this.failoverManager.failoverActive) {
          this.failoverManager.failoverActive = false;
          console.log('Deactivating logging failover mode');
        }
      }
    };
  }
  
  setupMonitoring() {
    this.monitor = {
      metrics: {
        totalLogs: 0,
        primaryLogs: 0,
        fallbackLogs: 0,
        bufferedLogs: 0,
        errors: 0
      },
      
      record: (type) => {
        this.monitor.metrics.totalLogs++;
        this.monitor.metrics[type]++;
      },
      
      getStats: () => ({
        ...this.monitor.metrics,
        primaryHealthy: this.healthChecker.primaryHealthy,
        failoverActive: this.failoverManager.failoverActive,
        bufferSize: this.bufferLogger.getSize(),
        lastHealthCheck: this.healthChecker.lastHealthCheck
      })
    };
    
    // Emit metrics every minute
    setInterval(() => {
      const stats = this.monitor.getStats();
      console.log('Network logging stats:', stats);
    }, 60000);
  }
  
  async log(level, message, metadata = {}) {
    const enrichedMetadata = {
      ...metadata,
      service: process.env.SERVICE_NAME,
      environment: this.environment,
      instance: require('os').hostname(),
      timestamp: new Date().toISOString()
    };
    
    try {
      if (this.healthChecker.primaryHealthy) {
        await this.primaryLogger.log(level, message, enrichedMetadata);
        this.monitor.record('primaryLogs');
        
        if (this.failoverManager.failoverActive) {
          this.failoverManager.deactivate();
        }
      } else {
        throw new Error('Primary logger unhealthy');
      }
      
    } catch (error) {
      this.monitor.record('errors');
      this.failoverManager.activate();
      
      // Try fallback logger
      try {
        await this.fallbackLogger.log(level, message, enrichedMetadata);
        this.monitor.record('fallbackLogs');
      } catch (fallbackError) {
        // Buffer the log entry
        this.bufferLogger.add(level, message, enrichedMetadata);
        this.monitor.record('bufferedLogs');
        
        console.error('All logging failed, buffering:', fallbackError.message);
      }
    }
  }
  
  // Convenience methods
  info(message, metadata) { return this.log('info', message, metadata); }
  warn(message, metadata) { return this.log('warn', message, metadata); }
  error(message, metadata) { return this.log('error', message, metadata); }
  debug(message, metadata) { return this.log('debug', message, metadata); }
  
  getHealth() {
    return this.monitor.getStats();
  }
  
  async flush() {
    await this.primaryLogger.flush();
  }
  
  async destroy() {
    await this.primaryLogger.destroy();
  }
}

// Usage example
const logger = new ProductionNetworkLogger({
  primary: {
    type: 'elasticsearch',
    host: 'es-cluster.internal',
    port: 9200
  },
  fallback: {
    logDir: '/var/log/myapp'
  }
});

// Application logging
logger.info('Application started', { port: 3000 });
logger.error('Database connection failed', { 
  error: 'Connection timeout',
  retryAttempt: 3 
});

// Health monitoring
setInterval(() => {
  const health = logger.getHealth();
  if (!health.primaryHealthy) {
    console.warn('Logging infrastructure degraded:', health);
  }
}, 60000);
```

---

**Previous**: [2.3.2 File Systems](./2.3.2_File_Systems.md)  
**Next**: [2.3.4 Databases](./2.3.4_Databases.md)
