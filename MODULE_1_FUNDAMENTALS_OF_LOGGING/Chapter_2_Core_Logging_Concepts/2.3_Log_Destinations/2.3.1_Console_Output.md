# 2.3.1 Console Output

## Understanding Console Output in Logging

Console output is the most immediate and commonly used logging destination for development and debugging. It provides real-time feedback and is essential for interactive development workflows. This section covers advanced console logging techniques, formatting, and optimization strategies.

## Advanced Console Logging Implementation

### 1. **Enhanced Console Logger**
Comprehensive console logging with advanced formatting, colors, and interactive features.

```javascript
// Advanced console logging implementation
class AdvancedConsoleLogger {
  constructor(options = {}) {
    this.options = {
      colors: options.colors !== false,
      timestamps: options.timestamps !== false,
      logLevel: options.logLevel || 'info',
      format: options.format || 'pretty',
      interactive: options.interactive || false,
      maxWidth: options.maxWidth || process.stdout.columns || 120,
      ...options
    };
    
    this.colorScheme = this.setupColorScheme();
    this.formatters = this.setupFormatters();
    this.outputStreams = this.setupOutputStreams();
    this.interactiveFeatures = this.setupInteractiveFeatures();
    this.performanceMonitor = this.setupPerformanceMonitor();
  }
  
  setupColorScheme() {
    return {
      // ANSI color codes
      colors: {
        reset: '\x1b[0m',
        bright: '\x1b[1m',
        dim: '\x1b[2m',
        underscore: '\x1b[4m',
        blink: '\x1b[5m',
        reverse: '\x1b[7m',
        hidden: '\x1b[8m',
        
        // Foreground colors
        black: '\x1b[30m',
        red: '\x1b[31m',
        green: '\x1b[32m',
        yellow: '\x1b[33m',
        blue: '\x1b[34m',
        magenta: '\x1b[35m',
        cyan: '\x1b[36m',
        white: '\x1b[37m',
        gray: '\x1b[90m',
        
        // Bright foreground colors
        brightRed: '\x1b[91m',
        brightGreen: '\x1b[92m',
        brightYellow: '\x1b[93m',
        brightBlue: '\x1b[94m',
        brightMagenta: '\x1b[95m',
        brightCyan: '\x1b[96m',
        brightWhite: '\x1b[97m',
        
        // Background colors
        bgBlack: '\x1b[40m',
        bgRed: '\x1b[41m',
        bgGreen: '\x1b[42m',
        bgYellow: '\x1b[43m',
        bgBlue: '\x1b[44m',
        bgMagenta: '\x1b[45m',
        bgCyan: '\x1b[46m',
        bgWhite: '\x1b[47m'
      },
      
      // Level-specific color mapping
      levelColors: {
        trace: 'gray',
        debug: 'cyan',
        info: 'green',
        warn: 'yellow',
        error: 'red',
        fatal: 'brightRed'
      },
      
      // Component colors
      componentColors: {
        timestamp: 'gray',
        level: 'bright',
        logger: 'magenta',
        message: 'white',
        metadata: 'cyan',
        stack: 'red',
        performance: 'yellow'
      }
    };
  }
  
  setupFormatters() {
    return {
      // Pretty console format with colors and structure
      pretty: (logEntry) => {
        const { colors, levelColors, componentColors } = this.colorScheme;
        const level = logEntry.level.toLowerCase();
        const timestamp = logEntry.timestamp || new Date().toISOString();
        
        let output = '';
        
        // Timestamp
        if (this.options.timestamps) {
          output += this.colorize(
            `[${timestamp}]`,
            colors[componentColors.timestamp]
          ) + ' ';
        }
        
        // Log level
        const levelColor = colors[levelColors[level]] || colors.white;
        const levelText = level.toUpperCase().padEnd(5);
        output += this.colorize(levelText, levelColor + colors.bright) + ' ';
        
        // Logger name
        if (logEntry.logger) {
          output += this.colorize(
            `${logEntry.logger}:`,
            colors[componentColors.logger]
          ) + ' ';
        }
        
        // Message
        output += this.colorize(
          logEntry.message,
          colors[componentColors.message]
        );
        
        // Metadata
        if (logEntry.metadata && Object.keys(logEntry.metadata).length > 0) {
          output += '\n' + this.formatMetadata(logEntry.metadata, 2);
        }
        
        // Stack trace
        if (logEntry.stack) {
          output += '\n' + this.formatStackTrace(logEntry.stack, 2);
        }
        
        // Performance information
        if (logEntry.performance) {
          output += '\n' + this.formatPerformance(logEntry.performance, 2);
        }
        
        return output;
      },
      
      // Compact single-line format
      compact: (logEntry) => {
        const { colors, levelColors } = this.colorScheme;
        const level = logEntry.level.toLowerCase();
        const timestamp = logEntry.timestamp || new Date().toISOString();
        
        const levelColor = colors[levelColors[level]] || colors.white;
        const parts = [];
        
        if (this.options.timestamps) {
          parts.push(this.colorize(timestamp, colors.gray));
        }
        
        parts.push(this.colorize(level.toUpperCase(), levelColor));
        
        if (logEntry.logger) {
          parts.push(this.colorize(logEntry.logger, colors.magenta));
        }
        
        parts.push(logEntry.message);
        
        if (logEntry.metadata) {
          const metaStr = JSON.stringify(logEntry.metadata);
          if (metaStr.length < 100) {
            parts.push(this.colorize(metaStr, colors.cyan));
          } else {
            parts.push(this.colorize('[metadata]', colors.cyan));
          }
        }
        
        return parts.join(' ');
      },
      
      // JSON format for structured output
      json: (logEntry) => {
        return JSON.stringify(logEntry, null, this.options.jsonIndent || 0);
      },
      
      // Development-friendly format with extra debugging info
      development: (logEntry) => {
        const { colors } = this.colorScheme;
        let output = this.formatters.pretty(logEntry);
        
        // Add extra development information
        if (logEntry.file || logEntry.line) {
          output += '\n' + this.colorize(
            `  📁 ${logEntry.file}:${logEntry.line}`,
            colors.gray
          );
        }
        
        if (logEntry.function) {
          output += '\n' + this.colorize(
            `  🔧 ${logEntry.function}()`,
            colors.gray
          );
        }
        
        if (logEntry.context) {
          output += '\n' + this.colorize(
            `  🔍 Context: ${JSON.stringify(logEntry.context)}`,
            colors.gray
          );
        }
        
        return output;
      },
      
      // Table format for structured data
      table: (logEntry) => {
        if (!logEntry.metadata || typeof logEntry.metadata !== 'object') {
          return this.formatters.pretty(logEntry);
        }
        
        const { colors } = this.colorScheme;
        let output = this.formatters.compact(logEntry) + '\n';
        
        // Create table
        const entries = Object.entries(logEntry.metadata);
        const maxKeyLength = Math.max(...entries.map(([key]) => key.length));
        
        output += this.colorize('┌' + '─'.repeat(maxKeyLength + 2) + '┬' + '─'.repeat(50) + '┐\n', colors.gray);
        output += this.colorize('│ Key'.padEnd(maxKeyLength + 3) + '│ Value'.padEnd(51) + '│\n', colors.gray);
        output += this.colorize('├' + '─'.repeat(maxKeyLength + 2) + '┼' + '─'.repeat(50) + '┤\n', colors.gray);
        
        entries.forEach(([key, value]) => {
          const valueStr = String(value).substring(0, 48);
          output += this.colorize('│ ', colors.gray) + 
                   this.colorize(key.padEnd(maxKeyLength + 1), colors.cyan) +
                   this.colorize('│ ', colors.gray) +
                   this.colorize(valueStr.padEnd(49), colors.white) +
                   this.colorize('│\n', colors.gray);
        });
        
        output += this.colorize('└' + '─'.repeat(maxKeyLength + 2) + '┴' + '─'.repeat(50) + '┘', colors.gray);
        
        return output;
      }
    };
  }
  
  setupOutputStreams() {
    return {
      // Standard output configuration
      stdout: {
        stream: process.stdout,
        levels: ['trace', 'debug', 'info'],
        encoding: 'utf8',
        autoClose: false
      },
      
      // Standard error configuration
      stderr: {
        stream: process.stderr,
        levels: ['warn', 'error', 'fatal'],
        encoding: 'utf8',
        autoClose: false
      },
      
      // Custom output stream handling
      writeToStream: (stream, data, callback) => {
        try {
          const written = stream.write(data + '\n', 'utf8', callback);
          
          if (!written) {
            // Handle backpressure
            stream.once('drain', () => {
              if (callback) callback();
            });
          }
          
          return written;
        } catch (error) {
          if (callback) callback(error);
          return false;
        }
      },
      
      // Stream health monitoring
      monitorStream: (stream, streamName) => {
        stream.on('error', (error) => {
          console.error(`Stream ${streamName} error:`, error);
        });
        
        stream.on('close', () => {
          console.warn(`Stream ${streamName} closed unexpectedly`);
        });
        
        return {
          isWritable: () => stream.writable,
          getBufferSize: () => stream.writableHighWaterMark - stream.writableLength,
          isBackpressured: () => !stream.writable || stream.writableLength >= stream.writableHighWaterMark
        };
      }
    };
  }
  
  setupInteractiveFeatures() {
    return {
      // Progress indicators
      progressBar: (current, total, message = '') => {
        const width = 40;
        const percentage = (current / total) * 100;
        const filled = Math.round((width * current) / total);
        const empty = width - filled;
        
        const { colors } = this.colorScheme;
        const bar = this.colorize('█'.repeat(filled), colors.green) +
                   this.colorize('░'.repeat(empty), colors.gray);
        
        const output = `${message} [${bar}] ${percentage.toFixed(1)}% (${current}/${total})`;
        
        // Clear line and write progress
        process.stdout.write('\r' + output);
        
        if (current >= total) {
          process.stdout.write('\n');
        }
      },
      
      // Spinner for long operations
      spinner: {
        frames: ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'],
        current: 0,
        interval: null,
        
        start: (message = 'Loading...') => {
          const { colors } = this.colorScheme;
          this.interactiveFeatures.spinner.interval = setInterval(() => {
            const frame = this.interactiveFeatures.spinner.frames[
              this.interactiveFeatures.spinner.current
            ];
            this.interactiveFeatures.spinner.current = 
              (this.interactiveFeatures.spinner.current + 1) % 
              this.interactiveFeatures.spinner.frames.length;
            
            process.stdout.write(
              '\r' + this.colorize(frame, colors.cyan) + ' ' + message
            );
          }, 100);
        },
        
        stop: (finalMessage = '') => {
          if (this.interactiveFeatures.spinner.interval) {
            clearInterval(this.interactiveFeatures.spinner.interval);
            this.interactiveFeatures.spinner.interval = null;
            process.stdout.write('\r' + finalMessage + '\n');
          }
        }
      },
      
      // Interactive prompts
      prompt: {
        question: (question, callback) => {
          const { colors } = this.colorScheme;
          const readline = require('readline');
          
          const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
          });
          
          rl.question(
            this.colorize(question + ' ', colors.yellow),
            (answer) => {
              rl.close();
              callback(answer);
            }
          );
        },
        
        confirm: (question, callback) => {
          this.interactiveFeatures.prompt.question(
            question + ' (y/n)',
            (answer) => {
              callback(['y', 'yes', 'true', '1'].includes(answer.toLowerCase()));
            }
          );
        }
      },
      
      // Real-time log filtering
      liveFilter: {
        active: false,
        filters: new Set(),
        
        enable: () => {
          this.interactiveFeatures.liveFilter.active = true;
          this.setupKeyboardHandler();
        },
        
        disable: () => {
          this.interactiveFeatures.liveFilter.active = false;
        },
        
        addFilter: (filter) => {
          this.interactiveFeatures.liveFilter.filters.add(filter);
        },
        
        removeFilter: (filter) => {
          this.interactiveFeatures.liveFilter.filters.delete(filter);
        },
        
        shouldShow: (logEntry) => {
          if (this.interactiveFeatures.liveFilter.filters.size === 0) {
            return true;
          }
          
          return Array.from(this.interactiveFeatures.liveFilter.filters).some(filter => {
            return logEntry.message.includes(filter) ||
                   logEntry.level.includes(filter) ||
                   (logEntry.logger && logEntry.logger.includes(filter));
          });
        }
      }
    };
  }
  
  setupPerformanceMonitor() {
    return {
      startTime: Date.now(),
      logCount: 0,
      levelCounts: {},
      averageLogTime: 0,
      
      recordLog: (level, startTime) => {
        const endTime = Date.now();
        const logTime = endTime - startTime;
        
        this.performanceMonitor.logCount++;
        this.performanceMonitor.levelCounts[level] = 
          (this.performanceMonitor.levelCounts[level] || 0) + 1;
        
        // Update average log time
        this.performanceMonitor.averageLogTime = 
          (this.performanceMonitor.averageLogTime * (this.performanceMonitor.logCount - 1) + logTime) / 
          this.performanceMonitor.logCount;
      },
      
      getStatistics: () => {
        const uptime = Date.now() - this.performanceMonitor.startTime;
        return {
          uptime,
          totalLogs: this.performanceMonitor.logCount,
          logsPerSecond: this.performanceMonitor.logCount / (uptime / 1000),
          averageLogTime: this.performanceMonitor.averageLogTime,
          levelDistribution: this.performanceMonitor.levelCounts
        };
      },
      
      reset: () => {
        this.performanceMonitor.startTime = Date.now();
        this.performanceMonitor.logCount = 0;
        this.performanceMonitor.levelCounts = {};
        this.performanceMonitor.averageLogTime = 0;
      }
    };
  }
  
  log(level, message, metadata = {}, options = {}) {
    const startTime = Date.now();
    
    // Check if level should be logged
    if (!this.shouldLog(level)) {
      return;
    }
    
    // Create log entry
    const logEntry = {
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      logger: options.logger || 'console',
      message,
      metadata: this.sanitizeMetadata(metadata),
      ...options
    };
    
    // Apply live filtering if active
    if (this.interactiveFeatures.liveFilter.active) {
      if (!this.interactiveFeatures.liveFilter.shouldShow(logEntry)) {
        return;
      }
    }
    
    // Format the log entry
    const formatter = this.formatters[this.options.format] || this.formatters.pretty;
    const formattedMessage = formatter(logEntry);
    
    // Determine output stream
    const streamConfig = this.getOutputStream(level);
    
    // Write to stream
    this.outputStreams.writeToStream(
      streamConfig.stream,
      formattedMessage,
      (error) => {
        if (error) {
          console.error('Console logging error:', error);
        }
      }
    );
    
    // Record performance metrics
    this.performanceMonitor.recordLog(level, startTime);
  }
  
  // Convenience methods for different log levels
  trace(message, metadata, options) { return this.log('trace', message, metadata, options); }
  debug(message, metadata, options) { return this.log('debug', message, metadata, options); }
  info(message, metadata, options) { return this.log('info', message, metadata, options); }
  warn(message, metadata, options) { return this.log('warn', message, metadata, options); }
  error(message, metadata, options) { return this.log('error', message, metadata, options); }
  fatal(message, metadata, options) { return this.log('fatal', message, metadata, options); }
  
  shouldLog(level) {
    const levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];
    const currentLevelIndex = levels.indexOf(this.options.logLevel);
    const messageLevelIndex = levels.indexOf(level);
    
    return messageLevelIndex >= currentLevelIndex;
  }
  
  getOutputStream(level) {
    const { stdout, stderr } = this.outputStreams;
    
    if (stdout.levels.includes(level)) {
      return stdout;
    } else if (stderr.levels.includes(level)) {
      return stderr;
    }
    
    // Default to stdout
    return stdout;
  }
  
  colorize(text, color) {
    if (!this.options.colors) {
      return text;
    }
    
    return color + text + this.colorScheme.colors.reset;
  }
  
  formatMetadata(metadata, indent = 0) {
    const { colors } = this.colorScheme;
    const spaces = ' '.repeat(indent);
    
    if (typeof metadata !== 'object' || metadata === null) {
      return spaces + this.colorize(String(metadata), colors.cyan);
    }
    
    let output = '';
    Object.entries(metadata).forEach(([key, value], index, array) => {
      const isLast = index === array.length - 1;
      const prefix = isLast ? '└─' : '├─';
      
      output += spaces + this.colorize(prefix + ' ', colors.gray) +
               this.colorize(key + ': ', colors.yellow);
      
      if (typeof value === 'object' && value !== null) {
        output += '\n' + this.formatMetadata(value, indent + 2);
      } else {
        output += this.colorize(String(value), colors.cyan);
      }
      
      if (!isLast) output += '\n';
    });
    
    return output;
  }
  
  formatStackTrace(stack, indent = 0) {
    const { colors } = this.colorScheme;
    const spaces = ' '.repeat(indent);
    
    if (typeof stack === 'string') {
      return stack.split('\n').map(line => 
        spaces + this.colorize(line, colors.red)
      ).join('\n');
    }
    
    if (Array.isArray(stack)) {
      return stack.map((frame, index) => {
        return spaces + this.colorize(
          `${index + 1}. ${frame.function || '<anonymous>'} (${frame.file}:${frame.line})`,
          colors.red
        );
      }).join('\n');
    }
    
    return spaces + this.colorize(String(stack), colors.red);
  }
  
  formatPerformance(performance, indent = 0) {
    const { colors } = this.colorScheme;
    const spaces = ' '.repeat(indent);
    
    let output = spaces + this.colorize('⚡ Performance:', colors.yellow) + '\n';
    
    Object.entries(performance).forEach(([key, value]) => {
      output += spaces + '  ' + this.colorize(key + ': ', colors.yellow) +
               this.colorize(this.formatValue(value), colors.white) + '\n';
    });
    
    return output.slice(0, -1); // Remove trailing newline
  }
  
  formatValue(value) {
    if (typeof value === 'number') {
      if (value < 1000) return value.toString();
      if (value < 1000000) return (value / 1000).toFixed(1) + 'K';
      return (value / 1000000).toFixed(1) + 'M';
    }
    
    return String(value);
  }
  
  sanitizeMetadata(metadata) {
    if (typeof metadata !== 'object' || metadata === null) {
      return metadata;
    }
    
    const sanitized = {};
    const sensitiveKeys = ['password', 'token', 'apiKey', 'secret', 'credentials'];
    
    Object.entries(metadata).forEach(([key, value]) => {
      const lowerKey = key.toLowerCase();
      
      if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {
        sanitized[key] = '[REDACTED]';
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeMetadata(value);
      } else {
        sanitized[key] = value;
      }
    });
    
    return sanitized;
  }
  
  setupKeyboardHandler() {
    if (!this.options.interactive) return;
    
    const readline = require('readline');
    readline.emitKeypressEvents(process.stdin);
    
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }
    
    process.stdin.on('keypress', (str, key) => {
      if (key.ctrl && key.name === 'c') {
        process.exit();
      }
      
      // Handle filter commands
      if (key.name === 'f' && key.ctrl) {
        this.interactiveFeatures.prompt.question(
          'Enter filter term:',
          (filter) => {
            this.interactiveFeatures.liveFilter.addFilter(filter);
            console.log(`Filter added: ${filter}`);
          }
        );
      }
      
      if (key.name === 'r' && key.ctrl) {
        this.interactiveFeatures.liveFilter.filters.clear();
        console.log('All filters removed');
      }
    });
  }
  
  // Utility methods
  clearScreen() {
    process.stdout.write('\x1b[2J\x1b[0f');
  }
  
  moveCursor(x, y) {
    process.stdout.write(`\x1b[${y};${x}H`);
  }
  
  saveCursor() {
    process.stdout.write('\x1b[s');
  }
  
  restoreCursor() {
    process.stdout.write('\x1b[u');
  }
  
  hideCursor() {
    process.stdout.write('\x1b[?25l');
  }
  
  showCursor() {
    process.stdout.write('\x1b[?25h');
  }
  
  getTerminalSize() {
    return {
      width: process.stdout.columns || 80,
      height: process.stdout.rows || 24
    };
  }
  
  // Statistics and monitoring
  getStatistics() {
    return {
      performance: this.performanceMonitor.getStatistics(),
      configuration: {
        format: this.options.format,
        colors: this.options.colors,
        logLevel: this.options.logLevel,
        interactive: this.options.interactive
      },
      terminal: this.getTerminalSize(),
      streams: {
        stdout: {
          writable: process.stdout.writable,
          columns: process.stdout.columns,
          rows: process.stdout.rows
        },
        stderr: {
          writable: process.stderr.writable
        }
      }
    };
  }
  
  // Configuration management
  updateConfiguration(newOptions) {
    this.options = { ...this.options, ...newOptions };
    
    // Reinitialize if needed
    if (newOptions.colors !== undefined) {
      this.colorScheme = this.setupColorScheme();
    }
    
    if (newOptions.format !== undefined) {
      // Format change doesn't require reinitialization
    }
    
    if (newOptions.interactive !== undefined && newOptions.interactive) {
      this.setupKeyboardHandler();
    }
  }
  
  // Cleanup
  destroy() {
    if (this.interactiveFeatures.spinner.interval) {
      this.interactiveFeatures.spinner.stop();
    }
    
    this.interactiveFeatures.liveFilter.disable();
    
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(false);
    }
    
    this.showCursor();
  }
}
```

### 2. **Console Output Optimization**
Advanced techniques for optimizing console output performance and reducing overhead.

```javascript
// Console output optimization system
class OptimizedConsoleOutput {
  constructor(options = {}) {
    this.options = {
      bufferSize: options.bufferSize || 1000,
      flushInterval: options.flushInterval || 100,
      asyncMode: options.asyncMode !== false,
      colorCaching: options.colorCaching !== false,
      compressionThreshold: options.compressionThreshold || 1024,
      ...options
    };
    
    this.buffer = [];
    this.colorCache = new Map();
    this.metrics = this.initializeMetrics();
    this.flushTimer = null;
    this.writeQueue = [];
    this.isWriting = false;
    
    this.setupBuffering();
    this.setupColorCaching();
    this.setupAsyncProcessing();
  }
  
  initializeMetrics() {
    return {
      totalLogs: 0,
      bufferedLogs: 0,
      flushedBatches: 0,
      averageFlushTime: 0,
      cacheHits: 0,
      cacheMisses: 0,
      compressionSaved: 0,
      queueDepth: 0,
      startTime: Date.now()
    };
  }
  
  setupBuffering() {
    this.bufferManager = {
      // Add log to buffer
      add: (logEntry) => {
        this.buffer.push({
          ...logEntry,
          timestamp: Date.now(),
          size: JSON.stringify(logEntry).length
        });
        
        this.metrics.bufferedLogs++;
        
        // Auto-flush if buffer is full
        if (this.buffer.length >= this.options.bufferSize) {
          this.flush();
        }
      },
      
      // Flush buffer to console
      flush: () => {
        if (this.buffer.length === 0) return;
        
        const startTime = Date.now();
        const batch = [...this.buffer];
        this.buffer = [];
        
        // Process batch
        const processedBatch = this.processBatch(batch);
        
        if (this.options.asyncMode) {
          this.writeQueue.push(processedBatch);
          this.processWriteQueue();
        } else {
          this.writeBatchSync(processedBatch);
        }
        
        // Update metrics
        const flushTime = Date.now() - startTime;
        this.metrics.flushedBatches++;
        this.metrics.averageFlushTime = 
          (this.metrics.averageFlushTime * (this.metrics.flushedBatches - 1) + flushTime) / 
          this.metrics.flushedBatches;
      },
      
      // Clear buffer without flushing
      clear: () => {
        const cleared = this.buffer.length;
        this.buffer = [];
        return cleared;
      },
      
      // Get buffer statistics
      getStats: () => ({
        currentSize: this.buffer.length,
        maxSize: this.options.bufferSize,
        utilization: (this.buffer.length / this.options.bufferSize) * 100,
        totalBytes: this.buffer.reduce((sum, entry) => sum + entry.size, 0)
      })
    };
    
    // Setup automatic flushing
    if (this.options.flushInterval > 0) {
      this.flushTimer = setInterval(() => {
        this.bufferManager.flush();
      }, this.options.flushInterval);
    }
  }
  
  setupColorCaching() {
    this.colorManager = {
      // Get cached colored text
      getColored: (text, colorCode) => {
        if (!this.options.colorCaching) {
          return colorCode + text + '\x1b[0m';
        }
        
        const cacheKey = `${colorCode}:${text}`;
        
        if (this.colorCache.has(cacheKey)) {
          this.metrics.cacheHits++;
          return this.colorCache.get(cacheKey);
        }
        
        const coloredText = colorCode + text + '\x1b[0m';
        
        // Limit cache size
        if (this.colorCache.size >= 1000) {
          const firstKey = this.colorCache.keys().next().value;
          this.colorCache.delete(firstKey);
        }
        
        this.colorCache.set(cacheKey, coloredText);
        this.metrics.cacheMisses++;
        
        return coloredText;
      },
      
      // Clear color cache
      clearCache: () => {
        this.colorCache.clear();
      },
      
      // Get cache statistics
      getCacheStats: () => ({
        size: this.colorCache.size,
        hitRate: this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) * 100,
        totalRequests: this.metrics.cacheHits + this.metrics.cacheMisses
      })
    };
  }
  
  setupAsyncProcessing() {
    this.asyncProcessor = {
      // Process write queue asynchronously
      processQueue: async () => {
        if (this.isWriting || this.writeQueue.length === 0) {
          return;
        }
        
        this.isWriting = true;
        this.metrics.queueDepth = this.writeQueue.length;
        
        try {
          while (this.writeQueue.length > 0) {
            const batch = this.writeQueue.shift();
            await this.writeBatchAsync(batch);
          }
        } catch (error) {
          console.error('Async write error:', error);
        } finally {
          this.isWriting = false;
          this.metrics.queueDepth = 0;
        }
      },
      
      // Write batch with backpressure handling
      writeBatch: (batch) => {
        return new Promise((resolve, reject) => {
          const output = batch.join('\n') + '\n';
          
          const written = process.stdout.write(output, 'utf8', (error) => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
          
          if (!written) {
            // Handle backpressure
            process.stdout.once('drain', resolve);
          }
        });
      }
    };
  }
  
  processBatch(batch) {
    return batch.map(entry => {
      // Apply compression if needed
      let output = this.formatLogEntry(entry);
      
      if (output.length > this.options.compressionThreshold) {
        const compressed = this.compressOutput(output);
        if (compressed.length < output.length * 0.8) {
          this.metrics.compressionSaved += output.length - compressed.length;
          output = compressed;
        }
      }
      
      return output;
    });
  }
  
  formatLogEntry(entry) {
    const timestamp = new Date(entry.timestamp).toISOString();
    const level = entry.level.toUpperCase().padEnd(5);
    
    // Use color caching
    const levelColored = this.colorManager.getColored(level, this.getLevelColor(entry.level));
    const messageColored = this.colorManager.getColored(entry.message, '\x1b[37m');
    
    let output = `[${timestamp}] ${levelColored} ${messageColored}`;
    
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      const metadataStr = JSON.stringify(entry.metadata);
      output += ' ' + this.colorManager.getColored(metadataStr, '\x1b[36m');
    }
    
    return output;
  }
  
  getLevelColor(level) {
    const colors = {
      trace: '\x1b[90m',
      debug: '\x1b[36m',
      info: '\x1b[32m',
      warn: '\x1b[33m',
      error: '\x1b[31m',
      fatal: '\x1b[91m'
    };
    
    return colors[level.toLowerCase()] || '\x1b[37m';
  }
  
  compressOutput(output) {
    // Simple compression: remove repeated whitespace and common patterns
    return output
      .replace(/\s+/g, ' ')
      .replace(/,\s*}/g, '}')
      .replace(/{\s*,/g, '{')
      .replace(/\[\s*,/g, '[')
      .replace(/,\s*\]/g, ']');
  }
  
  async writeBatchAsync(batch) {
    return this.asyncProcessor.writeBatch(batch);
  }
  
  writeBatchSync(batch) {
    const output = batch.join('\n') + '\n';
    process.stdout.write(output);
  }
  
  processWriteQueue() {
    // Use setImmediate to avoid blocking
    setImmediate(() => {
      this.asyncProcessor.processQueue();
    });
  }
  
  // Main logging method
  log(level, message, metadata = {}) {
    const logEntry = {
      level,
      message,
      metadata,
      timestamp: Date.now()
    };
    
    this.metrics.totalLogs++;
    this.bufferManager.add(logEntry);
  }
  
  // Force flush buffer
  flush() {
    this.bufferManager.flush();
  }
  
  // Get comprehensive statistics
  getStatistics() {
    const uptime = Date.now() - this.metrics.startTime;
    
    return {
      performance: {
        ...this.metrics,
        uptime,
        logsPerSecond: this.metrics.totalLogs / (uptime / 1000),
        bufferUtilization: (this.buffer.length / this.options.bufferSize) * 100
      },
      buffer: this.bufferManager.getStats(),
      colorCache: this.colorManager.getCacheStats(),
      configuration: this.options
    };
  }
  
  // Optimize configuration based on performance
  autoOptimize() {
    const stats = this.getStatistics();
    const recommendations = [];
    
    // Buffer size optimization
    if (stats.buffer.utilization > 90) {
      recommendations.push({
        type: 'buffer_size',
        current: this.options.bufferSize,
        recommended: this.options.bufferSize * 1.5,
        reason: 'High buffer utilization detected'
      });
    }
    
    // Flush interval optimization
    if (stats.performance.averageFlushTime > 50) {
      recommendations.push({
        type: 'flush_interval',
        current: this.options.flushInterval,
        recommended: this.options.flushInterval * 1.2,
        reason: 'High flush time detected'
      });
    }
    
    // Color caching optimization
    if (stats.colorCache.hitRate < 50) {
      recommendations.push({
        type: 'color_caching',
        current: this.options.colorCaching,
        recommended: false,
        reason: 'Low cache hit rate'
      });
    }
    
    return recommendations;
  }
  
  // Apply optimization recommendations
  applyOptimizations(recommendations) {
    recommendations.forEach(rec => {
      switch (rec.type) {
        case 'buffer_size':
          this.options.bufferSize = rec.recommended;
          break;
        case 'flush_interval':
          clearInterval(this.flushTimer);
          this.options.flushInterval = rec.recommended;
          this.flushTimer = setInterval(() => {
            this.bufferManager.flush();
          }, this.options.flushInterval);
          break;
        case 'color_caching':
          this.options.colorCaching = rec.recommended;
          if (!rec.recommended) {
            this.colorManager.clearCache();
          }
          break;
      }
    });
  }
  
  // Cleanup resources
  destroy() {
    // Flush remaining logs
    this.flush();
    
    // Clear timers
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    
    // Clear caches
    this.colorManager.clearCache();
    
    // Clear buffers
    this.bufferManager.clear();
    this.writeQueue = [];
  }
}
```

## Console Output Best Practices

### **Production Console Logging Strategy**
```javascript
// Production-ready console logging configuration
class ProductionConsoleLogger {
  constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development';
    this.isProduction = process.env.NODE_ENV === 'production';
    this.isTesting = process.env.NODE_ENV === 'test';
    
    this.consoleLogger = new AdvancedConsoleLogger({
      // Disable colors in production unless explicitly enabled
      colors: this.isDevelopment || process.env.FORCE_COLOR === 'true',
      
      // Use compact format in production
      format: this.isProduction ? 'json' : 'pretty',
      
      // Different log levels for different environments
      logLevel: this.getEnvironmentLogLevel(),
      
      // Disable interactive features in production
      interactive: this.isDevelopment,
      
      // Optimize for production
      bufferSize: this.isProduction ? 2000 : 500,
      flushInterval: this.isProduction ? 500 : 100
    });
    
    this.optimizer = new OptimizedConsoleOutput({
      asyncMode: this.isProduction,
      colorCaching: this.isDevelopment,
      compressionThreshold: this.isProduction ? 512 : 2048
    });
  }
  
  getEnvironmentLogLevel() {
    if (this.isTesting) return 'error';
    if (this.isProduction) return process.env.LOG_LEVEL || 'info';
    return 'debug';
  }
  
  log(level, message, metadata = {}) {
    // Add environment context
    const enrichedMetadata = {
      ...metadata,
      environment: process.env.NODE_ENV,
      service: process.env.SERVICE_NAME,
      version: process.env.APP_VERSION,
      instance: process.env.INSTANCE_ID || require('os').hostname(),
      pid: process.pid
    };
    
    // Use optimized logger in production
    if (this.isProduction) {
      this.optimizer.log(level, message, enrichedMetadata);
    } else {
      this.consoleLogger.log(level, message, enrichedMetadata);
    }
  }
  
  // Environment-specific convenience methods
  dev(message, metadata) {
    if (this.isDevelopment) {
      this.log('debug', `[DEV] ${message}`, metadata);
    }
  }
  
  test(message, metadata) {
    if (this.isTesting) {
      this.log('info', `[TEST] ${message}`, metadata);
    }
  }
  
  // Production monitoring
  getHealthMetrics() {
    const stats = this.isProduction ? 
      this.optimizer.getStatistics() : 
      this.consoleLogger.getStatistics();
    
    return {
      environment: process.env.NODE_ENV,
      healthy: stats.performance.logsPerSecond < 1000, // Threshold
      metrics: stats,
      recommendations: this.isProduction ? 
        this.optimizer.autoOptimize() : []
    };
  }
}

// Usage example
const logger = new ProductionConsoleLogger();

// Development logging
logger.dev('Starting application', { port: 3000 });

// Production logging
logger.info('Server started', { 
  port: process.env.PORT,
  environment: process.env.NODE_ENV 
});

// Error logging with context
logger.error('Database connection failed', {
  error: 'Connection timeout',
  database: 'users',
  retryAttempt: 3
});

// Health monitoring
setInterval(() => {
  const health = logger.getHealthMetrics();
  if (!health.healthy) {
    console.warn('Console logging performance degraded:', health.metrics);
  }
}, 60000);
```

---

**Previous**: [2.2.7 Stack Traces](../2.2_Log_Format_and_Structure/2.2.7_Stack_Traces.md)  
**Next**: [2.3.2 File Systems](./2.3.2_File_Systems.md)
