# 2.2.6 Context Information

## Understanding Context Information in Logging

Context information provides essential background data that helps understand the circumstances surrounding a log event. This includes request context, user context, system state, business context, and environmental information that makes logs more meaningful and actionable.

## Request and Session Context

### 1. **Request Context Management**
Comprehensive tracking of request-level context throughout the application lifecycle.

```javascript
// Advanced request context management
class RequestContextManager {
  constructor(logger) {
    this.logger = logger.child({ component: 'RequestContextManager' });
    this.activeContexts = new Map();
    this.contextHistory = new Map();
    this.contextEnrichment = this.setupContextEnrichment();
    this.contextPersistence = this.setupContextPersistence();
  }
  
  setupContextEnrichment() {
    return {
      // Enrich HTTP request context
      enrichHttpRequest: (req, res) => {
        return {
          // Request identification
          request: {
            id: req.id || this.generateRequestId(),
            method: req.method,
            url: req.url,
            path: req.path,
            query: req.query,
            params: req.params,
            protocol: req.protocol,
            secure: req.secure,
            xhr: req.xhr
          },
          
          // Request headers (sanitized)
          headers: {
            userAgent: req.get('User-Agent'),
            accept: req.get('Accept'),
            acceptLanguage: req.get('Accept-Language'),
            acceptEncoding: req.get('Accept-Encoding'),
            contentType: req.get('Content-Type'),
            contentLength: req.get('Content-Length'),
            referer: req.get('Referer'),
            origin: req.get('Origin'),
            authorization: req.get('Authorization') ? '[PRESENT]' : '[ABSENT]',
            xForwardedFor: req.get('X-Forwarded-For'),
            xRealIp: req.get('X-Real-IP'),
            host: req.get('Host')
          },
          
          // Network information
          network: {
            ip: req.ip || req.connection.remoteAddress,
            ips: req.ips,
            hostname: req.hostname,
            subdomains: req.subdomains,
            port: req.connection.localPort,
            remotePort: req.connection.remotePort,
            family: req.connection.remoteFamily
          },
          
          // Request timing
          timing: {
            startTime: Date.now(),
            startDate: new Date().toISOString(),
            hrTime: process.hrtime.bigint()
          },
          
          // Request body information (metadata only)
          body: {
            hasBody: !!req.body,
            bodySize: req.get('Content-Length') || 0,
            bodyType: req.get('Content-Type'),
            isEmpty: this.isEmptyBody(req.body),
            fieldCount: this.getBodyFieldCount(req.body)
          },
          
          // File upload information
          files: req.files ? {
            count: Array.isArray(req.files) ? req.files.length : Object.keys(req.files).length,
            totalSize: this.calculateFilesSize(req.files),
            types: this.getFileTypes(req.files)
          } : null,
          
          // Cookies (sanitized)
          cookies: this.sanitizeCookies(req.cookies),
          
          // Route information
          route: {
            path: req.route ? req.route.path : null,
            methods: req.route ? req.route.methods : null,
            regexp: req.route ? req.route.regexp.toString() : null,
            keys: req.route ? req.route.keys : null
          }
        };
      },
      
      // Enrich response context
      enrichHttpResponse: (req, res) => {
        const endTime = Date.now();
        const context = this.getRequestContext(req.id);
        const duration = context ? endTime - context.timing.startTime : 0;
        
        return {
          // Response identification
          response: {
            statusCode: res.statusCode,
            statusMessage: res.statusMessage,
            headers: this.sanitizeResponseHeaders(res.getHeaders()),
            headersSent: res.headersSent,
            finished: res.finished
          },
          
          // Response timing
          timing: {
            endTime,
            endDate: new Date().toISOString(),
            duration,
            hrDuration: context ? 
              Number(process.hrtime.bigint() - context.timing.hrTime) / 1000000 : 0 // milliseconds
          },
          
          // Response body information
          body: {
            size: res.get('Content-Length') || 0,
            type: res.get('Content-Type'),
            encoding: res.get('Content-Encoding'),
            disposition: res.get('Content-Disposition')
          },
          
          // Performance metrics
          performance: {
            duration,
            slow: duration > 1000,
            veryslow: duration > 5000,
            category: this.categorizeResponseTime(duration)
          },
          
          // Response classification
          classification: {
            success: res.statusCode >= 200 && res.statusCode < 300,
            redirect: res.statusCode >= 300 && res.statusCode < 400,
            clientError: res.statusCode >= 400 && res.statusCode < 500,
            serverError: res.statusCode >= 500,
            cached: !!res.get('Cache-Control'),
            compressed: !!res.get('Content-Encoding')
          }
        };
      },
      
      // Enrich user context
      enrichUserContext: (user, session) => {
        return {
          user: user ? {
            id: user.id,
            username: user.username,
            email: user.email ? this.maskEmail(user.email) : null,
            role: user.role,
            permissions: user.permissions || [],
            groups: user.groups || [],
            preferences: user.preferences ? {
              language: user.preferences.language,
              timezone: user.preferences.timezone,
              theme: user.preferences.theme
            } : null,
            profile: {
              createdAt: user.createdAt,
              lastLoginAt: user.lastLoginAt,
              loginCount: user.loginCount,
              verified: user.verified,
              active: user.active
            }
          } : null,
          
          session: session ? {
            id: session.id,
            createdAt: session.createdAt,
            lastAccessedAt: session.lastAccessedAt,
            expiresAt: session.expiresAt,
            isNew: session.isNew,
            maxAge: session.maxAge,
            secure: session.secure,
            httpOnly: session.httpOnly,
            sameSite: session.sameSite,
            store: session.store ? session.store.constructor.name : null
          } : null,
          
          authentication: {
            authenticated: !!user,
            method: session ? session.authMethod : null,
            provider: session ? session.authProvider : null,
            tokenType: session ? session.tokenType : null,
            scopes: session ? session.scopes : null,
            twoFactorEnabled: user ? user.twoFactorEnabled : false,
            passwordLastChanged: user ? user.passwordLastChanged : null
          }
        };
      },
      
      // Enrich system context
      enrichSystemContext: () => {
        return {
          system: {
            // Process information
            process: {
              pid: process.pid,
              ppid: process.ppid,
              title: process.title,
              version: process.version,
              platform: process.platform,
              arch: process.arch,
              uptime: process.uptime(),
              cwd: process.cwd(),
              execPath: process.execPath,
              memoryUsage: process.memoryUsage(),
              cpuUsage: process.cpuUsage()
            },
            
            // Node.js environment
            node: {
              version: process.version,
              versions: process.versions,
              features: process.features,
              env: process.env.NODE_ENV || 'development',
              debugPort: process.debugPort
            },
            
            // Operating system
            os: {
              hostname: require('os').hostname(),
              type: require('os').type(),
              platform: require('os').platform(),
              arch: require('os').arch(),
              release: require('os').release(),
              uptime: require('os').uptime(),
              loadavg: require('os').loadavg(),
              totalmem: require('os').totalmem(),
              freemem: require('os').freemem(),
              cpus: require('os').cpus().length,
              networkInterfaces: Object.keys(require('os').networkInterfaces())
            },
            
            // Application information
            application: {
              name: process.env.APP_NAME || 'unknown',
              version: process.env.APP_VERSION || '0.0.0',
              environment: process.env.NODE_ENV || 'development',
              instance: process.env.INSTANCE_ID || require('os').hostname(),
              cluster: process.env.CLUSTER_NAME,
              region: process.env.AWS_REGION || process.env.REGION,
              deployment: {
                id: process.env.DEPLOYMENT_ID,
                timestamp: process.env.DEPLOYMENT_TIMESTAMP,
                commitSha: process.env.GIT_COMMIT_SHA,
                branch: process.env.GIT_BRANCH
              }
            }
          }
        };
      }
    };
  }
  
  setupContextPersistence() {
    return {
      // Store context for the duration of request
      store: (contextId, context) => {
        this.activeContexts.set(contextId, {
          ...context,
          storedAt: Date.now(),
          accessCount: 0
        });
        
        // Also store in history for analysis
        this.contextHistory.set(contextId, {
          id: contextId,
          createdAt: context.timing.startDate,
          type: 'request',
          summary: this.createContextSummary(context)
        });
        
        // Cleanup old contexts
        this.cleanupOldContexts();
      },
      
      // Retrieve context
      retrieve: (contextId) => {
        const context = this.activeContexts.get(contextId);
        if (context) {
          context.accessCount++;
          context.lastAccessedAt = Date.now();
        }
        return context;
      },
      
      // Update context with additional information
      update: (contextId, updates) => {
        const context = this.activeContexts.get(contextId);
        if (context) {
          Object.assign(context, updates);
          context.updatedAt = Date.now();
        }
      },
      
      // Remove context when request is complete
      remove: (contextId) => {
        const context = this.activeContexts.get(contextId);
        if (context) {
          // Store final metrics in history
          const historyEntry = this.contextHistory.get(contextId);
          if (historyEntry) {
            historyEntry.completedAt = new Date().toISOString();
            historyEntry.duration = Date.now() - context.storedAt;
            historyEntry.accessCount = context.accessCount;
          }
          
          this.activeContexts.delete(contextId);
        }
      }
    };
  }
  
  createRequestContext(req, res) {
    const requestId = req.id || this.generateRequestId();
    
    // Enrich context with all available information
    const context = {
      id: requestId,
      type: 'http_request',
      
      // Core request/response context
      ...this.contextEnrichment.enrichHttpRequest(req, res),
      
      // User and session context
      ...this.contextEnrichment.enrichUserContext(req.user, req.session),
      
      // System context
      ...this.contextEnrichment.enrichSystemContext(),
      
      // Additional metadata
      metadata: {
        correlationId: this.generateCorrelationId(),
        traceId: req.traceId || this.generateTraceId(),
        spanId: this.generateSpanId(),
        parentSpanId: req.parentSpanId,
        
        // Request classification
        classification: {
          api: req.path.startsWith('/api/'),
          static: this.isStaticAsset(req.path),
          health: this.isHealthCheck(req.path),
          admin: this.isAdminRequest(req.path),
          public: this.isPublicEndpoint(req.path)
        },
        
        // Context flags
        flags: {
          internal: req.get('X-Internal-Request') === 'true',
          debug: req.query.debug === 'true',
          test: process.env.NODE_ENV === 'test',
          development: process.env.NODE_ENV === 'development'
        }
      }
    };
    
    // Store context
    this.contextPersistence.store(requestId, context);
    
    // Attach context to request for easy access
    req.context = context;
    
    this.logger.debug('Request context created', {
      requestId,
      method: context.request.method,
      url: context.request.url,
      userAgent: context.headers.userAgent,
      ip: context.network.ip
    });
    
    return context;
  }
  
  updateRequestContext(requestId, updates) {
    this.contextPersistence.update(requestId, updates);
    
    this.logger.trace('Request context updated', {
      requestId,
      updateKeys: Object.keys(updates)
    });
  }
  
  completeRequestContext(req, res) {
    const context = this.getRequestContext(req.id);
    if (!context) return null;
    
    // Enrich with response information
    const responseContext = this.contextEnrichment.enrichHttpResponse(req, res);
    this.updateRequestContext(req.id, responseContext);
    
    // Log request completion
    this.logger.info('Request completed', {
      requestId: req.id,
      method: context.request.method,
      url: context.request.url,
      statusCode: responseContext.response.statusCode,
      duration: responseContext.timing.duration,
      userAgent: context.headers.userAgent,
      ip: context.network.ip,
      userId: context.user?.id
    });
    
    // Clean up context
    this.contextPersistence.remove(req.id);
    
    return {
      ...context,
      ...responseContext
    };
  }
  
  getRequestContext(requestId) {
    return this.contextPersistence.retrieve(requestId);
  }
  
  logWithRequestContext(level, message, data = {}, requestId = null) {
    const context = requestId ? 
      this.getRequestContext(requestId) : 
      this.getCurrentRequestContext();
    
    const contextualLogEntry = {
      message,
      ...data,
      
      // Include relevant context information
      context: context ? {
        requestId: context.id,
        correlationId: context.metadata.correlationId,
        traceId: context.metadata.traceId,
        spanId: context.metadata.spanId,
        
        request: {
          method: context.request.method,
          url: context.request.url,
          userAgent: context.headers.userAgent,
          ip: context.network.ip
        },
        
        user: context.user ? {
          id: context.user.id,
          role: context.user.role
        } : null,
        
        timing: {
          requestAge: Date.now() - context.timing.startTime
        }
      } : null,
      
      timestamp: new Date().toISOString(),
      level: level.toUpperCase()
    };
    
    this.logger[level](message, contextualLogEntry);
    return contextualLogEntry;
  }
  
  getCurrentRequestContext() {
    // In a real implementation, this would use async local storage
    // or another mechanism to get the current request context
    return null;
  }
  
  generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  generateCorrelationId() {
    return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;
  }
  
  generateTraceId() {
    return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;
  }
  
  generateSpanId() {
    return `span_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;
  }
  
  isEmptyBody(body) {
    if (!body) return true;
    if (typeof body === 'string') return body.length === 0;
    if (typeof body === 'object') return Object.keys(body).length === 0;
    return false;
  }
  
  getBodyFieldCount(body) {
    if (!body || typeof body !== 'object') return 0;
    return Object.keys(body).length;
  }
  
  calculateFilesSize(files) {
    if (!files) return 0;
    
    const fileArray = Array.isArray(files) ? files : Object.values(files);
    return fileArray.reduce((total, file) => total + (file.size || 0), 0);
  }
  
  getFileTypes(files) {
    if (!files) return [];
    
    const fileArray = Array.isArray(files) ? files : Object.values(files);
    return [...new Set(fileArray.map(file => file.mimetype).filter(Boolean))];
  }
  
  sanitizeCookies(cookies) {
    if (!cookies) return null;
    
    const sanitized = {};
    const sensitiveCookieNames = ['session', 'token', 'auth', 'jwt', 'csrf'];
    
    Object.keys(cookies).forEach(name => {
      const lowerName = name.toLowerCase();
      if (sensitiveCookieNames.some(sensitive => lowerName.includes(sensitive))) {
        sanitized[name] = '[REDACTED]';
      } else {
        sanitized[name] = cookies[name];
      }
    });
    
    return sanitized;
  }
  
  sanitizeResponseHeaders(headers) {
    const sanitized = { ...headers };
    const sensitiveHeaders = ['set-cookie', 'authorization', 'x-auth-token'];
    
    sensitiveHeaders.forEach(header => {
      if (sanitized[header]) {
        sanitized[header] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
  
  maskEmail(email) {
    const [local, domain] = email.split('@');
    if (local.length <= 2) return `${local}@${domain}`;
    
    const maskedLocal = `${local[0]}${'*'.repeat(local.length - 2)}${local[local.length - 1]}`;
    return `${maskedLocal}@${domain}`;
  }
  
  categorizeResponseTime(duration) {
    if (duration < 100) return 'fast';
    if (duration < 500) return 'normal';
    if (duration < 1000) return 'slow';
    if (duration < 5000) return 'very_slow';
    return 'extremely_slow';
  }
  
  isStaticAsset(path) {
    const staticExtensions = ['.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.woff', '.woff2'];
    return staticExtensions.some(ext => path.endsWith(ext));
  }
  
  isHealthCheck(path) {
    const healthPaths = ['/health', '/ping', '/status', '/alive', '/ready'];
    return healthPaths.some(healthPath => path.startsWith(healthPath));
  }
  
  isAdminRequest(path) {
    return path.startsWith('/admin/') || path.startsWith('/management/');
  }
  
  isPublicEndpoint(path) {
    const publicPaths = ['/login', '/register', '/forgot-password', '/public/', '/assets/'];
    return publicPaths.some(publicPath => path.startsWith(publicPath));
  }
  
  createContextSummary(context) {
    return {
      method: context.request.method,
      url: context.request.url,
      userAgent: context.headers.userAgent,
      ip: context.network.ip,
      userId: context.user?.id,
      authenticated: !!context.user
    };
  }
  
  cleanupOldContexts() {
    const maxAge = 60 * 60 * 1000; // 1 hour
    const now = Date.now();
    
    this.activeContexts.forEach((context, id) => {
      if (now - context.storedAt > maxAge) {
        this.activeContexts.delete(id);
      }
    });
    
    // Also cleanup history
    this.contextHistory.forEach((entry, id) => {
      if (now - new Date(entry.createdAt).getTime() > maxAge) {
        this.contextHistory.delete(id);
      }
    });
  }
  
  getContextStatistics() {
    return {
      activeContexts: this.activeContexts.size,
      historicalContexts: this.contextHistory.size,
      memoryUsage: {
        activeContextsSize: this.estimateMapSize(this.activeContexts),
        historySize: this.estimateMapSize(this.contextHistory)
      }
    };
  }
  
  estimateMapSize(map) {
    // Rough estimation of memory usage
    let size = 0;
    map.forEach(value => {
      size += JSON.stringify(value).length;
    });
    return size;
  }
}
```

### 2. **Business Context Enrichment**
Adding business-specific context to logs for better understanding of business operations.

```javascript
// Business context enrichment system
class BusinessContextEnricher {
  constructor(logger) {
    this.logger = logger.child({ component: 'BusinessContextEnricher' });
    this.businessRules = this.setupBusinessRules();
    this.contextProviders = this.setupContextProviders();
    this.entityResolvers = this.setupEntityResolvers();
  }
  
  setupBusinessRules() {
    return {
      // Define business entities and their relationships
      entities: {
        user: {
          identifiers: ['userId', 'user_id', 'customerId', 'customer_id'],
          relationships: ['account', 'subscription', 'organization'],
          sensitiveFields: ['email', 'phone', 'ssn', 'address']
        },
        
        account: {
          identifiers: ['accountId', 'account_id'],
          relationships: ['user', 'subscription', 'transaction'],
          sensitiveFields: ['balance', 'accountNumber', 'routingNumber']
        },
        
        order: {
          identifiers: ['orderId', 'order_id', 'transactionId'],
          relationships: ['user', 'account', 'product'],
          sensitiveFields: ['amount', 'paymentMethod', 'billingAddress']
        },
        
        product: {
          identifiers: ['productId', 'product_id', 'sku'],
          relationships: ['category', 'vendor', 'inventory'],
          sensitiveFields: ['cost', 'margin', 'vendorPrice']
        },
        
        organization: {
          identifiers: ['orgId', 'organizationId', 'companyId'],
          relationships: ['user', 'subscription', 'billing'],
          sensitiveFields: ['revenue', 'contractTerms', 'pricing']
        }
      },
      
      // Business operations that require context
      operations: {
        payment: {
          contextFields: ['amount', 'currency', 'paymentMethod', 'gateway'],
          auditLevel: 'high',
          retentionPeriod: '7 years'
        },
        
        userRegistration: {
          contextFields: ['email', 'source', 'referrer', 'plan'],
          auditLevel: 'medium',
          retentionPeriod: '3 years'
        },
        
        dataAccess: {
          contextFields: ['resource', 'permissions', 'dataType', 'sensitivity'],
          auditLevel: 'high',
          retentionPeriod: '5 years'
        },
        
        configurationChange: {
          contextFields: ['setting', 'oldValue', 'newValue', 'impact'],
          auditLevel: 'critical',
          retentionPeriod: '10 years'
        }
      },
      
      // Compliance requirements
      compliance: {
        gdpr: {
          personalDataFields: ['email', 'name', 'address', 'phone', 'ip'],
          retentionRequirements: true,
          consentTracking: true
        },
        
        pci: {
          cardDataFields: ['cardNumber', 'cvv', 'expiryDate'],
          encryptionRequired: true,
          accessLogging: true
        },
        
        sox: {
          financialDataFields: ['amount', 'balance', 'revenue', 'cost'],
          auditTrailRequired: true,
          segregationOfDuties: true
        }
      }
    };
  }
  
  setupContextProviders() {
    return {
      // User context provider
      user: async (userId) => {
        // In a real implementation, this would query the user service/database
        return {
          profile: {
            id: userId,
            segment: 'premium',
            tenure: '2 years',
            lifetimeValue: 5000,
            riskScore: 'low',
            preferences: {
              language: 'en',
              timezone: 'America/New_York',
              notifications: 'email'
            }
          },
          
          subscription: {
            plan: 'professional',
            status: 'active',
            renewalDate: '2024-12-31',
            features: ['advanced_analytics', 'priority_support'],
            billingCycle: 'monthly'
          },
          
          organization: {
            id: 'org_123',
            name: 'Acme Corp',
            tier: 'enterprise',
            industry: 'technology',
            size: '1000-5000'
          },
          
          behavior: {
            lastLoginAt: '2024-01-15T10:30:00Z',
            loginFrequency: 'daily',
            averageSessionDuration: 45,
            primaryDevices: ['desktop', 'mobile'],
            featureUsage: ['dashboard', 'reports', 'api']
          }
        };
      },
      
      // Transaction context provider
      transaction: async (transactionId) => {
        return {
          financial: {
            amount: 99.99,
            currency: 'USD',
            type: 'subscription_payment',
            gateway: 'stripe',
            fees: 3.50,
            netAmount: 96.49
          },
          
          workflow: {
            status: 'completed',
            steps: ['validation', 'authorization', 'capture', 'settlement'],
            currentStep: 'settlement',
            retryCount: 0,
            timeToComplete: 1500
          },
          
          risk: {
            score: 25,
            level: 'low',
            factors: ['verified_user', 'known_device', 'normal_amount'],
            checks: ['fraud_detection', 'velocity_check', 'blacklist_check']
          },
          
          compliance: {
            regulations: ['PCI-DSS'],
            auditRequired: true,
            dataClassification: 'restricted',
            retentionPeriod: '7 years'
          }
        };
      },
      
      // Product context provider
      product: async (productId) => {
        return {
          catalog: {
            name: 'Professional Plan',
            category: 'subscription',
            sku: 'PROF-MONTHLY',
            version: '2.1',
            lifecycle: 'active'
          },
          
          business: {
            revenue: 'high',
            margin: 'healthy',
            competitiveness: 'strong',
            demandLevel: 'high',
            seasonality: 'none'
          },
          
          technical: {
            complexity: 'medium',
            dependencies: ['payment_service', 'user_service'],
            maintainability: 'good',
            scalability: 'excellent'
          },
          
          analytics: {
            popularityRank: 2,
            conversionRate: 15.5,
            churnRate: 2.1,
            supportTickets: 'low',
            userSatisfaction: 4.7
          }
        };
      },
      
      // Campaign context provider
      campaign: async (campaignId) => {
        return {
          marketing: {
            name: 'Q1 Growth Campaign',
            type: 'acquisition',
            channel: 'email',
            audience: 'prospects',
            budget: 50000,
            spend: 35000
          },
          
          performance: {
            impressions: 150000,
            clicks: 4500,
            conversions: 225,
            ctr: 3.0,
            conversionRate: 5.0,
            costPerAcquisition: 155.56
          },
          
          targeting: {
            demographics: ['age:25-45', 'income:high'],
            geography: ['US', 'CA', 'UK'],
            interests: ['technology', 'business'],
            behavior: ['frequent_buyer', 'email_engaged']
          },
          
          timeline: {
            startDate: '2024-01-01',
            endDate: '2024-03-31',
            phase: 'active',
            daysRemaining: 45
          }
        };
      }
    };
  }
  
  setupEntityResolvers() {
    return {
      // Resolve entity from various identifier formats
      resolveEntity: (data) => {
        const entities = [];
        const rules = this.businessRules.entities;
        
        Object.entries(rules).forEach(([entityType, config]) => {
          config.identifiers.forEach(identifier => {
            if (data[identifier]) {
              entities.push({
                type: entityType,
                id: data[identifier],
                identifier
              });
            }
          });
        });
        
        return entities;
      },
      
      // Extract business operation context
      identifyOperation: (data, metadata) => {
        const operations = this.businessRules.operations;
        
        // Look for operation indicators in the data
        if (data.amount || data.payment || data.transaction) {
          return 'payment';
        }
        
        if (data.email && metadata.action === 'create') {
          return 'userRegistration';
        }
        
        if (metadata.resource && metadata.action === 'read') {
          return 'dataAccess';
        }
        
        if (metadata.configuration || metadata.settings) {
          return 'configurationChange';
        }
        
        return 'general';
      },
      
      // Determine compliance requirements
      getComplianceContext: (entities, operation, data) => {
        const compliance = this.businessRules.compliance;
        const applicableRegulations = [];
        
        // Check for personal data (GDPR)
        if (this.hasPersonalData(data)) {
          applicableRegulations.push('gdpr');
        }
        
        // Check for payment card data (PCI)
        if (this.hasCardData(data)) {
          applicableRegulations.push('pci');
        }
        
        // Check for financial data (SOX)
        if (this.hasFinancialData(data)) {
          applicableRegulations.push('sox');
        }
        
        return {
          regulations: applicableRegulations,
          requirements: applicableRegulations.map(reg => compliance[reg])
        };
      }
    };
  }
  
  async enrichWithBusinessContext(logData, metadata = {}) {
    try {
      // Identify entities in the log data
      const entities = this.entityResolvers.resolveEntity(logData);
      
      // Identify business operation
      const operation = this.entityResolvers.identifyOperation(logData, metadata);
      
      // Get compliance context
      const compliance = this.entityResolvers.getComplianceContext(entities, operation, logData);
      
      // Enrich with business context from providers
      const businessContext = {
        entities: {},
        operation: {
          type: operation,
          config: this.businessRules.operations[operation]
        },
        compliance
      };
      
      // Fetch context for each identified entity
      for (const entity of entities) {
        if (this.contextProviders[entity.type]) {
          try {
            const context = await this.contextProviders[entity.type](entity.id);
            businessContext.entities[entity.type] = {
              id: entity.id,
              ...context
            };
          } catch (error) {
            this.logger.warn('Failed to fetch business context', {
              entityType: entity.type,
              entityId: entity.id,
              error: error.message
            });
          }
        }
      }
      
      // Add workflow context if available
      if (metadata.workflowId) {
        businessContext.workflow = await this.getWorkflowContext(metadata.workflowId);
      }
      
      // Add campaign context if available
      if (metadata.campaignId) {
        businessContext.campaign = await this.contextProviders.campaign(metadata.campaignId);
      }
      
      // Add business metrics
      businessContext.metrics = {
        businessValue: this.calculateBusinessValue(entities, operation),
        riskLevel: this.assessBusinessRisk(entities, operation, logData),
        impactScope: this.assessImpactScope(entities, operation),
        urgency: this.assessUrgency(operation, logData)
      };
      
      return businessContext;
      
    } catch (error) {
      this.logger.error('Failed to enrich business context', {
        error: error.message,
        logData: this.sanitizeLogData(logData),
        metadata
      });
      
      return {
        entities: {},
        operation: { type: 'unknown' },
        compliance: { regulations: [], requirements: [] },
        error: error.message
      };
    }
  }
  
  async logWithBusinessContext(level, message, data = {}, metadata = {}) {
    // Enrich with business context
    const businessContext = await this.enrichWithBusinessContext(data, metadata);
    
    // Create enhanced log entry
    const enhancedLogEntry = {
      message,
      data: this.sanitizeBusinessData(data, businessContext.compliance),
      business: businessContext,
      metadata: {
        ...metadata,
        hasBusinessContext: true,
        entitiesCount: Object.keys(businessContext.entities).length,
        operationType: businessContext.operation.type,
        complianceRegulations: businessContext.compliance.regulations
      },
      timestamp: new Date().toISOString(),
      level: level.toUpperCase()
    };
    
    // Apply business-specific logging rules
    const logLevel = this.adjustLogLevel(level, businessContext);
    
    this.logger[logLevel](message, enhancedLogEntry);
    
    // Trigger additional processing if required
    await this.processBusinessRules(enhancedLogEntry, businessContext);
    
    return enhancedLogEntry;
  }
  
  adjustLogLevel(originalLevel, businessContext) {
    // Upgrade log level for high-value or high-risk operations
    if (businessContext.metrics.businessValue === 'high' || 
        businessContext.metrics.riskLevel === 'high') {
      
      if (originalLevel === 'debug') return 'info';
      if (originalLevel === 'info') return 'warn';
    }
    
    // Upgrade for compliance-sensitive operations
    if (businessContext.compliance.regulations.length > 0) {
      if (originalLevel === 'debug') return 'info';
    }
    
    return originalLevel;
  }
  
  async processBusinessRules(logEntry, businessContext) {
    // Process compliance requirements
    if (businessContext.compliance.regulations.includes('gdpr')) {
      await this.processGDPRRequirements(logEntry);
    }
    
    if (businessContext.compliance.regulations.includes('pci')) {
      await this.processPCIRequirements(logEntry);
    }
    
    // Process business alerts
    if (businessContext.metrics.riskLevel === 'high') {
      await this.triggerRiskAlert(logEntry, businessContext);
    }
    
    // Process business analytics
    await this.updateBusinessMetrics(logEntry, businessContext);
  }
  
  async getWorkflowContext(workflowId) {
    // Mock workflow context - in practice, would query workflow service
    return {
      id: workflowId,
      name: 'User Onboarding',
      version: '2.1',
      status: 'active',
      currentStep: 'verification',
      progress: 60,
      estimatedCompletion: '2024-01-16T15:00:00Z',
      sla: {
        target: 24,
        unit: 'hours',
        remaining: 18
      }
    };
  }
  
  calculateBusinessValue(entities, operation) {
    // Calculate business value based on entities and operation
    let value = 'low';
    
    if (entities.some(e => e.type === 'transaction')) value = 'high';
    if (entities.some(e => e.type === 'user')) value = 'medium';
    if (operation === 'payment') value = 'high';
    
    return value;
  }
  
  assessBusinessRisk(entities, operation, data) {
    let risk = 'low';
    
    if (operation === 'payment' && data.amount > 1000) risk = 'medium';
    if (operation === 'dataAccess' && data.sensitivity === 'high') risk = 'high';
    if (entities.some(e => e.type === 'organization')) risk = 'medium';
    
    return risk;
  }
  
  assessImpactScope(entities, operation) {
    if (entities.some(e => e.type === 'organization')) return 'organization';
    if (entities.some(e => e.type === 'user')) return 'user';
    return 'system';
  }
  
  assessUrgency(operation, data) {
    if (operation === 'payment' && data.status === 'failed') return 'high';
    if (operation === 'configurationChange') return 'medium';
    return 'low';
  }
  
  hasPersonalData(data) {
    const personalDataFields = ['email', 'name', 'address', 'phone', 'ip'];
    return personalDataFields.some(field => data[field]);
  }
  
  hasCardData(data) {
    const cardDataFields = ['cardNumber', 'cvv', 'expiryDate'];
    return cardDataFields.some(field => data[field]);
  }
  
  hasFinancialData(data) {
    const financialFields = ['amount', 'balance', 'revenue', 'cost'];
    return financialFields.some(field => data[field]);
  }
  
  sanitizeLogData(data) {
    // Remove sensitive information for error logging
    const sanitized = { ...data };
    const sensitiveFields = ['password', 'token', 'ssn', 'cardNumber'];
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
  
  sanitizeBusinessData(data, compliance) {
    const sanitized = { ...data };
    
    // Apply GDPR sanitization
    if (compliance.regulations.includes('gdpr')) {
      const gdprFields = ['email', 'name', 'address', 'phone'];
      gdprFields.forEach(field => {
        if (sanitized[field]) {
          sanitized[field] = this.maskPersonalData(sanitized[field]);
        }
      });
    }
    
    // Apply PCI sanitization
    if (compliance.regulations.includes('pci')) {
      const pciFields = ['cardNumber', 'cvv'];
      pciFields.forEach(field => {
        if (sanitized[field]) {
          sanitized[field] = '[REDACTED]';
        }
      });
    }
    
    return sanitized;
  }
  
  maskPersonalData(value) {
    if (typeof value === 'string' && value.includes('@')) {
      // Email masking
      const [local, domain] = value.split('@');
      return `${local[0]}***@${domain}`;
    }
    
    if (typeof value === 'string' && value.length > 4) {
      // General string masking
      return `${value.substring(0, 2)}***${value.substring(value.length - 2)}`;
    }
    
    return '[MASKED]';
  }
  
  // Mock methods for business rule processing
  async processGDPRRequirements(logEntry) {
    // Implementation would handle GDPR compliance
  }
  
  async processPCIRequirements(logEntry) {
    // Implementation would handle PCI compliance
  }
  
  async triggerRiskAlert(logEntry, businessContext) {
    // Implementation would trigger risk alerts
  }
  
  async updateBusinessMetrics(logEntry, businessContext) {
    // Implementation would update business metrics
  }
}
```

---

**Previous**: [2.2.5 Message Content](./2.2.5_Message_Content.md)  
**Next**: [2.2.7 Stack Traces](./2.2.7_Stack_Traces.md)
