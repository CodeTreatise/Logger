# 2.2.3 Logger Name/Category

## Understanding Logger Names and Categories

Logger names and categories provide organizational structure to logs, enabling precise filtering, routing, and analysis. They create hierarchical namespaces that reflect application architecture, facilitate debugging by component, and enable fine-grained log level control across different parts of the system.

## Hierarchical Logger Naming Conventions

### 1. **Package-Based Naming Structure**
Following Java-style package naming conventions for clear hierarchy.

```javascript
// Package-based logger naming implementation
class PackageBasedLoggerNaming {
  constructor(baseLogger) {
    this.baseLogger = baseLogger;
    this.loggerRegistry = new Map();
    this.namingRules = this.setupNamingRules();
    this.hierarchyManager = this.setupHierarchyManager();
  }
  
  setupNamingRules() {
    return {
      // Standard package-style naming patterns
      patterns: {
        // Application layer structure
        application: {
          root: 'com.company.application',
          controllers: 'com.company.application.controllers',
          services: 'com.company.application.services',
          repositories: 'com.company.application.repositories',
          models: 'com.company.application.models',
          middleware: 'com.company.application.middleware',
          utilities: 'com.company.application.utils'
        },
        
        // Infrastructure layer structure
        infrastructure: {
          root: 'com.company.infrastructure',
          database: 'com.company.infrastructure.database',
          cache: 'com.company.infrastructure.cache',
          messaging: 'com.company.infrastructure.messaging',
          security: 'com.company.infrastructure.security',
          monitoring: 'com.company.infrastructure.monitoring',
          configuration: 'com.company.infrastructure.config'
        },
        
        // Domain layer structure
        domain: {
          root: 'com.company.domain',
          user: 'com.company.domain.user',
          order: 'com.company.domain.order',
          payment: 'com.company.domain.payment',
          inventory: 'com.company.domain.inventory',
          notification: 'com.company.domain.notification'
        },
        
        // External integrations
        external: {
          root: 'com.company.external',
          apis: 'com.company.external.apis',
          thirdparty: 'com.company.external.thirdparty',
          webhooks: 'com.company.external.webhooks'
        }
      },
      
      // Naming validation rules
      validation: {
        maxLength: 255,
        allowedCharacters: /^[a-zA-Z0-9._-]+$/,
        reservedNames: ['root', 'system', 'global', 'default'],
        requirePrefix: true,
        hierarchySeparator: '.',
        maxDepth: 8
      },
      
      // Automatic name generation rules
      generation: {
        fromFilePath: (filePath) => {
          // Convert file path to logger name
          const relativePath = filePath.replace(process.cwd(), '');
          const withoutExtension = relativePath.replace(/\.(js|ts|jsx|tsx)$/, '');
          const normalized = withoutExtension
            .replace(/^\/+/, '')
            .replace(/\/+/g, '.')
            .replace(/[^a-zA-Z0-9._-]/g, '_');
          
          return `com.company.application.${normalized}`;
        },
        
        fromClassName: (className, namespace = '') => {
          const prefix = namespace || 'com.company.application';
          const normalizedClass = className
            .replace(/([A-Z])/g, (match, letter, index) => 
              index > 0 ? `_${letter.toLowerCase()}` : letter.toLowerCase());
          
          return `${prefix}.${normalizedClass}`;
        },
        
        fromModuleName: (moduleName) => {
          return `com.company.application.modules.${moduleName.toLowerCase()}`;
        }
      }
    };
  }
  
  setupHierarchyManager() {
    return {
      // Get parent logger name
      getParent: (loggerName) => {
        const parts = loggerName.split('.');
        if (parts.length <= 1) return null;
        return parts.slice(0, -1).join('.');
      },
      
      // Get all ancestor logger names
      getAncestors: (loggerName) => {
        const parts = loggerName.split('.');
        const ancestors = [];
        
        for (let i = parts.length - 1; i > 0; i--) {
          ancestors.push(parts.slice(0, i).join('.'));
        }
        
        return ancestors;
      },
      
      // Get child logger names
      getChildren: (parentName) => {
        const children = [];
        const prefix = parentName + '.';
        
        for (const [name] of this.loggerRegistry) {
          if (name.startsWith(prefix) && 
              name.split('.').length === parentName.split('.').length + 1) {
            children.push(name);
          }
        }
        
        return children;
      },
      
      // Get all descendant logger names
      getDescendants: (ancestorName) => {
        const descendants = [];
        const prefix = ancestorName + '.';
        
        for (const [name] of this.loggerRegistry) {
          if (name.startsWith(prefix)) {
            descendants.push(name);
          }
        }
        
        return descendants;
      },
      
      // Calculate logger depth in hierarchy
      getDepth: (loggerName) => {
        return loggerName.split('.').length;
      },
      
      // Find common ancestor
      findCommonAncestor: (loggerName1, loggerName2) => {
        const parts1 = loggerName1.split('.');
        const parts2 = loggerName2.split('.');
        const commonParts = [];
        
        const minLength = Math.min(parts1.length, parts2.length);
        for (let i = 0; i < minLength; i++) {
          if (parts1[i] === parts2[i]) {
            commonParts.push(parts1[i]);
          } else {
            break;
          }
        }
        
        return commonParts.length > 0 ? commonParts.join('.') : null;
      }
    };
  }
  
  createLogger(name, options = {}) {
    // Validate logger name
    this.validateLoggerName(name);
    
    // Check if logger already exists
    if (this.loggerRegistry.has(name)) {
      return this.loggerRegistry.get(name);
    }
    
    // Create logger with hierarchical configuration
    const loggerConfig = this.buildLoggerConfig(name, options);
    const logger = this.baseLogger.child({
      name,
      ...loggerConfig
    });
    
    // Register logger
    this.loggerRegistry.set(name, logger);
    
    // Set up inheritance from parent loggers
    this.setupInheritance(name, logger);
    
    // Log creation
    this.baseLogger.debug('Logger created', {
      name,
      hierarchy: this.getLoggerHierarchyInfo(name),
      config: loggerConfig,
      registrySize: this.loggerRegistry.size
    });
    
    return logger;
  }
  
  buildLoggerConfig(name, options) {
    const config = {
      name,
      component: this.extractComponent(name),
      layer: this.extractLayer(name),
      module: this.extractModule(name),
      hierarchy: {
        parent: this.hierarchyManager.getParent(name),
        depth: this.hierarchyManager.getDepth(name),
        ancestors: this.hierarchyManager.getAncestors(name)
      },
      metadata: {
        createdAt: new Date().toISOString(),
        creator: options.creator || 'system',
        purpose: options.purpose || 'general',
        criticality: options.criticality || 'medium'
      },
      ...options
    };
    
    // Apply inheritance rules
    this.applyInheritanceRules(config);
    
    return config;
  }
  
  validateLoggerName(name) {
    const rules = this.namingRules.validation;
    
    if (!name || typeof name !== 'string') {
      throw new Error('Logger name must be a non-empty string');
    }
    
    if (name.length > rules.maxLength) {
      throw new Error(`Logger name exceeds maximum length of ${rules.maxLength}`);
    }
    
    if (!rules.allowedCharacters.test(name)) {
      throw new Error('Logger name contains invalid characters');
    }
    
    if (rules.reservedNames.includes(name.toLowerCase())) {
      throw new Error(`Logger name '${name}' is reserved`);
    }
    
    if (rules.requirePrefix && !name.includes('.')) {
      throw new Error('Logger name must include hierarchical prefix');
    }
    
    if (this.hierarchyManager.getDepth(name) > rules.maxDepth) {
      throw new Error(`Logger name exceeds maximum hierarchy depth of ${rules.maxDepth}`);
    }
  }
  
  extractComponent(loggerName) {
    const parts = loggerName.split('.');
    
    // Try to identify component from name patterns
    if (parts.includes('controllers')) return 'controller';
    if (parts.includes('services')) return 'service';
    if (parts.includes('repositories')) return 'repository';
    if (parts.includes('middleware')) return 'middleware';
    if (parts.includes('models')) return 'model';
    if (parts.includes('utils')) return 'utility';
    if (parts.includes('database')) return 'database';
    if (parts.includes('cache')) return 'cache';
    if (parts.includes('security')) return 'security';
    if (parts.includes('external')) return 'external';
    
    return parts[parts.length - 1] || 'unknown';
  }
  
  extractLayer(loggerName) {
    if (loggerName.includes('.application.')) return 'application';
    if (loggerName.includes('.infrastructure.')) return 'infrastructure';
    if (loggerName.includes('.domain.')) return 'domain';
    if (loggerName.includes('.external.')) return 'external';
    
    return 'unknown';
  }
  
  extractModule(loggerName) {
    const parts = loggerName.split('.');
    
    // Find module-specific parts
    for (let i = 0; i < parts.length; i++) {
      if (['user', 'order', 'payment', 'inventory', 'notification'].includes(parts[i])) {
        return parts[i];
      }
    }
    
    return parts[parts.length - 1] || 'core';
  }
  
  getLoggerHierarchyInfo(name) {
    return {
      name,
      parent: this.hierarchyManager.getParent(name),
      children: this.hierarchyManager.getChildren(name),
      ancestors: this.hierarchyManager.getAncestors(name),
      descendants: this.hierarchyManager.getDescendants(name),
      depth: this.hierarchyManager.getDepth(name),
      siblings: this.getSiblings(name)
    };
  }
  
  getSiblings(loggerName) {
    const parent = this.hierarchyManager.getParent(loggerName);
    if (!parent) return [];
    
    const children = this.hierarchyManager.getChildren(parent);
    return children.filter(child => child !== loggerName);
  }
}
```

### 2. **Component-Based Logger Organization**
Organizing loggers by application components and features.

```javascript
// Component-based logger organization
class ComponentBasedLoggerOrganization {
  constructor(baseLogger) {
    this.baseLogger = baseLogger;
    this.components = this.setupComponents();
    this.loggerFactory = this.setupLoggerFactory();
  }
  
  setupComponents() {
    return {
      // Web layer components
      web: {
        'api-gateway': {
          description: 'API Gateway and routing',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['routing', 'authentication', 'rate-limiting', 'load-balancing']
        },
        'controllers': {
          description: 'HTTP request controllers',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['user-controller', 'order-controller', 'payment-controller']
        },
        'middleware': {
          description: 'Express middleware functions',
          criticality: 'medium',
          logLevel: 'debug',
          subcomponents: ['cors', 'security', 'logging', 'error-handling']
        }
      },
      
      // Business logic components
      business: {
        'user-service': {
          description: 'User management and authentication',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['registration', 'authentication', 'profile', 'permissions']
        },
        'order-service': {
          description: 'Order processing and management',
          criticality: 'critical',
          logLevel: 'info',
          subcomponents: ['creation', 'fulfillment', 'tracking', 'cancellation']
        },
        'payment-service': {
          description: 'Payment processing',
          criticality: 'critical',
          logLevel: 'warn',
          subcomponents: ['gateway', 'validation', 'processing', 'refunds']
        },
        'inventory-service': {
          description: 'Inventory management',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['tracking', 'allocation', 'replenishment', 'reporting']
        }
      },
      
      // Data layer components
      data: {
        'database': {
          description: 'Database operations and connections',
          criticality: 'critical',
          logLevel: 'warn',
          subcomponents: ['connection-pool', 'queries', 'transactions', 'migrations']
        },
        'cache': {
          description: 'Caching layer operations',
          criticality: 'medium',
          logLevel: 'info',
          subcomponents: ['redis', 'memory-cache', 'invalidation', 'warming']
        },
        'search': {
          description: 'Search engine operations',
          criticality: 'medium',
          logLevel: 'info',
          subcomponents: ['indexing', 'querying', 'aggregation', 'suggestions']
        }
      },
      
      // Infrastructure components
      infrastructure: {
        'monitoring': {
          description: 'Application monitoring and metrics',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['health-checks', 'metrics', 'alerting', 'tracing']
        },
        'security': {
          description: 'Security-related operations',
          criticality: 'critical',
          logLevel: 'warn',
          subcomponents: ['authentication', 'authorization', 'encryption', 'audit']
        },
        'configuration': {
          description: 'Configuration management',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['loading', 'validation', 'hot-reload', 'secrets']
        }
      },
      
      // External integration components
      external: {
        'third-party-apis': {
          description: 'Third-party API integrations',
          criticality: 'medium',
          logLevel: 'info',
          subcomponents: ['http-client', 'retry-logic', 'circuit-breaker', 'rate-limiting']
        },
        'webhooks': {
          description: 'Webhook handling',
          criticality: 'medium',
          logLevel: 'info',
          subcomponents: ['incoming', 'outgoing', 'verification', 'retry']
        },
        'messaging': {
          description: 'Message queue operations',
          criticality: 'high',
          logLevel: 'info',
          subcomponents: ['producers', 'consumers', 'dead-letter', 'routing']
        }
      }
    };
  }
  
  setupLoggerFactory() {
    const factory = {
      // Create component logger
      createComponentLogger: (category, component, subcomponent = null) => {
        const componentInfo = this.components[category]?.[component];
        if (!componentInfo) {
          throw new Error(`Unknown component: ${category}.${component}`);
        }
        
        const loggerName = subcomponent ? 
          `${category}.${component}.${subcomponent}` : 
          `${category}.${component}`;
        
        const logger = this.baseLogger.child({
          component: loggerName,
          category,
          componentType: component,
          subcomponent,
          componentInfo: {
            description: componentInfo.description,
            criticality: componentInfo.criticality,
            defaultLevel: componentInfo.logLevel
          },
          metadata: {
            createdAt: new Date().toISOString(),
            factoryType: 'component-based'
          }
        });
        
        // Add component-specific methods
        this.addComponentMethods(logger, componentInfo);
        
        return logger;
      },
      
      // Create feature logger
      createFeatureLogger: (feature, operation = null) => {
        const loggerName = operation ? `feature.${feature}.${operation}` : `feature.${feature}`;
        
        return this.baseLogger.child({
          component: loggerName,
          feature,
          operation,
          type: 'feature',
          metadata: {
            createdAt: new Date().toISOString(),
            factoryType: 'feature-based'
          }
        });
      },
      
      // Create request logger
      createRequestLogger: (requestId, userId = null, sessionId = null) => {
        return this.baseLogger.child({
          component: 'request',
          requestId,
          userId,
          sessionId,
          type: 'request',
          metadata: {
            createdAt: new Date().toISOString(),
            factoryType: 'request-based'
          }
        });
      },
      
      // Create transaction logger
      createTransactionLogger: (transactionId, transactionType, userId = null) => {
        return this.baseLogger.child({
          component: `transaction.${transactionType}`,
          transactionId,
          transactionType,
          userId,
          type: 'transaction',
          metadata: {
            createdAt: new Date().toISOString(),
            factoryType: 'transaction-based'
          }
        });
      }
    };
    
    return factory;
  }
  
  addComponentMethods(logger, componentInfo) {
    // Add security logging for critical components
    if (componentInfo.criticality === 'critical') {
      logger.security = (message, data = {}) => {
        logger.warn(message, {
          ...data,
          securityEvent: true,
          requiresAudit: true,
          escalationLevel: 'immediate'
        });
      };
    }
    
    // Add performance logging
    logger.performance = (operation, duration, data = {}) => {
      const level = duration > 1000 ? 'warn' : 'info';
      logger[level](`Performance: ${operation}`, {
        ...data,
        operation,
        duration,
        performanceEvent: true,
        threshold: componentInfo.criticality === 'critical' ? 500 : 1000
      });
    };
    
    // Add business event logging
    logger.business = (event, data = {}) => {
      logger.info(`Business Event: ${event}`, {
        ...data,
        businessEvent: true,
        requiresAnalytics: true,
        component: logger.bindings().component
      });
    };
    
    // Add error context
    logger.errorWithContext = (error, context = {}) => {
      logger.error('Error occurred', {
        error: {
          message: error.message,
          stack: error.stack,
          name: error.name,
          code: error.code
        },
        context,
        component: logger.bindings().component,
        errorEvent: true,
        requiresInvestigation: true
      });
    };
  }
  
  // Demonstration of component logger usage
  demonstrateComponentLoggers() {
    const examples = {};
    
    // Web layer examples
    examples.apiGateway = this.loggerFactory.createComponentLogger('web', 'api-gateway', 'routing');
    examples.apiGateway.info('Request routed', { path: '/api/users', method: 'GET' });
    
    // Business layer examples
    examples.userService = this.loggerFactory.createComponentLogger('business', 'user-service', 'authentication');
    examples.userService.info('User authenticated', { userId: '12345' });
    
    // Data layer examples
    examples.database = this.loggerFactory.createComponentLogger('data', 'database', 'queries');
    examples.database.performance('SELECT query', 250, { table: 'users', rows: 100 });
    
    // Infrastructure examples
    examples.security = this.loggerFactory.createComponentLogger('infrastructure', 'security', 'audit');
    examples.security.security('Failed login attempt', { ip: '192.168.1.100', attempts: 3 });
    
    // Feature logger examples
    examples.checkout = this.loggerFactory.createFeatureLogger('checkout', 'payment-processing');
    examples.checkout.business('Checkout completed', { orderId: 'ORD-12345', amount: 99.99 });
    
    // Request logger examples
    examples.request = this.loggerFactory.createRequestLogger('req-123', 'user-456', 'sess-789');
    examples.request.info('Request processed', { endpoint: '/api/orders', status: 200 });
    
    this.baseLogger.info('Component logger demonstration', {
      exampleCount: Object.keys(examples).length,
      componentCategories: Object.keys(this.components),
      availableFactories: Object.keys(this.loggerFactory)
    });
    
    return examples;
  }
  
  getComponentHierarchy() {
    const hierarchy = {};
    
    Object.entries(this.components).forEach(([category, components]) => {
      hierarchy[category] = {
        description: `${category.charAt(0).toUpperCase() + category.slice(1)} layer components`,
        components: Object.keys(components),
        details: Object.entries(components).map(([name, info]) => ({
          name,
          description: info.description,
          criticality: info.criticality,
          subcomponents: info.subcomponents
        }))
      };
    });
    
    return hierarchy;
  }
}
```

### 3. **Dynamic Logger Categories**
Runtime creation and management of logger categories.

```javascript
// Dynamic logger category management
class DynamicLoggerCategoryManager {
  constructor(baseLogger) {
    this.baseLogger = baseLogger;
    this.categoryRegistry = new Map();
    this.categoryRules = this.setupCategoryRules();
    this.dynamicCategories = this.setupDynamicCategories();
  }
  
  setupCategoryRules() {
    return {
      // Category naming rules
      naming: {
        maxLength: 100,
        allowedPattern: /^[a-zA-Z][a-zA-Z0-9._-]*$/,
        reservedPrefixes: ['system', 'internal', 'reserved'],
        requiredSeparators: ['.', '-', '_'],
        hierarchyDepthLimit: 5
      },
      
      // Category lifecycle rules
      lifecycle: {
        autoExpiry: {
          enabled: true,
          defaultTTL: 3600000, // 1 hour
          maxTTL: 86400000,     // 24 hours
          cleanupInterval: 300000 // 5 minutes
        },
        
        usage: {
          trackUsage: true,
          minUsageToKeep: 10,
          usageWindow: 3600000 // 1 hour
        }
      },
      
      // Category behavior rules
      behavior: {
        inheritance: {
          enabled: true,
          inheritLevel: true,
          inheritFormatting: true,
          inheritDestinations: false
        },
        
        limits: {
          maxCategoriesPerHour: 1000,
          maxTotalCategories: 10000,
          warningThreshold: 8000
        }
      }
    };
  }
  
  setupDynamicCategories() {
    return {
      // Request-based categories
      request: {
        pattern: 'request.{requestId}',
        generator: (requestId) => ({
          name: `request.${requestId}`,
          ttl: 300000, // 5 minutes
          metadata: {
            type: 'request',
            requestId,
            createdAt: new Date().toISOString()
          }
        })
      },
      
      // User session categories
      session: {
        pattern: 'session.{sessionId}',
        generator: (sessionId, userId = null) => ({
          name: `session.${sessionId}`,
          ttl: 1800000, // 30 minutes
          metadata: {
            type: 'session',
            sessionId,
            userId,
            createdAt: new Date().toISOString()
          }
        })
      },
      
      // Transaction categories
      transaction: {
        pattern: 'transaction.{type}.{transactionId}',
        generator: (type, transactionId) => ({
          name: `transaction.${type}.${transactionId}`,
          ttl: 3600000, // 1 hour
          metadata: {
            type: 'transaction',
            transactionType: type,
            transactionId,
            createdAt: new Date().toISOString()
          }
        })
      },
      
      // Feature flag categories
      feature: {
        pattern: 'feature.{featureName}',
        generator: (featureName, environment = 'production') => ({
          name: `feature.${featureName}`,
          ttl: 7200000, // 2 hours
          metadata: {
            type: 'feature',
            featureName,
            environment,
            createdAt: new Date().toISOString()
          }
        })
      },
      
      // A/B test categories
      experiment: {
        pattern: 'experiment.{experimentId}',
        generator: (experimentId, variant = null) => ({
          name: variant ? `experiment.${experimentId}.${variant}` : `experiment.${experimentId}`,
          ttl: 86400000, // 24 hours
          metadata: {
            type: 'experiment',
            experimentId,
            variant,
            createdAt: new Date().toISOString()
          }
        })
      },
      
      // Error correlation categories
      error: {
        pattern: 'error.{correlationId}',
        generator: (correlationId, errorType = 'general') => ({
          name: `error.${correlationId}`,
          ttl: 7200000, // 2 hours
          metadata: {
            type: 'error',
            correlationId,
            errorType,
            createdAt: new Date().toISOString()
          }
        })
      }
    };
  }
  
  createDynamicCategory(type, ...params) {
    const categoryTemplate = this.dynamicCategories[type];
    if (!categoryTemplate) {
      throw new Error(`Unknown dynamic category type: ${type}`);
    }
    
    // Generate category configuration
    const categoryConfig = categoryTemplate.generator(...params);
    
    // Validate category
    this.validateCategory(categoryConfig);
    
    // Check limits
    this.checkCategoryLimits();
    
    // Create or retrieve existing category
    let category = this.categoryRegistry.get(categoryConfig.name);
    if (category) {
      // Update TTL and usage
      category.lastUsed = new Date();
      category.usageCount++;
      return category.logger;
    }
    
    // Create new category
    category = {
      name: categoryConfig.name,
      type,
      metadata: categoryConfig.metadata,
      ttl: categoryConfig.ttl,
      createdAt: new Date(),
      lastUsed: new Date(),
      usageCount: 1,
      logger: this.createCategoryLogger(categoryConfig)
    };
    
    // Register category
    this.categoryRegistry.set(categoryConfig.name, category);
    
    // Set up automatic cleanup
    this.scheduleCategoryCleanup(category);
    
    this.baseLogger.debug('Dynamic category created', {
      name: categoryConfig.name,
      type,
      metadata: categoryConfig.metadata,
      registrySize: this.categoryRegistry.size
    });
    
    return category.logger;
  }
  
  createCategoryLogger(categoryConfig) {
    const logger = this.baseLogger.child({
      category: categoryConfig.name,
      categoryType: categoryConfig.metadata.type,
      categoryMetadata: categoryConfig.metadata,
      dynamic: true
    });
    
    // Add dynamic category methods
    this.addDynamicMethods(logger, categoryConfig);
    
    return logger;
  }
  
  addDynamicMethods(logger, categoryConfig) {
    // Add correlation method
    logger.correlate = (correlationId, data = {}) => {
      logger.info('Correlated event', {
        correlationId,
        ...data,
        categoryCorrelation: categoryConfig.name
      });
    };
    
    // Add timing method for performance tracking
    logger.time = (operation) => {
      const startTime = process.hrtime.bigint();
      
      return {
        end: (data = {}) => {
          const endTime = process.hrtime.bigint();
          const duration = Number(endTime - startTime) / 1000000; // Convert to milliseconds
          
          logger.info(`Timing: ${operation}`, {
            operation,
            duration,
            ...data,
            timingEvent: true
          });
          
          return duration;
        }
      };
    };
    
    // Add context method
    logger.addContext = (context) => {
      return logger.child(context);
    };
    
    // Add batch logging method
    logger.batch = (events) => {
      events.forEach(event => {
        const { level = 'info', message, data = {} } = event;
        logger[level](message, {
          ...data,
          batchEvent: true,
          batchSize: events.length
        });
      });
    };
  }
  
  validateCategory(categoryConfig) {
    const rules = this.categoryRules.naming;
    
    if (!categoryConfig.name || typeof categoryConfig.name !== 'string') {
      throw new Error('Category name must be a non-empty string');
    }
    
    if (categoryConfig.name.length > rules.maxLength) {
      throw new Error(`Category name exceeds maximum length of ${rules.maxLength}`);
    }
    
    if (!rules.allowedPattern.test(categoryConfig.name)) {
      throw new Error('Category name contains invalid characters');
    }
    
    // Check for reserved prefixes
    const hasReservedPrefix = rules.reservedPrefixes.some(prefix => 
      categoryConfig.name.toLowerCase().startsWith(prefix)
    );
    
    if (hasReservedPrefix) {
      throw new Error('Category name uses reserved prefix');
    }
    
    // Check hierarchy depth
    const depth = categoryConfig.name.split(/[._-]/).length;
    if (depth > rules.hierarchyDepthLimit) {
      throw new Error(`Category hierarchy depth exceeds limit of ${rules.hierarchyDepthLimit}`);
    }
  }
  
  checkCategoryLimits() {
    const limits = this.categoryRules.behavior.limits;
    const currentCount = this.categoryRegistry.size;
    
    if (currentCount >= limits.maxTotalCategories) {
      throw new Error(`Maximum number of categories (${limits.maxTotalCategories}) exceeded`);
    }
    
    if (currentCount >= limits.warningThreshold) {
      this.baseLogger.warn('Category count approaching limit', {
        currentCount,
        maxCategories: limits.maxTotalCategories,
        threshold: limits.warningThreshold
      });
    }
    
    // Check hourly creation rate
    const oneHourAgo = new Date(Date.now() - 3600000);
    const recentCategories = Array.from(this.categoryRegistry.values())
      .filter(category => category.createdAt > oneHourAgo);
    
    if (recentCategories.length >= limits.maxCategoriesPerHour) {
      throw new Error(`Hourly category creation limit (${limits.maxCategoriesPerHour}) exceeded`);
    }
  }
  
  scheduleCategoryCleanup(category) {
    setTimeout(() => {
      this.cleanupCategory(category.name);
    }, category.ttl);
  }
  
  cleanupCategory(categoryName) {
    const category = this.categoryRegistry.get(categoryName);
    if (!category) return;
    
    // Check if category is still in use
    const timeSinceLastUse = Date.now() - category.lastUsed.getTime();
    const rules = this.categoryRules.lifecycle;
    
    if (timeSinceLastUse < category.ttl && 
        category.usageCount >= rules.usage.minUsageToKeep) {
      // Extend TTL
      this.scheduleCategoryCleanup(category);
      return;
    }
    
    // Remove category
    this.categoryRegistry.delete(categoryName);
    
    this.baseLogger.debug('Dynamic category cleaned up', {
      name: categoryName,
      usageCount: category.usageCount,
      lifespan: Date.now() - category.createdAt.getTime(),
      registrySize: this.categoryRegistry.size
    });
  }
  
  getCategoryStatistics() {
    const stats = {
      totalCategories: this.categoryRegistry.size,
      categoryTypes: {},
      usage: {
        totalUsage: 0,
        averageUsage: 0,
        mostUsed: null,
        leastUsed: null
      },
      lifecycle: {
        oldestCategory: null,
        newestCategory: null,
        averageLifespan: 0
      }
    };
    
    const categories = Array.from(this.categoryRegistry.values());
    
    // Calculate type distribution
    categories.forEach(category => {
      stats.categoryTypes[category.type] = (stats.categoryTypes[category.type] || 0) + 1;
      stats.usage.totalUsage += category.usageCount;
    });
    
    if (categories.length > 0) {
      stats.usage.averageUsage = stats.usage.totalUsage / categories.length;
      
      // Find most and least used
      stats.usage.mostUsed = categories.reduce((max, cat) => 
        cat.usageCount > max.usageCount ? cat : max);
      stats.usage.leastUsed = categories.reduce((min, cat) => 
        cat.usageCount < min.usageCount ? cat : min);
      
      // Find oldest and newest
      stats.lifecycle.oldestCategory = categories.reduce((oldest, cat) => 
        cat.createdAt < oldest.createdAt ? cat : oldest);
      stats.lifecycle.newestCategory = categories.reduce((newest, cat) => 
        cat.createdAt > newest.createdAt ? cat : newest);
      
      // Calculate average lifespan
      const totalLifespan = categories.reduce((sum, cat) => 
        sum + (Date.now() - cat.createdAt.getTime()), 0);
      stats.lifecycle.averageLifespan = totalLifespan / categories.length;
    }
    
    return stats;
  }
}
```

## Logger Name Resolution and Inheritance

### 1. **Logger Inheritance System**
```javascript
// Logger inheritance and configuration propagation
class LoggerInheritanceSystem {
  constructor(baseLogger) {
    this.baseLogger = baseLogger;
    this.inheritanceRules = this.setupInheritanceRules();
    this.configurationTree = new Map();
  }
  
  setupInheritanceRules() {
    return {
      // What properties are inherited
      inheritableProperties: [
        'level',
        'formatters',
        'transports',
        'filters',
        'handlers',
        'metadata'
      ],
      
      // Inheritance behavior
      behavior: {
        level: 'inherit_if_not_specified',
        formatters: 'merge_with_parent',
        transports: 'merge_with_parent',
        filters: 'chain_with_parent',
        handlers: 'merge_with_parent',
        metadata: 'merge_with_parent'
      },
      
      // Override rules
      overrides: {
        allowChildOverride: true,
        allowRootOverride: false,
        requireExplicitOverride: ['level', 'transports']
      }
    };
  }
  
  createInheritedLogger(name, config = {}) {
    // Parse logger hierarchy
    const hierarchy = this.parseLoggerHierarchy(name);
    
    // Build inherited configuration
    const inheritedConfig = this.buildInheritedConfiguration(hierarchy, config);
    
    // Create logger with inherited configuration
    const logger = this.baseLogger.child({
      name,
      ...inheritedConfig
    });
    
    // Store in configuration tree
    this.configurationTree.set(name, {
      config: inheritedConfig,
      hierarchy,
      children: new Set(),
      parent: hierarchy.parent
    });
    
    // Update parent's children list
    if (hierarchy.parent) {
      const parentEntry = this.configurationTree.get(hierarchy.parent);
      if (parentEntry) {
        parentEntry.children.add(name);
      }
    }
    
    return logger;
  }
  
  buildInheritedConfiguration(hierarchy, config) {
    let inheritedConfig = { ...config };
    
    // Walk up the hierarchy and inherit configurations
    hierarchy.ancestors.forEach(ancestorName => {
      const ancestorConfig = this.configurationTree.get(ancestorName);
      if (ancestorConfig) {
        inheritedConfig = this.mergeConfigurations(
          ancestorConfig.config, 
          inheritedConfig
        );
      }
    });
    
    return inheritedConfig;
  }
  
  mergeConfigurations(parentConfig, childConfig) {
    const merged = { ...parentConfig };
    const rules = this.inheritanceRules.behavior;
    
    Object.keys(childConfig).forEach(key => {
      const rule = rules[key] || 'child_overrides';
      
      switch (rule) {
        case 'inherit_if_not_specified':
          if (childConfig[key] !== undefined) {
            merged[key] = childConfig[key];
          }
          break;
          
        case 'merge_with_parent':
          if (typeof parentConfig[key] === 'object' && typeof childConfig[key] === 'object') {
            merged[key] = { ...parentConfig[key], ...childConfig[key] };
          } else {
            merged[key] = childConfig[key];
          }
          break;
          
        case 'chain_with_parent':
          merged[key] = [
            ...(Array.isArray(parentConfig[key]) ? parentConfig[key] : [parentConfig[key]]),
            ...(Array.isArray(childConfig[key]) ? childConfig[key] : [childConfig[key]])
          ].filter(Boolean);
          break;
          
        default:
          merged[key] = childConfig[key];
      }
    });
    
    return merged;
  }
}
```

---

**Previous**: [2.2.2 Log Level](./2.2.2_Log_Level.md)  
**Next**: [2.2.4 Thread Information](./2.2.4_Thread_Information.md)
