# 2.2.5 Message Content

## Understanding Message Content in Logging

Message content is the core payload of log entries, containing the actual information being communicated. Well-structured message content ensures logs are readable, searchable, and actionable. This includes message formatting, interpolation, sanitization, and structured data handling.

## Message Formatting and Templates

### 1. **Template-Based Message Formatting**
Creating consistent and flexible message templates for various logging scenarios.

```javascript
// Advanced message template system
class MessageTemplateEngine {
  constructor(logger) {
    this.logger = logger.child({ component: 'MessageTemplateEngine' });
    this.templates = new Map();
    this.formatters = this.setupFormatters();
    this.validators = this.setupValidators();
    this.sanitizers = this.setupSanitizers();
  }
  
  setupFormatters() {
    return {
      // Basic interpolation formatter
      interpolate: (template, data) => {
        return template.replace(/\{([^}]+)\}/g, (match, key) => {
          const value = this.getNestedValue(data, key);
          return value !== undefined ? String(value) : match;
        });
      },
      
      // Structured template formatter
      structured: (template, data) => {
        const result = {
          message: this.formatters.interpolate(template.message, data),
          category: template.category,
          tags: template.tags || [],
          structured: {}
        };
        
        if (template.fields) {
          template.fields.forEach(field => {
            const value = this.getNestedValue(data, field.source);
            if (value !== undefined) {
              result.structured[field.name] = this.formatValue(value, field.type);
            }
          });
        }
        
        return result;
      },
      
      // JSON template formatter
      json: (template, data) => {
        const interpolated = this.formatters.interpolate(JSON.stringify(template), data);
        return JSON.parse(interpolated);
      },
      
      // Custom formatter with functions
      custom: (template, data, formatFunctions = {}) => {
        let result = template;
        
        // Apply custom formatting functions
        Object.entries(formatFunctions).forEach(([name, func]) => {
          const regex = new RegExp(`\\{${name}:([^}]+)\\}`, 'g');
          result = result.replace(regex, (match, param) => {
            return func(this.getNestedValue(data, param), data);
          });
        });
        
        return this.formatters.interpolate(result, data);
      }
    };
  }
  
  setupValidators() {
    return {
      // Validate message template structure
      validateTemplate: (template) => {
        const errors = [];
        
        if (!template.id) {
          errors.push('Template must have an id');
        }
        
        if (!template.message) {
          errors.push('Template must have a message');
        }
        
        if (template.fields && !Array.isArray(template.fields)) {
          errors.push('Template fields must be an array');
        }
        
        // Validate interpolation syntax
        const interpolationRegex = /\{([^}]+)\}/g;
        const matches = template.message.match(interpolationRegex);
        
        if (matches) {
          matches.forEach(match => {
            const key = match.slice(1, -1);
            if (!this.isValidKeyPath(key)) {
              errors.push(`Invalid key path: ${key}`);
            }
          });
        }
        
        return {
          valid: errors.length === 0,
          errors
        };
      },
      
      // Validate message data against template
      validateData: (template, data) => {
        const errors = [];
        const warnings = [];
        
        if (template.required) {
          template.required.forEach(field => {
            if (this.getNestedValue(data, field) === undefined) {
              errors.push(`Required field missing: ${field}`);
            }
          });
        }
        
        if (template.fields) {
          template.fields.forEach(field => {
            const value = this.getNestedValue(data, field.source);
            if (value !== undefined) {
              const validation = this.validateFieldValue(value, field);
              if (!validation.valid) {
                warnings.push(`Field ${field.name}: ${validation.error}`);
              }
            }
          });
        }
        
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
    };
  }
  
  setupSanitizers() {
    return {
      // Remove sensitive information
      sanitizeSensitive: (data) => {
        const sanitized = JSON.parse(JSON.stringify(data));
        const sensitiveFields = [
          'password', 'passwd', 'pwd',
          'token', 'accessToken', 'refreshToken',
          'apiKey', 'api_key', 'secret',
          'privateKey', 'private_key',
          'credentials', 'auth', 'authorization',
          'ssn', 'social_security_number',
          'creditCard', 'credit_card', 'ccn',
          'email', 'phone', 'phoneNumber'
        ];
        
        return this.deepSanitize(sanitized, sensitiveFields);
      },
      
      // Truncate long values
      truncateValues: (data, maxLength = 1000) => {
        return this.deepMap(data, (value) => {
          if (typeof value === 'string' && value.length > maxLength) {
            return value.substring(0, maxLength) + '...[truncated]';
          }
          return value;
        });
      },
      
      // Remove null/undefined values
      removeEmpty: (data) => {
        return this.deepMap(data, (value, key, parent) => {
          if (value === null || value === undefined || value === '') {
            delete parent[key];
            return undefined;
          }
          return value;
        });
      },
      
      // Escape special characters
      escapeSpecial: (data) => {
        return this.deepMap(data, (value) => {
          if (typeof value === 'string') {
            return value
              .replace(/\\/g, '\\\\')
              .replace(/"/g, '\\"')
              .replace(/\n/g, '\\n')
              .replace(/\r/g, '\\r')
              .replace(/\t/g, '\\t');
          }
          return value;
        });
      }
    };
  }
  
  registerTemplate(template) {
    const validation = this.validators.validateTemplate(template);
    
    if (!validation.valid) {
      throw new Error(`Invalid template: ${validation.errors.join(', ')}`);
    }
    
    this.templates.set(template.id, {
      ...template,
      createdAt: new Date().toISOString(),
      usageCount: 0
    });
    
    this.logger.debug('Message template registered', {
      templateId: template.id,
      category: template.category,
      fieldCount: template.fields ? template.fields.length : 0
    });
  }
  
  formatMessage(templateId, data, options = {}) {
    const template = this.templates.get(templateId);
    
    if (!template) {
      throw new Error(`Template not found: ${templateId}`);
    }
    
    // Increment usage counter
    template.usageCount++;
    
    // Validate data
    const dataValidation = this.validators.validateData(template, data);
    if (!dataValidation.valid && !options.ignoreValidation) {
      throw new Error(`Data validation failed: ${dataValidation.errors.join(', ')}`);
    }
    
    // Sanitize data if requested
    let processedData = data;
    if (options.sanitize !== false) {
      processedData = this.sanitizers.sanitizeSensitive(processedData);
    }
    
    if (options.truncate) {
      processedData = this.sanitizers.truncateValues(processedData, options.maxLength);
    }
    
    if (options.removeEmpty) {
      processedData = this.sanitizers.removeEmpty(processedData);
    }
    
    // Format message using appropriate formatter
    const formatter = options.formatter || 'interpolate';
    const formattedMessage = this.formatters[formatter](template, processedData, options.formatFunctions);
    
    const result = {
      formattedMessage,
      templateId,
      templateCategory: template.category,
      templateTags: template.tags || [],
      originalData: data,
      processedData,
      validation: dataValidation,
      timestamp: new Date().toISOString(),
      usageCount: template.usageCount
    };
    
    this.logger.trace('Message formatted', {
      templateId,
      hasWarnings: dataValidation.warnings.length > 0,
      dataSize: JSON.stringify(data).length,
      formattedSize: JSON.stringify(formattedMessage).length
    });
    
    return result;
  }
  
  logWithTemplate(level, templateId, data, options = {}) {
    try {
      const formatted = this.formatMessage(templateId, data, options);
      
      const logEntry = {
        message: typeof formatted.formattedMessage === 'string' ? 
          formatted.formattedMessage : 
          formatted.formattedMessage.message,
        
        template: {
          id: templateId,
          category: formatted.templateCategory,
          tags: formatted.templateTags,
          usageCount: formatted.usageCount
        },
        
        structured: typeof formatted.formattedMessage === 'object' ? 
          formatted.formattedMessage.structured : 
          undefined,
        
        originalData: formatted.originalData,
        processedData: formatted.processedData,
        
        validation: {
          valid: formatted.validation.valid,
          warnings: formatted.validation.warnings
        },
        
        formatting: {
          formatter: options.formatter || 'interpolate',
          sanitized: options.sanitize !== false,
          truncated: !!options.truncate
        },
        
        timestamp: formatted.timestamp,
        level: level.toUpperCase()
      };
      
      this.logger[level](logEntry.message, logEntry);
      return logEntry;
      
    } catch (error) {
      this.logger.error('Failed to format message with template', {
        templateId,
        error: {
          message: error.message,
          stack: error.stack
        },
        data
      });
      
      // Fallback to simple message
      const fallbackMessage = `Template formatting failed: ${error.message}`;
      this.logger[level](fallbackMessage, { templateId, originalData: data });
      
      return {
        message: fallbackMessage,
        templateId,
        originalData: data,
        error: error.message,
        fallback: true
      };
    }
  }
  
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }
  
  formatValue(value, type) {
    switch (type) {
      case 'string':
        return String(value);
      case 'number':
        return Number(value);
      case 'boolean':
        return Boolean(value);
      case 'date':
        return new Date(value).toISOString();
      case 'json':
        return JSON.stringify(value);
      default:
        return value;
    }
  }
  
  isValidKeyPath(keyPath) {
    return /^[a-zA-Z_][a-zA-Z0-9_.]*$/.test(keyPath);
  }
  
  validateFieldValue(value, field) {
    if (field.type === 'string' && typeof value !== 'string') {
      return { valid: false, error: 'Expected string value' };
    }
    
    if (field.type === 'number' && typeof value !== 'number') {
      return { valid: false, error: 'Expected number value' };
    }
    
    if (field.min !== undefined && value < field.min) {
      return { valid: false, error: `Value below minimum: ${field.min}` };
    }
    
    if (field.max !== undefined && value > field.max) {
      return { valid: false, error: `Value above maximum: ${field.max}` };
    }
    
    return { valid: true };
  }
  
  deepSanitize(obj, sensitiveFields) {
    if (typeof obj !== 'object' || obj === null) {
      return obj;
    }
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.deepSanitize(item, sensitiveFields));
    }
    
    const result = {};
    Object.keys(obj).forEach(key => {
      const lowerKey = key.toLowerCase();
      if (sensitiveFields.some(field => lowerKey.includes(field.toLowerCase()))) {
        result[key] = '[REDACTED]';
      } else if (typeof obj[key] === 'object') {
        result[key] = this.deepSanitize(obj[key], sensitiveFields);
      } else {
        result[key] = obj[key];
      }
    });
    
    return result;
  }
  
  deepMap(obj, transformer) {
    if (typeof obj !== 'object' || obj === null) {
      return transformer(obj);
    }
    
    if (Array.isArray(obj)) {
      return obj.map(item => this.deepMap(item, transformer));
    }
    
    const result = {};
    Object.keys(obj).forEach(key => {
      const transformedValue = transformer(obj[key], key, result);
      if (transformedValue !== undefined) {
        if (typeof transformedValue === 'object') {
          result[key] = this.deepMap(transformedValue, transformer);
        } else {
          result[key] = transformedValue;
        }
      }
    });
    
    return result;
  }
  
  getTemplateStatistics() {
    const stats = {
      totalTemplates: this.templates.size,
      totalUsage: 0,
      mostUsedTemplate: null,
      templatesByCategory: {},
      averageUsage: 0
    };
    
    this.templates.forEach((template, id) => {
      stats.totalUsage += template.usageCount;
      
      if (!stats.mostUsedTemplate || template.usageCount > stats.mostUsedTemplate.usageCount) {
        stats.mostUsedTemplate = { id, usageCount: template.usageCount };
      }
      
      const category = template.category || 'uncategorized';
      stats.templatesByCategory[category] = (stats.templatesByCategory[category] || 0) + 1;
    });
    
    stats.averageUsage = stats.totalTemplates > 0 ? stats.totalUsage / stats.totalTemplates : 0;
    
    return stats;
  }
}
```

### 2. **Structured Message Content**
Creating and managing structured message content for better searchability and analysis.

```javascript
// Structured message content manager
class StructuredMessageManager {
  constructor(logger) {
    this.logger = logger.child({ component: 'StructuredMessageManager' });
    this.schemas = new Map();
    this.messageTypes = this.setupMessageTypes();
    this.contentProcessors = this.setupContentProcessors();
  }
  
  setupMessageTypes() {
    return {
      // Application events
      APPLICATION_EVENT: {
        schema: 'application_event',
        requiredFields: ['eventType', 'timestamp'],
        optionalFields: ['userId', 'sessionId', 'metadata']
      },
      
      // Error messages
      ERROR_EVENT: {
        schema: 'error_event',
        requiredFields: ['errorType', 'message', 'timestamp'],
        optionalFields: ['stack', 'context', 'userAction', 'severity']
      },
      
      // Performance metrics
      PERFORMANCE_METRIC: {
        schema: 'performance_metric',
        requiredFields: ['metricName', 'value', 'timestamp'],
        optionalFields: ['tags', 'dimensions', 'unit']
      },
      
      // Security events
      SECURITY_EVENT: {
        schema: 'security_event',
        requiredFields: ['securityEventType', 'timestamp', 'source'],
        optionalFields: ['userId', 'ip', 'userAgent', 'details']
      },
      
      // Business events
      BUSINESS_EVENT: {
        schema: 'business_event',
        requiredFields: ['businessEventType', 'timestamp'],
        optionalFields: ['entityId', 'entityType', 'previousState', 'newState']
      },
      
      // API requests
      API_REQUEST: {
        schema: 'api_request',
        requiredFields: ['method', 'url', 'timestamp'],
        optionalFields: ['statusCode', 'duration', 'userId', 'requestId']
      }
    };
  }
  
  setupContentProcessors() {
    return {
      // Process error content
      processError: (error, context = {}) => {
        return {
          type: 'ERROR_EVENT',
          errorType: error.name || 'Error',
          message: error.message,
          stack: error.stack,
          code: error.code,
          
          context: {
            ...context,
            timestamp: new Date().toISOString(),
            nodeVersion: process.version,
            platform: process.platform,
            memory: process.memoryUsage(),
            uptime: process.uptime()
          },
          
          classification: {
            severity: this.classifyErrorSeverity(error),
            category: this.categorizeError(error),
            isRetryable: this.isRetryableError(error),
            requiresAlert: this.requiresAlert(error)
          },
          
          fingerprint: this.generateErrorFingerprint(error),
          
          troubleshooting: {
            commonCauses: this.getCommonCauses(error),
            suggestedActions: this.getSuggestedActions(error),
            relatedDocs: this.getRelatedDocumentation(error)
          }
        };
      },
      
      // Process performance metrics
      processPerformance: (metricName, value, metadata = {}) => {
        return {
          type: 'PERFORMANCE_METRIC',
          metricName,
          value,
          
          measurement: {
            timestamp: new Date().toISOString(),
            unit: metadata.unit || 'count',
            precision: metadata.precision || 2,
            aggregationType: metadata.aggregationType || 'gauge'
          },
          
          tags: {
            environment: process.env.NODE_ENV || 'development',
            version: process.env.APP_VERSION,
            instance: process.env.INSTANCE_ID,
            ...metadata.tags
          },
          
          dimensions: {
            process: {
              pid: process.pid,
              memory: process.memoryUsage(),
              cpu: process.cpuUsage()
            },
            ...metadata.dimensions
          },
          
          threshold: {
            warning: metadata.warningThreshold,
            critical: metadata.criticalThreshold,
            status: this.evaluateThresholdStatus(value, metadata)
          },
          
          trend: {
            direction: metadata.trendDirection,
            significance: metadata.trendSignificance,
            period: metadata.trendPeriod
          }
        };
      },
      
      // Process API request content
      processApiRequest: (request, response, metadata = {}) => {
        return {
          type: 'API_REQUEST',
          
          request: {
            method: request.method,
            url: request.url,
            path: request.path,
            query: request.query,
            headers: this.sanitizeHeaders(request.headers),
            userAgent: request.get('User-Agent'),
            ip: request.ip || request.connection.remoteAddress,
            contentLength: request.get('Content-Length')
          },
          
          response: {
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            headers: this.sanitizeHeaders(response.getHeaders()),
            contentLength: response.get('Content-Length'),
            duration: metadata.duration
          },
          
          authentication: {
            userId: request.user?.id,
            userRole: request.user?.role,
            sessionId: request.sessionID,
            tokenType: request.authInfo?.type,
            scopes: request.authInfo?.scopes
          },
          
          context: {
            requestId: request.id || metadata.requestId,
            correlationId: request.correlationId,
            traceId: request.traceId,
            timestamp: new Date().toISOString(),
            route: request.route?.path,
            controller: metadata.controller,
            action: metadata.action
          },
          
          performance: {
            duration: metadata.duration,
            dbQueries: metadata.dbQueries,
            cacheHits: metadata.cacheHits,
            externalCalls: metadata.externalCalls
          },
          
          security: {
            rateLimited: metadata.rateLimited,
            blocked: metadata.blocked,
            suspicious: metadata.suspicious,
            geoLocation: metadata.geoLocation
          }
        };
      },
      
      // Process business events
      processBusinessEvent: (eventType, entity, changes, metadata = {}) => {
        return {
          type: 'BUSINESS_EVENT',
          businessEventType: eventType,
          
          entity: {
            id: entity.id,
            type: entity.type || entity.constructor.name,
            version: entity.version,
            status: entity.status
          },
          
          changes: {
            previousState: changes.previousState,
            newState: changes.newState,
            diff: this.calculateStateDiff(changes.previousState, changes.newState),
            changeType: this.classifyChangeType(changes)
          },
          
          context: {
            timestamp: new Date().toISOString(),
            triggeredBy: {
              userId: metadata.userId,
              userRole: metadata.userRole,
              system: metadata.system,
              automated: metadata.automated
            },
            
            request: {
              requestId: metadata.requestId,
              sessionId: metadata.sessionId,
              ip: metadata.ip
            },
            
            workflow: {
              workflowId: metadata.workflowId,
              stepId: metadata.stepId,
              previousStep: metadata.previousStep,
              nextStep: metadata.nextStep
            }
          },
          
          impact: {
            scope: this.assessImpactScope(eventType, entity),
            severity: this.assessImpactSeverity(eventType, changes),
            affectedEntities: metadata.affectedEntities,
            cascadingEffects: metadata.cascadingEffects
          },
          
          compliance: {
            auditRequired: this.requiresAudit(eventType, entity),
            retentionPeriod: this.getRetentionPeriod(eventType),
            privacyLevel: this.getPrivacyLevel(entity, changes),
            regulations: this.getApplicableRegulations(eventType, entity)
          }
        };
      },
      
      // Process security events
      processSecurityEvent: (eventType, source, details = {}) => {
        return {
          type: 'SECURITY_EVENT',
          securityEventType: eventType,
          
          source: {
            type: source.type, // 'user', 'system', 'api', 'external'
            ip: source.ip,
            userAgent: source.userAgent,
            userId: source.userId,
            sessionId: source.sessionId,
            location: source.location
          },
          
          event: {
            timestamp: new Date().toISOString(),
            severity: this.classifySecuritySeverity(eventType),
            category: this.categorizeSecurityEvent(eventType),
            subcategory: details.subcategory,
            description: details.description
          },
          
          context: {
            resource: details.resource,
            action: details.action,
            outcome: details.outcome, // 'success', 'failure', 'blocked'
            reason: details.reason,
            method: details.method
          },
          
          detection: {
            detectedBy: details.detectedBy, // 'automatic', 'manual', 'external'
            confidence: details.confidence,
            ruleId: details.ruleId,
            signatureId: details.signatureId
          },
          
          response: {
            automated: details.automatedResponse,
            actions: details.responseActions,
            escalated: details.escalated,
            blocked: details.blocked,
            notified: details.notified
          },
          
          risk: {
            level: this.assessRiskLevel(eventType, source, details),
            factors: this.identifyRiskFactors(eventType, source, details),
            mitigation: this.suggestMitigation(eventType, details)
          }
        };
      }
    };
  }
  
  registerSchema(schemaId, schema) {
    this.schemas.set(schemaId, {
      ...schema,
      registeredAt: new Date().toISOString(),
      version: schema.version || '1.0.0'
    });
    
    this.logger.debug('Message schema registered', {
      schemaId,
      version: schema.version,
      fieldCount: Object.keys(schema.properties || {}).length
    });
  }
  
  createStructuredMessage(messageType, data, options = {}) {
    const messageConfig = this.messageTypes[messageType];
    
    if (!messageConfig) {
      throw new Error(`Unknown message type: ${messageType}`);
    }
    
    // Validate required fields
    const missingFields = messageConfig.requiredFields.filter(
      field => data[field] === undefined
    );
    
    if (missingFields.length > 0) {
      throw new Error(`Missing required fields: ${missingFields.join(', ')}`);
    }
    
    // Process content based on message type
    let processedContent;
    switch (messageType) {
      case 'ERROR_EVENT':
        processedContent = this.contentProcessors.processError(data.error || data, data.context);
        break;
      case 'PERFORMANCE_METRIC':
        processedContent = this.contentProcessors.processPerformance(data.metricName, data.value, data);
        break;
      case 'API_REQUEST':
        processedContent = this.contentProcessors.processApiRequest(data.request, data.response, data);
        break;
      case 'BUSINESS_EVENT':
        processedContent = this.contentProcessors.processBusinessEvent(data.eventType, data.entity, data.changes, data);
        break;
      case 'SECURITY_EVENT':
        processedContent = this.contentProcessors.processSecurityEvent(data.eventType, data.source, data.details);
        break;
      default:
        processedContent = { ...data, type: messageType };
    }
    
    // Add metadata
    const structuredMessage = {
      ...processedContent,
      
      metadata: {
        messageId: this.generateMessageId(),
        messageType,
        schemaVersion: messageConfig.schemaVersion || '1.0.0',
        createdAt: new Date().toISOString(),
        source: options.source || 'application',
        environment: process.env.NODE_ENV || 'development',
        service: options.service || process.env.SERVICE_NAME,
        version: options.version || process.env.APP_VERSION
      },
      
      processing: {
        processingTime: Date.now(),
        validationPassed: true,
        sanitized: options.sanitize !== false,
        compressed: options.compress || false
      }
    };
    
    // Validate against schema if available
    if (messageConfig.schema && this.schemas.has(messageConfig.schema)) {
      const validation = this.validateAgainstSchema(structuredMessage, messageConfig.schema);
      structuredMessage.processing.validationPassed = validation.valid;
      structuredMessage.processing.validationErrors = validation.errors;
    }
    
    return structuredMessage;
  }
  
  logStructuredMessage(level, messageType, data, options = {}) {
    try {
      const structuredMessage = this.createStructuredMessage(messageType, data, options);
      
      // Extract human-readable message
      const humanMessage = this.extractHumanMessage(structuredMessage);
      
      const logEntry = {
        message: humanMessage,
        structured: structuredMessage,
        messageType,
        timestamp: new Date().toISOString(),
        level: level.toUpperCase()
      };
      
      this.logger[level](humanMessage, logEntry);
      return logEntry;
      
    } catch (error) {
      this.logger.error('Failed to create structured message', {
        messageType,
        error: {
          message: error.message,
          stack: error.stack
        },
        originalData: data
      });
      
      // Fallback to simple logging
      const fallbackMessage = `Structured message creation failed: ${error.message}`;
      this.logger[level](fallbackMessage, { messageType, originalData: data });
      
      return {
        message: fallbackMessage,
        messageType,
        originalData: data,
        error: error.message,
        fallback: true
      };
    }
  }
  
  extractHumanMessage(structuredMessage) {
    switch (structuredMessage.type) {
      case 'ERROR_EVENT':
        return `${structuredMessage.errorType}: ${structuredMessage.message}`;
      
      case 'PERFORMANCE_METRIC':
        return `Performance metric ${structuredMessage.metricName}: ${structuredMessage.value} ${structuredMessage.measurement.unit}`;
      
      case 'API_REQUEST':
        return `${structuredMessage.request.method} ${structuredMessage.request.url} - ${structuredMessage.response.statusCode} (${structuredMessage.performance.duration}ms)`;
      
      case 'BUSINESS_EVENT':
        return `Business event: ${structuredMessage.businessEventType} for ${structuredMessage.entity.type} ${structuredMessage.entity.id}`;
      
      case 'SECURITY_EVENT':
        return `Security event: ${structuredMessage.securityEventType} from ${structuredMessage.source.type} (${structuredMessage.event.severity})`;
      
      default:
        return structuredMessage.message || `${structuredMessage.type} event`;
    }
  }
  
  validateAgainstSchema(message, schemaId) {
    const schema = this.schemas.get(schemaId);
    if (!schema) {
      return { valid: false, errors: [`Schema not found: ${schemaId}`] };
    }
    
    // Simplified validation - in practice, use a proper JSON schema validator
    const errors = [];
    
    if (schema.required) {
      schema.required.forEach(field => {
        if (this.getNestedValue(message, field) === undefined) {
          errors.push(`Required field missing: ${field}`);
        }
      });
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
  
  // Utility methods for content processing
  classifyErrorSeverity(error) {
    if (error.name === 'ValidationError') return 'low';
    if (error.name === 'NotFoundError') return 'low';
    if (error.name === 'UnauthorizedError') return 'medium';
    if (error.name === 'DatabaseError') return 'high';
    if (error.name === 'SystemError') return 'critical';
    return 'medium';
  }
  
  categorizeError(error) {
    if (error.name.includes('Database') || error.code === 'ECONNREFUSED') return 'database';
    if (error.name.includes('Network') || error.code === 'ENOTFOUND') return 'network';
    if (error.name.includes('Auth') || error.name.includes('Permission')) return 'security';
    if (error.name.includes('Validation')) return 'validation';
    return 'application';
  }
  
  isRetryableError(error) {
    const retryableCodes = ['ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED'];
    const retryableNames = ['NetworkError', 'TimeoutError', 'ServiceUnavailableError'];
    
    return retryableCodes.includes(error.code) || 
           retryableNames.some(name => error.name.includes(name));
  }
  
  requiresAlert(error) {
    const alertSeverities = ['high', 'critical'];
    return alertSeverities.includes(this.classifyErrorSeverity(error));
  }
  
  generateErrorFingerprint(error) {
    const content = `${error.name}:${error.message}:${error.stack?.split('\n')[0]}`;
    return require('crypto').createHash('md5').update(content).digest('hex');
  }
  
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }
  
  sanitizeHeaders(headers) {
    const sanitized = { ...headers };
    const sensitiveHeaders = ['authorization', 'cookie', 'x-api-key', 'x-auth-token'];
    
    sensitiveHeaders.forEach(header => {
      if (sanitized[header]) {
        sanitized[header] = '[REDACTED]';
      }
    });
    
    return sanitized;
  }
  
  calculateStateDiff(previous, current) {
    // Simplified diff calculation
    const diff = {};
    
    Object.keys({ ...previous, ...current }).forEach(key => {
      if (previous[key] !== current[key]) {
        diff[key] = {
          from: previous[key],
          to: current[key]
        };
      }
    });
    
    return diff;
  }
  
  // Additional classification methods would be implemented here
  classifyChangeType(changes) { return 'update'; }
  assessImpactScope(eventType, entity) { return 'local'; }
  assessImpactSeverity(eventType, changes) { return 'medium'; }
  requiresAudit(eventType, entity) { return true; }
  getRetentionPeriod(eventType) { return '7 years'; }
  getPrivacyLevel(entity, changes) { return 'internal'; }
  getApplicableRegulations(eventType, entity) { return ['GDPR']; }
  classifySecuritySeverity(eventType) { return 'medium'; }
  categorizeSecurityEvent(eventType) { return 'access'; }
  assessRiskLevel(eventType, source, details) { return 'medium'; }
  identifyRiskFactors(eventType, source, details) { return []; }
  suggestMitigation(eventType, details) { return []; }
  evaluateThresholdStatus(value, metadata) { return 'normal'; }
  getCommonCauses(error) { return []; }
  getSuggestedActions(error) { return []; }
  getRelatedDocumentation(error) { return []; }
}
```

## Message Interpolation and Parameters

### 1. **Advanced Parameter Interpolation**
```javascript
// Advanced parameter interpolation system
class ParameterInterpolationEngine {
  constructor(logger) {
    this.logger = logger.child({ component: 'ParameterInterpolationEngine' });
    this.interpolators = this.setupInterpolators();
    this.formatters = this.setupParameterFormatters();
    this.validators = this.setupParameterValidators();
  }
  
  setupInterpolators() {
    return {
      // Basic placeholder interpolation: {key}
      basic: (template, params) => {
        return template.replace(/\{([^}]+)\}/g, (match, key) => {
          const value = this.getParameterValue(params, key);
          return value !== undefined ? String(value) : match;
        });
      },
      
      // Formatted interpolation: {key:format}
      formatted: (template, params) => {
        return template.replace(/\{([^:}]+):([^}]+)\}/g, (match, key, format) => {
          const value = this.getParameterValue(params, key);
          if (value === undefined) return match;
          
          return this.formatValue(value, format);
        });
      },
      
      // Conditional interpolation: {key?true_value:false_value}
      conditional: (template, params) => {
        return template.replace(/\{([^?}]+)\?([^:}]*):([^}]*)\}/g, (match, key, trueValue, falseValue) => {
          const value = this.getParameterValue(params, key);
          const condition = this.evaluateCondition(value);
          
          return condition ? 
            this.interpolators.basic(trueValue, params) : 
            this.interpolators.basic(falseValue, params);
        });
      },
      
      // Function-based interpolation: {func(key)}
      functional: (template, params, functions = {}) => {
        return template.replace(/\{([a-zA-Z_][a-zA-Z0-9_]*)\(([^)]*)\)\}/g, (match, funcName, args) => {
          if (!functions[funcName]) return match;
          
          const parsedArgs = this.parseArguments(args, params);
          return functions[funcName](...parsedArgs);
        });
      },
      
      // Array interpolation: {array[index]} or {array[*]}
      array: (template, params) => {
        // Array index access
        template = template.replace(/\{([^[\]]+)\[(\d+)\]\}/g, (match, key, index) => {
          const array = this.getParameterValue(params, key);
          if (!Array.isArray(array)) return match;
          
          const idx = parseInt(index);
          return idx < array.length ? String(array[idx]) : match;
        });
        
        // Array join
        template = template.replace(/\{([^[\]]+)\[\*\](?::([^}]+))?\}/g, (match, key, separator) => {
          const array = this.getParameterValue(params, key);
          if (!Array.isArray(array)) return match;
          
          return array.join(separator || ', ');
        });
        
        return template;
      },
      
      // Object property access: {obj.prop} or {obj['prop']}
      object: (template, params) => {
        return template.replace(/\{([^.}]+)\.([^}]+)\}/g, (match, objKey, propPath) => {
          const obj = this.getParameterValue(params, objKey);
          if (typeof obj !== 'object' || obj === null) return match;
          
          const value = this.getNestedProperty(obj, propPath);
          return value !== undefined ? String(value) : match;
        });
      }
    };
  }
  
  setupParameterFormatters() {
    return {
      // Date formatting
      date: (value, format = 'iso') => {
        const date = new Date(value);
        if (isNaN(date.getTime())) return String(value);
        
        switch (format.toLowerCase()) {
          case 'iso':
            return date.toISOString();
          case 'local':
            return date.toLocaleString();
          case 'date':
            return date.toDateString();
          case 'time':
            return date.toTimeString();
          case 'unix':
            return Math.floor(date.getTime() / 1000).toString();
          default:
            return this.formatDateCustom(date, format);
        }
      },
      
      // Number formatting
      number: (value, format = 'default') => {
        const num = Number(value);
        if (isNaN(num)) return String(value);
        
        switch (format.toLowerCase()) {
          case 'fixed':
            return num.toFixed(2);
          case 'exponential':
            return num.toExponential();
          case 'precision':
            return num.toPrecision(3);
          case 'percent':
            return `${(num * 100).toFixed(2)}%`;
          case 'currency':
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(num);
          case 'bytes':
            return this.formatBytes(num);
          default:
            return num.toString();
        }
      },
      
      // String formatting
      string: (value, format = 'default') => {
        const str = String(value);
        
        switch (format.toLowerCase()) {
          case 'upper':
            return str.toUpperCase();
          case 'lower':
            return str.toLowerCase();
          case 'title':
            return str.replace(/\w\S*/g, txt => 
              txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
          case 'truncate':
            return str.length > 50 ? str.substring(0, 47) + '...' : str;
          case 'escape':
            return str.replace(/[&<>"']/g, char => ({
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#39;'
            })[char]);
          default:
            return str;
        }
      },
      
      // JSON formatting
      json: (value, format = 'compact') => {
        try {
          switch (format.toLowerCase()) {
            case 'pretty':
              return JSON.stringify(value, null, 2);
            case 'compact':
              return JSON.stringify(value);
            case 'keys':
              return JSON.stringify(Object.keys(value || {}));
            case 'values':
              return JSON.stringify(Object.values(value || {}));
            default:
              return JSON.stringify(value);
          }
        } catch (error) {
          return String(value);
        }
      },
      
      // Duration formatting
      duration: (value, format = 'ms') => {
        const ms = Number(value);
        if (isNaN(ms)) return String(value);
        
        switch (format.toLowerCase()) {
          case 'ms':
            return `${ms}ms`;
          case 'seconds':
            return `${(ms / 1000).toFixed(2)}s`;
          case 'human':
            return this.formatDurationHuman(ms);
          case 'iso':
            return this.formatDurationISO(ms);
          default:
            return `${ms}ms`;
        }
      }
    };
  }
  
  setupParameterValidators() {
    return {
      required: (params, requiredKeys) => {
        const missing = requiredKeys.filter(key => this.getParameterValue(params, key) === undefined);
        return {
          valid: missing.length === 0,
          missing
        };
      },
      
      types: (params, typeMap) => {
        const errors = [];
        
        Object.entries(typeMap).forEach(([key, expectedType]) => {
          const value = this.getParameterValue(params, key);
          if (value !== undefined && typeof value !== expectedType) {
            errors.push(`${key} expected ${expectedType}, got ${typeof value}`);
          }
        });
        
        return {
          valid: errors.length === 0,
          errors
        };
      },
      
      ranges: (params, rangeMap) => {
        const errors = [];
        
        Object.entries(rangeMap).forEach(([key, range]) => {
          const value = this.getParameterValue(params, key);
          if (typeof value === 'number') {
            if (range.min !== undefined && value < range.min) {
              errors.push(`${key} below minimum: ${range.min}`);
            }
            if (range.max !== undefined && value > range.max) {
              errors.push(`${key} above maximum: ${range.max}`);
            }
          }
        });
        
        return {
          valid: errors.length === 0,
          errors
        };
      }
    };
  }
  
  interpolate(template, params, options = {}) {
    let result = template;
    
    // Apply interpolators in sequence
    const interpolatorOrder = options.interpolators || [
      'object', 'array', 'conditional', 'formatted', 'basic'
    ];
    
    interpolatorOrder.forEach(name => {
      if (this.interpolators[name]) {
        result = this.interpolators[name](result, params, options.functions);
      }
    });
    
    // Apply functional interpolation if functions provided
    if (options.functions) {
      result = this.interpolators.functional(result, params, options.functions);
    }
    
    return result;
  }
  
  logWithInterpolation(level, template, params, options = {}) {
    try {
      // Validate parameters if validation rules provided
      if (options.validation) {
        const validation = this.validateParameters(params, options.validation);
        if (!validation.valid) {
          throw new Error(`Parameter validation failed: ${validation.errors.join(', ')}`);
        }
      }
      
      // Sanitize parameters
      const sanitizedParams = options.sanitize !== false ? 
        this.sanitizeParameters(params) : params;
      
      // Perform interpolation
      const interpolatedMessage = this.interpolate(template, sanitizedParams, options);
      
      const logEntry = {
        message: interpolatedMessage,
        template,
        parameters: sanitizedParams,
        interpolation: {
          success: true,
          interpolators: options.interpolators || ['default'],
          sanitized: options.sanitize !== false,
          validated: !!options.validation
        },
        timestamp: new Date().toISOString(),
        level: level.toUpperCase()
      };
      
      this.logger[level](interpolatedMessage, logEntry);
      return logEntry;
      
    } catch (error) {
      this.logger.error('Parameter interpolation failed', {
        template,
        parameters: params,
        error: {
          message: error.message,
          stack: error.stack
        }
      });
      
      // Fallback to template
      this.logger[level](template, { 
        template, 
        parameters: params, 
        interpolationError: error.message 
      });
      
      return {
        message: template,
        template,
        parameters: params,
        interpolation: {
          success: false,
          error: error.message
        },
        fallback: true
      };
    }
  }
  
  validateParameters(params, validationRules) {
    const results = {
      valid: true,
      errors: []
    };
    
    if (validationRules.required) {
      const requiredValidation = this.validators.required(params, validationRules.required);
      if (!requiredValidation.valid) {
        results.valid = false;
        results.errors.push(`Missing required parameters: ${requiredValidation.missing.join(', ')}`);
      }
    }
    
    if (validationRules.types) {
      const typeValidation = this.validators.types(params, validationRules.types);
      if (!typeValidation.valid) {
        results.valid = false;
        results.errors.push(...typeValidation.errors);
      }
    }
    
    if (validationRules.ranges) {
      const rangeValidation = this.validators.ranges(params, validationRules.ranges);
      if (!rangeValidation.valid) {
        results.valid = false;
        results.errors.push(...rangeValidation.errors);
      }
    }
    
    return results;
  }
  
  sanitizeParameters(params) {
    const sensitiveKeys = ['password', 'token', 'apiKey', 'secret', 'credentials'];
    
    const sanitize = (obj) => {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
      
      if (Array.isArray(obj)) {
        return obj.map(sanitize);
      }
      
      const sanitized = {};
      Object.keys(obj).forEach(key => {
        const lowerKey = key.toLowerCase();
        if (sensitiveKeys.some(sensitive => lowerKey.includes(sensitive))) {
          sanitized[key] = '[REDACTED]';
        } else if (typeof obj[key] === 'object') {
          sanitized[key] = sanitize(obj[key]);
        } else {
          sanitized[key] = obj[key];
        }
      });
      
      return sanitized;
    };
    
    return sanitize(params);
  }
  
  getParameterValue(params, key) {
    return key.split('.').reduce((obj, prop) => {
      return obj && obj[prop] !== undefined ? obj[prop] : undefined;
    }, params);
  }
  
  getNestedProperty(obj, path) {
    return path.split('.').reduce((current, prop) => {
      return current && current[prop] !== undefined ? current[prop] : undefined;
    }, obj);
  }
  
  formatValue(value, format) {
    const [type, subformat] = format.split(':');
    
    if (this.formatters[type]) {
      return this.formatters[type](value, subformat);
    }
    
    return String(value);
  }
  
  evaluateCondition(value) {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'number') return value !== 0;
    if (typeof value === 'string') return value.length > 0;
    if (Array.isArray(value)) return value.length > 0;
    if (typeof value === 'object') return value !== null;
    return !!value;
  }
  
  parseArguments(argsString, params) {
    if (!argsString.trim()) return [];
    
    return argsString.split(',').map(arg => {
      const trimmed = arg.trim();
      
      // String literal
      if ((trimmed.startsWith('"') && trimmed.endsWith('"')) ||
          (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
        return trimmed.slice(1, -1);
      }
      
      // Number literal
      if (/^\d+(\.\d+)?$/.test(trimmed)) {
        return Number(trimmed);
      }
      
      // Boolean literal
      if (trimmed === 'true') return true;
      if (trimmed === 'false') return false;
      
      // Parameter reference
      return this.getParameterValue(params, trimmed);
    });
  }
  
  formatDateCustom(date, format) {
    // Simplified custom date formatting
    return format
      .replace('YYYY', date.getFullYear())
      .replace('MM', String(date.getMonth() + 1).padStart(2, '0'))
      .replace('DD', String(date.getDate()).padStart(2, '0'))
      .replace('HH', String(date.getHours()).padStart(2, '0'))
      .replace('mm', String(date.getMinutes()).padStart(2, '0'))
      .replace('ss', String(date.getSeconds()).padStart(2, '0'));
  }
  
  formatBytes(bytes) {
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) return '0 Bytes';
    
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
  }
  
  formatDurationHuman(ms) {
    const units = [
      { name: 'day', ms: 86400000 },
      { name: 'hour', ms: 3600000 },
      { name: 'minute', ms: 60000 },
      { name: 'second', ms: 1000 }
    ];
    
    for (const unit of units) {
      if (ms >= unit.ms) {
        const value = Math.floor(ms / unit.ms);
        return `${value} ${unit.name}${value !== 1 ? 's' : ''}`;
      }
    }
    
    return `${ms}ms`;
  }
  
  formatDurationISO(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    
    return `PT${hours}H${minutes % 60}M${seconds % 60}S`;
  }
}
```

---

**Previous**: [2.2.4 Thread Information](./2.2.4_Thread_Information.md)  
**Next**: [2.2.6 Context Information](./2.2.6_Context_Information.md)
