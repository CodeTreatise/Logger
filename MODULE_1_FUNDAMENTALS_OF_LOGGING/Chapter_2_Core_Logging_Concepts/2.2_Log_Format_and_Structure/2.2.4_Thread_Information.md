# 2.2.4 Thread Information

## Understanding Thread Information in Logging

Thread information in logs provides crucial context for debugging concurrent applications, tracking request flows, and understanding system behavior. While Node.js is primarily single-threaded with an event loop, modern applications often use worker threads, child processes, and async operations that benefit from thread-like tracking mechanisms.

## Process and Thread Identification

### 1. **Process-Level Information**
Capturing essential process identification and state information.

```javascript
// Process-level information capture
class ProcessInformationLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'ProcessInformationLogger' });
    this.processInfo = this.captureProcessInformation();
    this.processMonitor = this.setupProcessMonitoring();
  }
  
  captureProcessInformation() {
    return {
      // Basic process identification
      pid: process.pid,
      ppid: process.ppid,
      uid: process.getuid ? process.getuid() : null,
      gid: process.getgid ? process.getgid() : null,
      
      // Process metadata
      title: process.title,
      execPath: process.execPath,
      execArgv: process.execArgv,
      argv: process.argv,
      version: process.version,
      versions: process.versions,
      
      // Platform information
      platform: process.platform,
      arch: process.arch,
      
      // Environment
      env: {
        nodeEnv: process.env.NODE_ENV,
        instanceId: process.env.INSTANCE_ID || `${require('os').hostname()}-${process.pid}`,
        deploymentId: process.env.DEPLOYMENT_ID,
        region: process.env.AWS_REGION || process.env.REGION,
        cluster: process.env.CLUSTER_NAME
      },
      
      // Resource information
      cwd: process.cwd(),
      umask: process.umask ? process.umask() : null,
      
      // Startup information
      startTime: process.env.PROCESS_START_TIME || new Date().toISOString(),
      uptime: process.uptime(),
      
      // Memory and CPU usage
      memoryUsage: process.memoryUsage(),
      cpuUsage: process.cpuUsage(),
      
      // Event loop information
      activeHandles: process._getActiveHandles().length,
      activeRequests: process._getActiveRequests().length
    };
  }
  
  setupProcessMonitoring() {
    return {
      // Monitor process events
      monitorProcessEvents: () => {
        // Exit events
        process.on('exit', (code) => {
          this.logProcessEvent('exit', { exitCode: code });
        });
        
        process.on('beforeExit', (code) => {
          this.logProcessEvent('beforeExit', { exitCode: code });
        });
        
        // Signal events
        ['SIGTERM', 'SIGINT', 'SIGUSR1', 'SIGUSR2'].forEach(signal => {
          process.on(signal, () => {
            this.logProcessEvent('signal', { signal });
          });
        });
        
        // Warning events
        process.on('warning', (warning) => {
          this.logProcessEvent('warning', {
            name: warning.name,
            message: warning.message,
            stack: warning.stack
          });
        });
        
        // Uncaught exception
        process.on('uncaughtException', (error) => {
          this.logProcessEvent('uncaughtException', {
            error: {
              message: error.message,
              stack: error.stack,
              name: error.name
            }
          });
        });
        
        // Unhandled rejection
        process.on('unhandledRejection', (reason, promise) => {
          this.logProcessEvent('unhandledRejection', {
            reason: reason instanceof Error ? {
              message: reason.message,
              stack: reason.stack,
              name: reason.name
            } : reason,
            promise: promise.toString()
          });
        });
      },
      
      // Periodic health monitoring
      startHealthMonitoring: (interval = 60000) => {
        setInterval(() => {
          this.logProcessHealth();
        }, interval);
      },
      
      // Resource usage monitoring
      startResourceMonitoring: (interval = 30000) => {
        setInterval(() => {
          this.logResourceUsage();
        }, interval);
      }
    };
  }
  
  logWithProcessInfo(level, message, data = {}) {
    const currentProcessInfo = {
      // Dynamic process information
      pid: process.pid,
      uptime: process.uptime(),
      memoryUsage: process.memoryUsage(),
      cpuUsage: process.cpuUsage(),
      
      // Event loop state
      eventLoop: {
        activeHandles: process._getActiveHandles().length,
        activeRequests: process._getActiveRequests().length,
        lag: this.measureEventLoopLag()
      },
      
      // Resource utilization
      resources: {
        maxRSS: process.resourceUsage ? process.resourceUsage().maxRSS : null,
        userCPUTime: process.resourceUsage ? process.resourceUsage().userCPUTime : null,
        systemCPUTime: process.resourceUsage ? process.resourceUsage().systemCPUTime : null
      },
      
      // Node.js specific
      nodeInfo: {
        version: process.version,
        features: process.features,
        config: process.config
      }
    };
    
    const logEntry = {
      ...data,
      process: {
        ...this.processInfo,
        current: currentProcessInfo
      },
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  logProcessEvent(eventType, eventData = {}) {
    this.logger.info(`Process event: ${eventType}`, {
      eventType,
      eventData,
      process: this.getMinimalProcessInfo(),
      timestamp: new Date().toISOString()
    });
  }
  
  logProcessHealth() {
    const health = {
      status: 'healthy',
      checks: {
        memory: this.checkMemoryHealth(),
        cpu: this.checkCPUHealth(),
        eventLoop: this.checkEventLoopHealth(),
        handles: this.checkHandlesHealth()
      },
      uptime: process.uptime(),
      timestamp: new Date().toISOString()
    };
    
    // Determine overall health status
    const failedChecks = Object.values(health.checks).filter(check => !check.healthy);
    if (failedChecks.length > 0) {
      health.status = failedChecks.some(check => check.critical) ? 'critical' : 'degraded';
    }
    
    const logLevel = health.status === 'critical' ? 'error' : 
                     health.status === 'degraded' ? 'warn' : 'info';
    
    this.logger[logLevel](`Process health: ${health.status}`, health);
  }
  
  logResourceUsage() {
    const usage = {
      memory: process.memoryUsage(),
      cpu: process.cpuUsage(),
      resourceUsage: process.resourceUsage ? process.resourceUsage() : null,
      uptime: process.uptime(),
      eventLoop: {
        lag: this.measureEventLoopLag(),
        activeHandles: process._getActiveHandles().length,
        activeRequests: process._getActiveRequests().length
      },
      system: {
        loadAvg: require('os').loadavg(),
        freeMem: require('os').freemem(),
        totalMem: require('os').totalmem(),
        cpus: require('os').cpus().length
      },
      timestamp: new Date().toISOString()
    };
    
    this.logger.debug('Process resource usage', usage);
  }
  
  measureEventLoopLag() {
    const start = process.hrtime.bigint();
    return new Promise(resolve => {
      setImmediate(() => {
        const lag = Number(process.hrtime.bigint() - start) / 1000000; // Convert to milliseconds
        resolve(lag);
      });
    });
  }
  
  checkMemoryHealth() {
    const usage = process.memoryUsage();
    const totalMem = require('os').totalmem();
    const memoryPercentage = (usage.rss / totalMem) * 100;
    
    return {
      healthy: memoryPercentage < 80,
      critical: memoryPercentage > 95,
      percentage: memoryPercentage,
      usage,
      thresholds: {
        warning: 80,
        critical: 95
      }
    };
  }
  
  checkCPUHealth() {
    const cpuUsage = process.cpuUsage();
    const totalTime = cpuUsage.user + cpuUsage.system;
    const uptime = process.uptime() * 1000000; // Convert to microseconds
    const cpuPercentage = (totalTime / uptime) * 100;
    
    return {
      healthy: cpuPercentage < 80,
      critical: cpuPercentage > 95,
      percentage: cpuPercentage,
      usage: cpuUsage,
      thresholds: {
        warning: 80,
        critical: 95
      }
    };
  }
  
  checkEventLoopHealth() {
    const activeHandles = process._getActiveHandles().length;
    const activeRequests = process._getActiveRequests().length;
    
    return {
      healthy: activeHandles < 1000 && activeRequests < 100,
      critical: activeHandles > 5000 || activeRequests > 1000,
      activeHandles,
      activeRequests,
      thresholds: {
        handles: { warning: 1000, critical: 5000 },
        requests: { warning: 100, critical: 1000 }
      }
    };
  }
  
  checkHandlesHealth() {
    const handles = process._getActiveHandles();
    const requests = process._getActiveRequests();
    
    return {
      healthy: handles.length < 500,
      critical: handles.length > 2000,
      handleCount: handles.length,
      requestCount: requests.length,
      handleTypes: this.categorizeHandles(handles)
    };
  }
  
  categorizeHandles(handles) {
    const categories = {};
    
    handles.forEach(handle => {
      const type = handle.constructor.name;
      categories[type] = (categories[type] || 0) + 1;
    });
    
    return categories;
  }
  
  getMinimalProcessInfo() {
    return {
      pid: process.pid,
      uptime: process.uptime(),
      memoryRSS: process.memoryUsage().rss,
      eventLoopLag: this.measureEventLoopLag()
    };
  }
}
```

### 2. **Worker Thread Information**
Tracking and logging worker thread activities in Node.js applications.

```javascript
// Worker thread information logging
class WorkerThreadLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'WorkerThreadLogger' });
    this.isMainThread = require('worker_threads').isMainThread;
    this.threadId = require('worker_threads').threadId;
    this.workerData = require('worker_threads').workerData;
    
    this.threadInfo = this.captureThreadInformation();
    this.messageHandlers = this.setupMessageHandlers();
  }
  
  captureThreadInformation() {
    const { isMainThread, threadId, workerData, parentPort } = require('worker_threads');
    
    return {
      // Thread identification
      isMainThread,
      threadId,
      parentThreadId: isMainThread ? null : 'main',
      
      // Thread role and purpose
      threadType: isMainThread ? 'main' : 'worker',
      threadRole: this.determineThreadRole(),
      threadPurpose: workerData?.purpose || 'general',
      
      // Worker-specific information
      workerData: workerData || null,
      hasParentPort: !!parentPort,
      
      // Thread lifecycle
      createdAt: new Date().toISOString(),
      startTime: process.hrtime.bigint(),
      
      // Thread configuration
      threadConfig: {
        stackSizeMb: workerData?.stackSizeMb,
        maxOldGenerationSizeMb: workerData?.maxOldGenerationSizeMb,
        maxYoungGenerationSizeMb: workerData?.maxYoungGenerationSizeMb,
        sharedArrayBuffers: workerData?.sharedArrayBuffers || []
      },
      
      // Communication channels
      communication: {
        parentPort: !!parentPort,
        messageChannels: this.getMessageChannels(),
        broadcastChannels: this.getBroadcastChannels()
      }
    };
  }
  
  setupMessageHandlers() {
    const { parentPort, MessageChannel } = require('worker_threads');
    
    if (!this.isMainThread && parentPort) {
      // Set up message logging for worker threads
      parentPort.on('message', (message) => {
        this.logMessage('received', message, 'parent');
      });
      
      parentPort.on('error', (error) => {
        this.logThreadError('parent_port_error', error);
      });
      
      parentPort.on('close', () => {
        this.logThreadEvent('parent_port_closed');
      });
    }
    
    return {
      // Message logging wrapper
      logMessage: (direction, message, source) => {
        this.logger.debug(`Thread message ${direction}`, {
          threadId: this.threadId,
          direction,
          source,
          message: this.sanitizeMessage(message),
          messageType: typeof message,
          messageSize: JSON.stringify(message).length,
          timestamp: new Date().toISOString()
        });
      },
      
      // Error logging for thread communication
      logThreadError: (errorType, error) => {
        this.logger.error(`Thread error: ${errorType}`, {
          threadId: this.threadId,
          errorType,
          error: {
            message: error.message,
            stack: error.stack,
            name: error.name,
            code: error.code
          },
          threadInfo: this.threadInfo,
          timestamp: new Date().toISOString()
        });
      },
      
      // Thread lifecycle events
      logThreadEvent: (eventType, eventData = {}) => {
        this.logger.info(`Thread event: ${eventType}`, {
          threadId: this.threadId,
          eventType,
          eventData,
          threadInfo: this.getMinimalThreadInfo(),
          timestamp: new Date().toISOString()
        });
      }
    };
  }
  
  logWithThreadInfo(level, message, data = {}) {
    const threadContext = {
      // Current thread information
      thread: {
        id: this.threadId,
        type: this.threadInfo.threadType,
        role: this.threadInfo.threadRole,
        purpose: this.threadInfo.threadPurpose,
        isMain: this.isMainThread
      },
      
      // Thread performance information
      performance: {
        uptime: Number(process.hrtime.bigint() - this.threadInfo.startTime) / 1000000000, // Convert to seconds
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage(),
        resourceUsage: process.resourceUsage ? process.resourceUsage() : null
      },
      
      // Thread communication state
      communication: {
        messagesSent: this.getMessagesSentCount(),
        messagesReceived: this.getMessagesReceivedCount(),
        activeCommunicationChannels: this.getActiveCommunicationChannels(),
        pendingOperations: this.getPendingOperations()
      },
      
      // Thread synchronization
      synchronization: {
        sharedArrayBuffers: this.threadInfo.threadConfig.sharedArrayBuffers.length,
        atomicsOperations: this.getAtomicsOperationsCount(),
        locks: this.getActiveLocks()
      }
    };
    
    const logEntry = {
      ...data,
      ...threadContext,
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  determineThreadRole() {
    if (this.isMainThread) {
      return 'coordinator';
    }
    
    const purpose = this.workerData?.purpose;
    switch (purpose) {
      case 'cpu_intensive':
        return 'compute_worker';
      case 'io_operations':
        return 'io_worker';
      case 'data_processing':
        return 'data_worker';
      case 'background_tasks':
        return 'background_worker';
      default:
        return 'general_worker';
    }
  }
  
  getMessageChannels() {
    // In a real implementation, this would track created MessageChannels
    return [];
  }
  
  getBroadcastChannels() {
    // Track BroadcastChannel instances if using them
    return [];
  }
  
  sanitizeMessage(message) {
    // Remove sensitive data from message logging
    if (typeof message === 'object' && message !== null) {
      const sanitized = { ...message };
      
      // Remove common sensitive fields
      ['password', 'token', 'apiKey', 'secret', 'credentials'].forEach(field => {
        if (sanitized[field]) {
          sanitized[field] = '[REDACTED]';
        }
      });
      
      return sanitized;
    }
    
    return message;
  }
  
  getMinimalThreadInfo() {
    return {
      id: this.threadId,
      type: this.threadInfo.threadType,
      uptime: Number(process.hrtime.bigint() - this.threadInfo.startTime) / 1000000000,
      memoryRSS: process.memoryUsage().rss
    };
  }
  
  // Placeholder methods for tracking communication metrics
  getMessagesSentCount() { return 0; }
  getMessagesReceivedCount() { return 0; }
  getActiveCommunicationChannels() { return []; }
  getPendingOperations() { return []; }
  getAtomicsOperationsCount() { return 0; }
  getActiveLocks() { return []; }
}
```

### 3. **Async Context Tracking**
Tracking asynchronous operation context across the event loop.

```javascript
// Async context tracking for Node.js
class AsyncContextTracker {
  constructor(logger) {
    this.logger = logger.child({ component: 'AsyncContextTracker' });
    this.asyncHooks = require('async_hooks');
    this.contexts = new Map();
    this.activeContexts = new Set();
    
    this.asyncHook = this.setupAsyncHooks();
    this.contextIdGenerator = this.setupContextIdGenerator();
  }
  
  setupAsyncHooks() {
    const hook = this.asyncHooks.createHook({
      init: (asyncId, type, triggerAsyncId, resource) => {
        this.initAsyncResource(asyncId, type, triggerAsyncId, resource);
      },
      
      before: (asyncId) => {
        this.beforeAsyncExecution(asyncId);
      },
      
      after: (asyncId) => {
        this.afterAsyncExecution(asyncId);
      },
      
      destroy: (asyncId) => {
        this.destroyAsyncResource(asyncId);
      },
      
      promiseResolve: (asyncId) => {
        this.promiseResolved(asyncId);
      }
    });
    
    return hook;
  }
  
  setupContextIdGenerator() {
    let contextIdCounter = 0;
    
    return {
      generate: () => {
        return `ctx_${Date.now()}_${++contextIdCounter}_${Math.random().toString(36).substr(2, 9)}`;
      },
      
      generateCorrelationId: () => {
        return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;
      },
      
      generateSpanId: () => {
        return `span_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;
      }
    };
  }
  
  enable() {
    this.asyncHook.enable();
    this.logger.info('Async context tracking enabled');
  }
  
  disable() {
    this.asyncHook.disable();
    this.logger.info('Async context tracking disabled');
  }
  
  createContext(contextData = {}) {
    const contextId = this.contextIdGenerator.generate();
    const correlationId = this.contextIdGenerator.generateCorrelationId();
    
    const context = {
      contextId,
      correlationId,
      parentContextId: this.getCurrentContextId(),
      
      // Context metadata
      createdAt: new Date().toISOString(),
      createdBy: contextData.createdBy || 'system',
      purpose: contextData.purpose || 'general',
      priority: contextData.priority || 'normal',
      
      // Execution tracking
      execution: {
        asyncId: this.asyncHooks.executionAsyncId(),
        triggerAsyncId: this.asyncHooks.triggerAsyncId(),
        startTime: process.hrtime.bigint(),
        operations: [],
        spans: []
      },
      
      // User-provided data
      data: { ...contextData },
      
      // Context state
      state: {
        active: true,
        suspended: false,
        errorOccurred: false,
        completed: false
      },
      
      // Performance tracking
      performance: {
        startTime: process.hrtime.bigint(),
        cpuTime: process.cpuUsage(),
        memorySnapshot: process.memoryUsage()
      }
    };
    
    this.contexts.set(contextId, context);
    this.activeContexts.add(contextId);
    
    this.logger.debug('Async context created', {
      contextId,
      correlationId,
      parentContextId: context.parentContextId,
      contextData
    });
    
    return context;
  }
  
  logWithAsyncContext(level, message, data = {}) {
    const currentContextId = this.getCurrentContextId();
    const context = currentContextId ? this.contexts.get(currentContextId) : null;
    
    const asyncInfo = {
      // Current async execution information
      async: {
        executionAsyncId: this.asyncHooks.executionAsyncId(),
        triggerAsyncId: this.asyncHooks.triggerAsyncId(),
        contextId: currentContextId,
        correlationId: context?.correlationId,
        parentContextId: context?.parentContextId
      },
      
      // Context chain
      contextChain: this.getContextChain(currentContextId),
      
      // Async operation tracking
      operation: {
        id: this.contextIdGenerator.generate(),
        timestamp: new Date().toISOString(),
        asyncStack: this.captureAsyncStack(),
        eventLoopPhase: this.getEventLoopPhase()
      },
      
      // Performance context
      performance: context ? {
        contextUptime: Number(process.hrtime.bigint() - context.performance.startTime) / 1000000, // milliseconds
        operationCount: context.execution.operations.length,
        spanCount: context.execution.spans.length
      } : null
    };
    
    // Add operation to context if available
    if (context) {
      context.execution.operations.push({
        level,
        message,
        timestamp: asyncInfo.operation.timestamp,
        operationId: asyncInfo.operation.id
      });
    }
    
    const logEntry = {
      ...data,
      ...asyncInfo,
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  initAsyncResource(asyncId, type, triggerAsyncId, resource) {
    const currentContextId = this.getCurrentContextId();
    
    if (currentContextId) {
      const context = this.contexts.get(currentContextId);
      if (context) {
        context.execution.operations.push({
          type: 'async_init',
          asyncId,
          resourceType: type,
          triggerAsyncId,
          timestamp: new Date().toISOString()
        });
      }
    }
    
    this.logger.trace('Async resource initialized', {
      asyncId,
      type,
      triggerAsyncId,
      contextId: currentContextId,
      resourceInfo: this.getResourceInfo(resource)
    });
  }
  
  beforeAsyncExecution(asyncId) {
    const contextId = this.findContextByAsyncId(asyncId);
    
    if (contextId) {
      const context = this.contexts.get(contextId);
      if (context) {
        context.state.active = true;
        this.activeContexts.add(contextId);
      }
    }
    
    this.logger.trace('Before async execution', {
      asyncId,
      contextId,
      activeContextsCount: this.activeContexts.size
    });
  }
  
  afterAsyncExecution(asyncId) {
    const contextId = this.findContextByAsyncId(asyncId);
    
    if (contextId) {
      const context = this.contexts.get(contextId);
      if (context) {
        context.state.active = false;
        this.activeContexts.delete(contextId);
      }
    }
    
    this.logger.trace('After async execution', {
      asyncId,
      contextId,
      activeContextsCount: this.activeContexts.size
    });
  }
  
  destroyAsyncResource(asyncId) {
    const contextId = this.findContextByAsyncId(asyncId);
    
    this.logger.trace('Async resource destroyed', {
      asyncId,
      contextId
    });
  }
  
  promiseResolved(asyncId) {
    const contextId = this.findContextByAsyncId(asyncId);
    
    this.logger.trace('Promise resolved', {
      asyncId,
      contextId
    });
  }
  
  getCurrentContextId() {
    // Implementation would depend on async_hooks context storage
    // This is a simplified version
    const asyncId = this.asyncHooks.executionAsyncId();
    return this.findContextByAsyncId(asyncId);
  }
  
  findContextByAsyncId(asyncId) {
    // Simplified implementation - would need proper async ID tracking
    for (const [contextId, context] of this.contexts) {
      if (context.execution.asyncId === asyncId) {
        return contextId;
      }
    }
    return null;
  }
  
  getContextChain(contextId) {
    const chain = [];
    let currentId = contextId;
    
    while (currentId && chain.length < 20) { // Prevent infinite loops
      const context = this.contexts.get(currentId);
      if (!context) break;
      
      chain.push({
        contextId: currentId,
        correlationId: context.correlationId,
        purpose: context.purpose,
        createdAt: context.createdAt
      });
      
      currentId = context.parentContextId;
    }
    
    return chain;
  }
  
  captureAsyncStack() {
    // Capture async stack trace information
    const stack = new Error().stack;
    return {
      rawStack: stack,
      asyncFrames: this.parseAsyncFrames(stack),
      depth: (stack.match(/\n/g) || []).length
    };
  }
  
  parseAsyncFrames(stack) {
    // Parse async stack frames - simplified implementation
    return stack.split('\n')
      .slice(1) // Remove error message line
      .map(line => line.trim())
      .filter(line => line.startsWith('at '))
      .map(line => ({
        function: this.extractFunctionName(line),
        location: this.extractLocation(line),
        isAsync: line.includes('async ')
      }));
  }
  
  extractFunctionName(stackLine) {
    const match = stackLine.match(/at\s+([^\s]+)/);
    return match ? match[1] : 'anonymous';
  }
  
  extractLocation(stackLine) {
    const match = stackLine.match(/\(([^)]+)\)$/);
    return match ? match[1] : stackLine.substring(stackLine.lastIndexOf(' ') + 1);
  }
  
  getEventLoopPhase() {
    // Node.js doesn't directly expose event loop phase, this is conceptual
    return 'unknown'; // Would need native addon or different approach
  }
  
  getResourceInfo(resource) {
    if (!resource) return null;
    
    return {
      type: resource.constructor.name,
      hasAsyncId: typeof resource.asyncId === 'number',
      hasTriggerAsyncId: typeof resource.triggerAsyncId === 'number'
    };
  }
  
  getContextStatistics() {
    const stats = {
      totalContexts: this.contexts.size,
      activeContexts: this.activeContexts.size,
      completedContexts: 0,
      erroredContexts: 0,
      avgContextLifetime: 0,
      longestRunningContext: null,
      contextsByPurpose: {}
    };
    
    let totalLifetime = 0;
    let longestLifetime = 0;
    
    this.contexts.forEach(context => {
      const lifetime = context.state.completed ? 
        context.performance.endTime - context.performance.startTime :
        Number(process.hrtime.bigint() - context.performance.startTime) / 1000000;
      
      totalLifetime += lifetime;
      
      if (lifetime > longestLifetime) {
        longestLifetime = lifetime;
        stats.longestRunningContext = {
          contextId: context.contextId,
          lifetime,
          purpose: context.purpose
        };
      }
      
      if (context.state.completed) stats.completedContexts++;
      if (context.state.errorOccurred) stats.erroredContexts++;
      
      stats.contextsByPurpose[context.purpose] = 
        (stats.contextsByPurpose[context.purpose] || 0) + 1;
    });
    
    stats.avgContextLifetime = this.contexts.size > 0 ? 
      totalLifetime / this.contexts.size : 0;
    
    return stats;
  }
}
```

## Thread Correlation and Request Tracking

### 1. **Request Correlation Implementation**
```javascript
// Request correlation across async operations
class RequestCorrelationTracker {
  constructor(logger) {
    this.logger = logger.child({ component: 'RequestCorrelationTracker' });
    this.correlationStorage = new Map();
    this.requestChains = new Map();
  }
  
  createRequestCorrelation(requestId, metadata = {}) {
    const correlation = {
      requestId,
      correlationId: this.generateCorrelationId(),
      traceId: this.generateTraceId(),
      spanId: this.generateSpanId(),
      parentSpanId: null,
      
      // Request metadata
      metadata: {
        method: metadata.method,
        url: metadata.url,
        userAgent: metadata.userAgent,
        ip: metadata.ip,
        userId: metadata.userId,
        sessionId: metadata.sessionId,
        ...metadata
      },
      
      // Timing information
      timing: {
        startTime: process.hrtime.bigint(),
        requestStart: new Date().toISOString()
      },
      
      // Request chain tracking
      chain: {
        depth: 0,
        operations: [],
        spans: [],
        childRequests: []
      }
    };
    
    this.correlationStorage.set(requestId, correlation);
    
    this.logger.info('Request correlation created', {
      requestId,
      correlationId: correlation.correlationId,
      traceId: correlation.traceId,
      metadata: correlation.metadata
    });
    
    return correlation;
  }
  
  logWithCorrelation(level, message, data = {}, requestId = null) {
    const correlation = requestId ? 
      this.correlationStorage.get(requestId) : 
      this.getCurrentCorrelation();
    
    const correlationInfo = correlation ? {
      correlation: {
        requestId: correlation.requestId,
        correlationId: correlation.correlationId,
        traceId: correlation.traceId,
        spanId: correlation.spanId,
        parentSpanId: correlation.parentSpanId,
        depth: correlation.chain.depth
      },
      
      request: {
        method: correlation.metadata.method,
        url: correlation.metadata.url,
        userId: correlation.metadata.userId,
        sessionId: correlation.metadata.sessionId
      },
      
      timing: {
        requestUptime: Number(process.hrtime.bigint() - correlation.timing.startTime) / 1000000,
        operationCount: correlation.chain.operations.length
      }
    } : {};
    
    const logEntry = {
      ...data,
      ...correlationInfo,
      timestamp: new Date().toISOString(),
      level: level.toUpperCase(),
      message
    };
    
    // Add operation to correlation chain
    if (correlation) {
      correlation.chain.operations.push({
        level,
        message,
        timestamp: logEntry.timestamp,
        data: data
      });
    }
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  generateCorrelationId() {
    return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;
  }
  
  generateTraceId() {
    return `trace_${Date.now()}_${Math.random().toString(36).substr(2, 16)}`;
  }
  
  generateSpanId() {
    return `span_${Date.now()}_${Math.random().toString(36).substr(2, 12)}`;
  }
  
  getCurrentCorrelation() {
    // Implementation would depend on async context storage
    // This is a simplified version
    return null;
  }
}
```

---

**Previous**: [2.2.3 Logger Name/Category](./2.2.3_Logger_Name_Category.md)  
**Next**: [2.2.5 Message Content](./2.2.5_Message_Content.md)
