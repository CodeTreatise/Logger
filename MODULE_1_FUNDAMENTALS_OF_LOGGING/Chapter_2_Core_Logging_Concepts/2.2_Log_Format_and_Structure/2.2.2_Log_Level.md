# 2.2.2 Log Level

## Understanding Log Level in Format Structure

The log level is a critical component of log format that indicates the severity and importance of the logged event. It serves as a primary filtering mechanism, enables automated alerting, and provides immediate context about the nature of the event. Proper log level formatting ensures consistent parsing, efficient processing, and effective log analysis.

## Log Level Representation Formats

### 1. **Standard Textual Representation**
The most common and human-readable format for log levels.

```javascript
// Standard textual log level formatting
class TextualLogLevelFormatter {
  constructor(logger) {
    this.logger = logger.child({ component: 'TextualLogLevelFormatter' });
    this.levelMappings = this.setupLevelMappings();
    this.formatters = this.setupFormatters();
  }
  
  setupLevelMappings() {
    return {
      // Standard log levels with various representations
      levels: {
        fatal: {
          value: 60,
          names: ['FATAL', 'CRITICAL', 'CRIT', 'F'],
          description: 'System unusable, immediate attention required',
          color: 'red',
          symbol: 'ðŸ”´',
          priority: 'P0'
        },
        error: {
          value: 50,
          names: ['ERROR', 'ERR', 'E'],
          description: 'Error conditions that need attention',
          color: 'red',
          symbol: 'âŒ',
          priority: 'P1'
        },
        warn: {
          value: 40,
          names: ['WARN', 'WARNING', 'W'],
          description: 'Warning conditions, potential issues',
          color: 'yellow',
          symbol: 'âš ï¸',
          priority: 'P2'
        },
        info: {
          value: 30,
          names: ['INFO', 'INFORMATION', 'I'],
          description: 'Informational messages',
          color: 'green',
          symbol: 'â„¹ï¸',
          priority: 'P3'
        },
        debug: {
          value: 20,
          names: ['DEBUG', 'DBG', 'D'],
          description: 'Detailed debugging information',
          color: 'blue',
          symbol: 'ðŸ”',
          priority: 'P4'
        },
        trace: {
          value: 10,
          names: ['TRACE', 'TRC', 'T'],
          description: 'Finest-grained informational events',
          color: 'gray',
          symbol: 'ðŸ”¬',
          priority: 'P5'
        }
      },
      
      // Format variations
      formatStyles: {
        uppercase: (level) => level.toUpperCase(),
        lowercase: (level) => level.toLowerCase(),
        capitalized: (level) => level.charAt(0).toUpperCase() + level.slice(1).toLowerCase(),
        abbreviated: (level) => this.getAbbreviation(level),
        padded: (level, width = 5) => level.toUpperCase().padEnd(width),
        bracketed: (level) => `[${level.toUpperCase()}]`,
        parenthesized: (level) => `(${level.toUpperCase()})`,
        symbolic: (level) => this.getLevelSymbol(level)
      }
    };
  }
  
  setupFormatters() {
    return {
      // Standard formatter
      standard: (level) => {
        return {
          level: level.toUpperCase(),
          format: 'standard',
          representation: level.toUpperCase()
        };
      },
      
      // Detailed formatter with metadata
      detailed: (level) => {
        const levelInfo = this.levelMappings.levels[level.toLowerCase()];
        return {
          level: level.toUpperCase(),
          levelValue: levelInfo?.value || 0,
          levelName: levelInfo?.names[0] || level.toUpperCase(),
          description: levelInfo?.description || 'Unknown level',
          priority: levelInfo?.priority || 'P?',
          symbol: levelInfo?.symbol || 'â“',
          color: levelInfo?.color || 'default',
          format: 'detailed'
        };
      },
      
      // Compact formatter for space-constrained environments
      compact: (level) => {
        const abbrev = this.getAbbreviation(level);
        return {
          level: abbrev,
          format: 'compact',
          fullLevel: level.toUpperCase()
        };
      },
      
      // Visual formatter with colors and symbols
      visual: (level) => {
        const levelInfo = this.levelMappings.levels[level.toLowerCase()];
        return {
          level: level.toUpperCase(),
          symbol: levelInfo?.symbol || 'â“',
          coloredLevel: this.applyColor(level.toUpperCase(), levelInfo?.color),
          visualRepresentation: `${levelInfo?.symbol || 'â“'} ${level.toUpperCase()}`,
          format: 'visual'
        };
      },
      
      // Structured formatter for machine processing
      structured: (level) => {
        const levelInfo = this.levelMappings.levels[level.toLowerCase()];
        return {
          level: {
            name: level.toUpperCase(),
            value: levelInfo?.value || 0,
            severity: this.getSeverityCategory(levelInfo?.value || 0),
            isError: (levelInfo?.value || 0) >= 40,
            isWarning: (levelInfo?.value || 0) === 40,
            isInfo: (levelInfo?.value || 0) <= 30,
            requiresAction: (levelInfo?.value || 0) >= 50,
            alertable: (levelInfo?.value || 0) >= 40
          },
          metadata: {
            priority: levelInfo?.priority || 'P?',
            category: this.getCategoryFromLevel(level),
            urgency: this.getUrgencyFromLevel(level),
            audience: this.getAudienceFromLevel(level)
          },
          format: 'structured'
        };
      }
    };
  }
  
  formatLogLevel(level, style = 'standard', options = {}) {
    const formatter = this.formatters[style];
    if (!formatter) {
      throw new Error(`Unknown log level format style: ${style}`);
    }
    
    const formatted = formatter(level);
    
    // Apply additional formatting options
    if (options.padding) {
      formatted.paddedLevel = formatted.level.padEnd(options.padding);
    }
    
    if (options.brackets) {
      formatted.bracketedLevel = `[${formatted.level}]`;
    }
    
    if (options.timestamp) {
      formatted.timestampedLevel = `${new Date().toISOString()} ${formatted.level}`;
    }
    
    // Log the formatting demonstration
    this.logger.debug('Log level formatting demonstration', {
      originalLevel: level,
      style,
      options,
      formatted,
      allVariations: this.getAllLevelVariations(level)
    });
    
    return formatted;
  }
  
  getAllLevelVariations(level) {
    const variations = {};
    
    Object.keys(this.levelMappings.formatStyles).forEach(styleName => {
      const styleFunc = this.levelMappings.formatStyles[styleName];
      variations[styleName] = styleFunc(level);
    });
    
    return variations;
  }
  
  getAbbreviation(level) {
    const levelInfo = this.levelMappings.levels[level.toLowerCase()];
    return levelInfo?.names[levelInfo.names.length - 1] || level.charAt(0).toUpperCase();
  }
  
  getLevelSymbol(level) {
    const levelInfo = this.levelMappings.levels[level.toLowerCase()];
    return levelInfo?.symbol || 'â“';
  }
  
  applyColor(text, color) {
    const colors = {
      red: '\x1b[31m',
      yellow: '\x1b[33m',
      green: '\x1b[32m',
      blue: '\x1b[34m',
      gray: '\x1b[90m',
      reset: '\x1b[0m'
    };
    
    return `${colors[color] || ''}${text}${colors.reset}`;
  }
  
  getSeverityCategory(value) {
    if (value >= 50) return 'critical';
    if (value >= 40) return 'warning';
    if (value >= 30) return 'normal';
    return 'debug';
  }
  
  getCategoryFromLevel(level) {
    const categories = {
      fatal: 'system',
      error: 'application',
      warn: 'operational',
      info: 'business',
      debug: 'development',
      trace: 'diagnostic'
    };
    return categories[level.toLowerCase()] || 'unknown';
  }
  
  getUrgencyFromLevel(level) {
    const urgencies = {
      fatal: 'immediate',
      error: 'high',
      warn: 'medium',
      info: 'low',
      debug: 'none',
      trace: 'none'
    };
    return urgencies[level.toLowerCase()] || 'unknown';
  }
  
  getAudienceFromLevel(level) {
    const audiences = {
      fatal: ['executives', 'oncall', 'operations', 'developers'],
      error: ['oncall', 'operations', 'developers'],
      warn: ['operations', 'developers'],
      info: ['operations', 'business'],
      debug: ['developers'],
      trace: ['developers']
    };
    return audiences[level.toLowerCase()] || ['developers'];
  }
}
```

### 2. **Numeric Log Level Representation**
Numeric representation for efficient processing and comparison.

```javascript
// Numeric log level formatting
class NumericLogLevelFormatter {
  constructor(logger) {
    this.logger = logger.child({ component: 'NumericLogLevelFormatter' });
    this.numericMappings = this.setupNumericMappings();
    this.conversionUtils = this.setupConversionUtils();
  }
  
  setupNumericMappings() {
    return {
      // Standard numeric mappings (following syslog and npm conventions)
      syslog: {
        emergency: 0,    // System is unusable
        alert: 1,        // Action must be taken immediately
        critical: 2,     // Critical conditions
        error: 3,        // Error conditions
        warning: 4,      // Warning conditions
        notice: 5,       // Normal but significant condition
        informational: 6, // Informational messages
        debug: 7         // Debug-level messages
      },
      
      // npm-style numeric levels
      npm: {
        silly: 0,
        debug: 1,
        verbose: 2,
        info: 3,
        warn: 4,
        error: 5
      },
      
      // Custom application levels
      custom: {
        trace: 10,
        debug: 20,
        info: 30,
        warn: 40,
        error: 50,
        fatal: 60
      },
      
      // Log4j style levels
      log4j: {
        ALL: 0,
        TRACE: 5,
        DEBUG: 10,
        INFO: 20,
        WARN: 30,
        ERROR: 40,
        FATAL: 50,
        OFF: 100
      },
      
      // Java Logging API levels
      jul: {
        FINEST: 300,
        FINER: 400,
        FINE: 500,
        CONFIG: 700,
        INFO: 800,
        WARNING: 900,
        SEVERE: 1000
      }
    };
  }
  
  setupConversionUtils() {
    return {
      // Convert level name to numeric value
      nameToNumeric: (levelName, system = 'custom') => {
        const mapping = this.numericMappings[system];
        if (!mapping) {
          throw new Error(`Unknown numeric level system: ${system}`);
        }
        
        const normalizedName = levelName.toLowerCase();
        const value = mapping[normalizedName];
        
        if (value === undefined) {
          // Try to find closest match
          const closestMatch = this.findClosestLevelMatch(normalizedName, mapping);
          return closestMatch ? mapping[closestMatch] : null;
        }
        
        return value;
      },
      
      // Convert numeric value to level name
      numericToName: (numericValue, system = 'custom') => {
        const mapping = this.numericMappings[system];
        if (!mapping) {
          throw new Error(`Unknown numeric level system: ${system}`);
        }
        
        // Find exact match
        const exactMatch = Object.entries(mapping).find(([name, value]) => value === numericValue);
        if (exactMatch) {
          return exactMatch[0];
        }
        
        // Find closest lower value
        const sortedLevels = Object.entries(mapping)
          .sort(([, a], [, b]) => b - a)
          .find(([name, value]) => value <= numericValue);
        
        return sortedLevels ? sortedLevels[0] : null;
      },
      
      // Convert between different numeric systems
      convertBetweenSystems: (value, fromSystem, toSystem) => {
        const levelName = this.conversionUtils.numericToName(value, fromSystem);
        if (!levelName) {
          return null;
        }
        
        return this.conversionUtils.nameToNumeric(levelName, toSystem);
      },
      
      // Compare levels numerically
      compareLevels: (level1, level2, system = 'custom') => {
        const value1 = typeof level1 === 'string' ? 
          this.conversionUtils.nameToNumeric(level1, system) : level1;
        const value2 = typeof level2 === 'string' ? 
          this.conversionUtils.nameToNumeric(level2, system) : level2;
        
        if (value1 === null || value2 === null) {
          return null;
        }
        
        return value1 - value2;
      }
    };
  }
  
  formatNumericLogLevel(level, options = {}) {
    const {
      system = 'custom',
      includeMapping = true,
      includeMagnitude = true,
      includeRange = true,
      includeComparisons = true
    } = options;
    
    const numericValue = typeof level === 'string' ? 
      this.conversionUtils.nameToNumeric(level, system) : level;
    
    const levelName = typeof level === 'number' ? 
      this.conversionUtils.numericToName(level, system) : level;
    
    const formatted = {
      originalLevel: level,
      numericValue,
      levelName,
      system,
      format: 'numeric'
    };
    
    if (includeMapping) {
      formatted.systemMappings = this.getAllSystemMappings(levelName || level);
    }
    
    if (includeMagnitude) {
      formatted.magnitude = this.calculateLevelMagnitude(numericValue, system);
    }
    
    if (includeRange) {
      formatted.range = this.getLevelRange(numericValue, system);
    }
    
    if (includeComparisons) {
      formatted.comparisons = this.generateLevelComparisons(numericValue, system);
    }
    
    // Add processing metadata
    formatted.processingInfo = {
      isValidLevel: numericValue !== null,
      canCompare: true,
      sortOrder: numericValue,
      filterValue: numericValue,
      thresholdCompatible: true
    };
    
    this.logger.debug('Numeric log level formatting', formatted);
    return formatted;
  }
  
  getAllSystemMappings(level) {
    const mappings = {};
    
    Object.keys(this.numericMappings).forEach(system => {
      const value = this.conversionUtils.nameToNumeric(level, system);
      if (value !== null) {
        mappings[system] = value;
      }
    });
    
    return mappings;
  }
  
  calculateLevelMagnitude(value, system) {
    const mapping = this.numericMappings[system];
    const values = Object.values(mapping).sort((a, b) => a - b);
    
    const min = values[0];
    const max = values[values.length - 1];
    const range = max - min;
    
    return {
      normalized: range > 0 ? (value - min) / range : 0,
      percentile: this.calculatePercentile(value, values),
      quartile: this.calculateQuartile(value, values),
      relative: value / max
    };
  }
  
  calculatePercentile(value, sortedValues) {
    const index = sortedValues.findIndex(v => v >= value);
    return index === -1 ? 100 : Math.round((index / sortedValues.length) * 100);
  }
  
  calculateQuartile(value, sortedValues) {
    const percentile = this.calculatePercentile(value, sortedValues);
    if (percentile <= 25) return 'Q1';
    if (percentile <= 50) return 'Q2';
    if (percentile <= 75) return 'Q3';
    return 'Q4';
  }
  
  getLevelRange(value, system) {
    const mapping = this.numericMappings[system];
    const sortedEntries = Object.entries(mapping).sort(([, a], [, b]) => a - b);
    
    const currentIndex = sortedEntries.findIndex(([, v]) => v === value);
    if (currentIndex === -1) return null;
    
    return {
      current: sortedEntries[currentIndex][0],
      previous: currentIndex > 0 ? sortedEntries[currentIndex - 1][0] : null,
      next: currentIndex < sortedEntries.length - 1 ? sortedEntries[currentIndex + 1][0] : null,
      position: `${currentIndex + 1}/${sortedEntries.length}`
    };
  }
  
  generateLevelComparisons(value, system) {
    const mapping = this.numericMappings[system];
    const comparisons = {};
    
    Object.entries(mapping).forEach(([name, otherValue]) => {
      const diff = value - otherValue;
      comparisons[name] = {
        numericDifference: diff,
        relationship: diff > 0 ? 'higher' : diff < 0 ? 'lower' : 'equal',
        magnitude: Math.abs(diff)
      };
    });
    
    return comparisons;
  }
  
  findClosestLevelMatch(levelName, mapping) {
    const names = Object.keys(mapping);
    
    // Try exact match (case insensitive)
    const exactMatch = names.find(name => name.toLowerCase() === levelName);
    if (exactMatch) return exactMatch;
    
    // Try partial match
    const partialMatch = names.find(name => 
      name.toLowerCase().includes(levelName) || levelName.includes(name.toLowerCase())
    );
    if (partialMatch) return partialMatch;
    
    // Try abbreviation match
    const abbreviationMatch = names.find(name => 
      name.toLowerCase().startsWith(levelName.charAt(0))
    );
    
    return abbreviationMatch || null;
  }
}
```

### 3. **Structured Log Level Representation**
Complex structured representation for advanced processing.

```javascript
// Structured log level formatting
class StructuredLogLevelFormatter {
  constructor(logger) {
    this.logger = logger.child({ component: 'StructuredLogLevelFormatter' });
    this.structuredMappings = this.setupStructuredMappings();
    this.enrichmentRules = this.setupEnrichmentRules();
  }
  
  setupStructuredMappings() {
    return {
      // Comprehensive level definitions
      levels: {
        fatal: {
          name: 'FATAL',
          value: 60,
          severity: 'critical',
          category: 'system',
          urgency: 'immediate',
          escalation: 'P0',
          retention: 'long_term',
          alerting: {
            required: true,
            channels: ['pager', 'email', 'slack', 'sms'],
            escalationTime: 300, // 5 minutes
            acknowledgmentRequired: true
          },
          audience: ['executives', 'oncall', 'operations', 'security'],
          automation: {
            autoEscalate: true,
            autoNotify: true,
            autoTicket: true,
            runbooks: ['incident_response', 'disaster_recovery']
          },
          compliance: {
            auditRequired: true,
            regulatoryNotification: true,
            evidencePreservation: true
          },
          business: {
            impactLevel: 'critical',
            customerFacing: true,
            revenueImpact: 'high',
            slaViolation: true
          }
        },
        
        error: {
          name: 'ERROR',
          value: 50,
          severity: 'high',
          category: 'application',
          urgency: 'high',
          escalation: 'P1',
          retention: 'medium_term',
          alerting: {
            required: true,
            channels: ['email', 'slack'],
            escalationTime: 900, // 15 minutes
            acknowledgmentRequired: false
          },
          audience: ['oncall', 'operations', 'developers'],
          automation: {
            autoEscalate: false,
            autoNotify: true,
            autoTicket: true,
            runbooks: ['error_investigation', 'rollback_procedure']
          },
          compliance: {
            auditRequired: false,
            regulatoryNotification: false,
            evidencePreservation: false
          },
          business: {
            impactLevel: 'high',
            customerFacing: true,
            revenueImpact: 'medium',
            slaViolation: false
          }
        },
        
        warn: {
          name: 'WARN',
          value: 40,
          severity: 'medium',
          category: 'operational',
          urgency: 'medium',
          escalation: 'P2',
          retention: 'short_term',
          alerting: {
            required: false,
            channels: ['slack'],
            escalationTime: 3600, // 1 hour
            acknowledgmentRequired: false
          },
          audience: ['operations', 'developers'],
          automation: {
            autoEscalate: false,
            autoNotify: false,
            autoTicket: false,
            runbooks: ['performance_tuning', 'capacity_planning']
          },
          compliance: {
            auditRequired: false,
            regulatoryNotification: false,
            evidencePreservation: false
          },
          business: {
            impactLevel: 'medium',
            customerFacing: false,
            revenueImpact: 'low',
            slaViolation: false
          }
        },
        
        info: {
          name: 'INFO',
          value: 30,
          severity: 'low',
          category: 'business',
          urgency: 'low',
          escalation: 'P3',
          retention: 'standard',
          alerting: {
            required: false,
            channels: [],
            escalationTime: null,
            acknowledgmentRequired: false
          },
          audience: ['business', 'operations'],
          automation: {
            autoEscalate: false,
            autoNotify: false,
            autoTicket: false,
            runbooks: []
          },
          compliance: {
            auditRequired: false,
            regulatoryNotification: false,
            evidencePreservation: false
          },
          business: {
            impactLevel: 'low',
            customerFacing: false,
            revenueImpact: 'none',
            slaViolation: false
          }
        },
        
        debug: {
          name: 'DEBUG',
          value: 20,
          severity: 'minimal',
          category: 'development',
          urgency: 'none',
          escalation: 'P4',
          retention: 'short_term',
          alerting: {
            required: false,
            channels: [],
            escalationTime: null,
            acknowledgmentRequired: false
          },
          audience: ['developers'],
          automation: {
            autoEscalate: false,
            autoNotify: false,
            autoTicket: false,
            runbooks: []
          },
          compliance: {
            auditRequired: false,
            regulatoryNotification: false,
            evidencePreservation: false
          },
          business: {
            impactLevel: 'none',
            customerFacing: false,
            revenueImpact: 'none',
            slaViolation: false
          }
        },
        
        trace: {
          name: 'TRACE',
          value: 10,
          severity: 'minimal',
          category: 'diagnostic',
          urgency: 'none',
          escalation: 'P5',
          retention: 'minimal',
          alerting: {
            required: false,
            channels: [],
            escalationTime: null,
            acknowledgmentRequired: false
          },
          audience: ['developers'],
          automation: {
            autoEscalate: false,
            autoNotify: false,
            autoTicket: false,
            runbooks: []
          },
          compliance: {
            auditRequired: false,
            regulatoryNotification: false,
            evidencePreservation: false
          },
          business: {
            impactLevel: 'none',
            customerFacing: false,
            revenueImpact: 'none',
            slaViolation: false
          }
        }
      }
    };
  }
  
  setupEnrichmentRules() {
    return {
      // Context-based enrichment
      contextual: {
        environment: (level, env) => {
          const enrichment = { environment: env };
          
          if (env === 'production') {
            enrichment.productionRules = {
              suppressDebug: level.value <= 20,
              elevateWarnings: level.value === 40,
              mandatoryAlerting: level.value >= 50
            };
          }
          
          return enrichment;
        },
        
        component: (level, component) => ({
          component,
          componentCriticality: this.getComponentCriticality(component),
          componentOwner: this.getComponentOwner(component),
          componentSLA: this.getComponentSLA(component)
        }),
        
        user: (level, userContext) => ({
          userContext,
          userImpact: this.assessUserImpact(level, userContext),
          userNotification: this.shouldNotifyUser(level, userContext)
        })
      },
      
      // Time-based enrichment
      temporal: {
        businessHours: (level, timestamp) => ({
          duringBusinessHours: this.isBusinessHours(timestamp),
          escalationModifier: this.getTimeBasedEscalation(level, timestamp),
          responseTimeExpectation: this.getResponseTimeExpectation(level, timestamp)
        }),
        
        frequency: (level, frequency) => ({
          frequency,
          rateLimit: this.shouldRateLimit(level, frequency),
          sampling: this.getSamplingRate(level, frequency),
          aggregation: this.shouldAggregate(level, frequency)
        })
      },
      
      // Business impact enrichment
      business: (level, businessContext) => ({
        businessContext,
        impactAssessment: this.assessBusinessImpact(level, businessContext),
        stakeholderNotification: this.getStakeholderNotification(level, businessContext),
        complianceRequirements: this.getComplianceRequirements(level, businessContext)
      })
    };
  }
  
  formatStructuredLogLevel(level, context = {}) {
    const levelName = typeof level === 'string' ? level.toLowerCase() : 
      this.getNameFromValue(level);
    
    const baseLevelInfo = this.structuredMappings.levels[levelName];
    if (!baseLevelInfo) {
      throw new Error(`Unknown log level: ${level}`);
    }
    
    // Start with base level information
    const structured = {
      level: {
        ...baseLevelInfo,
        originalInput: level,
        resolvedName: levelName
      },
      
      // Processing directives
      processing: {
        shouldLog: this.shouldLog(baseLevelInfo, context),
        shouldAlert: this.shouldAlert(baseLevelInfo, context),
        shouldEscalate: this.shouldEscalate(baseLevelInfo, context),
        shouldArchive: this.shouldArchive(baseLevelInfo, context),
        shouldNotify: this.shouldNotify(baseLevelInfo, context)
      },
      
      // Routing information
      routing: {
        destinations: this.getLogDestinations(baseLevelInfo, context),
        channels: this.getNotificationChannels(baseLevelInfo, context),
        audiences: this.getTargetAudiences(baseLevelInfo, context),
        systems: this.getTargetSystems(baseLevelInfo, context)
      },
      
      // Metadata for processors
      metadata: {
        timestamp: new Date().toISOString(),
        formatVersion: '2.0',
        enrichmentApplied: [],
        validationPassed: true,
        processingHints: this.getProcessingHints(baseLevelInfo, context)
      }
    };
    
    // Apply enrichment rules
    this.applyEnrichmentRules(structured, context);
    
    // Validate structured format
    this.validateStructuredFormat(structured);
    
    this.logger.debug('Structured log level formatting', {
      input: { level, context },
      output: structured,
      enrichmentSummary: this.getEnrichmentSummary(structured)
    });
    
    return structured;
  }
  
  applyEnrichmentRules(structured, context) {
    const rules = this.enrichmentRules;
    
    // Apply contextual enrichment
    if (context.environment) {
      const enrichment = rules.contextual.environment(structured.level, context.environment);
      structured.enrichment = { ...structured.enrichment, ...enrichment };
      structured.metadata.enrichmentApplied.push('environment');
    }
    
    if (context.component) {
      const enrichment = rules.contextual.component(structured.level, context.component);
      structured.enrichment = { ...structured.enrichment, ...enrichment };
      structured.metadata.enrichmentApplied.push('component');
    }
    
    if (context.user) {
      const enrichment = rules.contextual.user(structured.level, context.user);
      structured.enrichment = { ...structured.enrichment, ...enrichment };
      structured.metadata.enrichmentApplied.push('user');
    }
    
    // Apply temporal enrichment
    if (context.timestamp) {
      const enrichment = rules.temporal.businessHours(structured.level, context.timestamp);
      structured.enrichment = { ...structured.enrichment, ...enrichment };
      structured.metadata.enrichmentApplied.push('temporal');
    }
    
    if (context.frequency) {
      const enrichment = rules.temporal.frequency(structured.level, context.frequency);
      structured.enrichment = { ...structured.enrichment, ...enrichment };
      structured.metadata.enrichmentApplied.push('frequency');
    }
    
    // Apply business enrichment
    if (context.business) {
      const enrichment = rules.business(structured.level, context.business);
      structured.enrichment = { ...structured.enrichment, ...enrichment };
      structured.metadata.enrichmentApplied.push('business');
    }
  }
  
  shouldLog(levelInfo, context) {
    // Environment-based filtering
    if (context.environment === 'production' && levelInfo.value <= 20) {
      return false;
    }
    
    // Rate limiting
    if (context.frequency && context.frequency > 1000 && levelInfo.value <= 30) {
      return Math.random() < 0.1; // 10% sampling
    }
    
    return true;
  }
  
  shouldAlert(levelInfo, context) {
    return levelInfo.alerting.required && this.shouldLog(levelInfo, context);
  }
  
  shouldEscalate(levelInfo, context) {
    return levelInfo.automation.autoEscalate || 
           (levelInfo.value >= 50 && context.environment === 'production');
  }
  
  getLogDestinations(levelInfo, context) {
    const destinations = ['primary_log'];
    
    if (levelInfo.value >= 40) {
      destinations.push('error_log');
    }
    
    if (levelInfo.value >= 50) {
      destinations.push('alert_log', 'audit_log');
    }
    
    if (context.environment === 'production' && levelInfo.value >= 30) {
      destinations.push('metrics_collector');
    }
    
    return destinations;
  }
  
  getProcessingHints(levelInfo, context) {
    return {
      priority: levelInfo.escalation,
      batchable: levelInfo.value <= 30,
      compressible: levelInfo.value <= 20,
      cacheable: levelInfo.value <= 40,
      indexable: levelInfo.value >= 40,
      searchable: levelInfo.value >= 30
    };
  }
}
```

## Log Level Filtering and Thresholds

### 1. **Dynamic Filtering Implementation**
```javascript
// Dynamic log level filtering
class LogLevelFilter {
  constructor(logger) {
    this.logger = logger.child({ component: 'LogLevelFilter' });
    this.filters = this.setupFilters();
    this.thresholds = this.setupThresholds();
  }
  
  setupFilters() {
    return {
      // Static threshold filter
      threshold: (level, threshold) => {
        const levelValue = this.getLevelValue(level);
        const thresholdValue = this.getLevelValue(threshold);
        return levelValue >= thresholdValue;
      },
      
      // Environment-based filter
      environment: (level, environment) => {
        const envRules = {
          development: () => true, // Log everything
          testing: (l) => this.getLevelValue(l) >= 20, // Debug and above
          staging: (l) => this.getLevelValue(l) >= 30, // Info and above
          production: (l) => this.getLevelValue(l) >= 40 // Warn and above
        };
        
        const rule = envRules[environment] || envRules.production;
        return rule(level);
      },
      
      // Time-based filter
      timeBased: (level, timestamp) => {
        const hour = new Date(timestamp).getHours();
        const isBusinessHours = hour >= 9 && hour <= 17;
        
        if (isBusinessHours) {
          return this.getLevelValue(level) >= 30; // More verbose during business hours
        } else {
          return this.getLevelValue(level) >= 40; // Less verbose off-hours
        }
      },
      
      // Rate-based filter
      rateBased: (level, frequency) => {
        const levelValue = this.getLevelValue(level);
        
        // High-frequency events need higher threshold
        if (frequency > 1000) {
          return levelValue >= 50;
        } else if (frequency > 100) {
          return levelValue >= 40;
        } else {
          return levelValue >= 30;
        }
      },
      
      // Component-based filter
      componentBased: (level, component) => {
        const componentRules = {
          'security': () => this.getLevelValue(level) >= 30, // More verbose for security
          'payment': () => this.getLevelValue(level) >= 40, // Critical component
          'auth': () => this.getLevelValue(level) >= 30,    // Authentication events
          'api': () => this.getLevelValue(level) >= 40,     // API events
          'database': () => this.getLevelValue(level) >= 30, // Database operations
          'cache': () => this.getLevelValue(level) >= 50     // Only errors for cache
        };
        
        const rule = componentRules[component] || (() => this.getLevelValue(level) >= 30);
        return rule();
      }
    };
  }
  
  applyFilters(level, context = {}) {
    const filterResults = {
      level,
      context,
      shouldLog: true,
      appliedFilters: [],
      filterReasons: []
    };
    
    // Apply threshold filter
    if (context.threshold) {
      const passed = this.filters.threshold(level, context.threshold);
      filterResults.appliedFilters.push('threshold');
      if (!passed) {
        filterResults.shouldLog = false;
        filterResults.filterReasons.push(`Level ${level} below threshold ${context.threshold}`);
      }
    }
    
    // Apply environment filter
    if (context.environment) {
      const passed = this.filters.environment(level, context.environment);
      filterResults.appliedFilters.push('environment');
      if (!passed) {
        filterResults.shouldLog = false;
        filterResults.filterReasons.push(`Level ${level} filtered for environment ${context.environment}`);
      }
    }
    
    // Apply additional filters...
    // (continuing with other filter implementations)
    
    this.logger.trace('Log level filtering applied', filterResults);
    return filterResults;
  }
}
```

---

**Previous**: [2.2.1 Timestamp](./2.2.1_Timestamp.md)  
**Next**: [2.2.3 Logger Name/Category](./2.2.3_Logger_Name_Category.md)
