# 2.2.7 Stack Traces

## Understanding Stack Traces in Logging

Stack traces provide crucial debugging information by showing the exact sequence of function calls that led to an error or specific point in execution. Proper stack trace handling, formatting, and enhancement can significantly improve debugging efficiency and error resolution time.

## Stack Trace Capture and Enhancement

### 1. **Advanced Stack Trace Capture**
Comprehensive stack trace capture with enhancement and analysis capabilities.

```javascript
// Advanced stack trace capture and analysis
class StackTraceAnalyzer {
  constructor(logger) {
    this.logger = logger.child({ component: 'StackTraceAnalyzer' });
    this.stackEnhancers = this.setupStackEnhancers();
    this.sourceMapResolver = this.setupSourceMapResolver();
    this.stackFilters = this.setupStackFilters();
    this.stackCache = new Map();
  }
  
  setupStackEnhancers() {
    return {
      // Enhance stack trace with source map information
      enhanceWithSourceMaps: async (stack) => {
        const enhancedFrames = [];
        
        for (const frame of stack.frames) {
          try {
            const sourceLocation = await this.sourceMapResolver.resolve(
              frame.fileName, 
              frame.lineNumber, 
              frame.columnNumber
            );
            
            enhancedFrames.push({
              ...frame,
              original: sourceLocation ? {
                fileName: sourceLocation.source,
                lineNumber: sourceLocation.line,
                columnNumber: sourceLocation.column,
                functionName: sourceLocation.name || frame.functionName
              } : null,
              enhanced: true
            });
          } catch (error) {
            enhancedFrames.push({
              ...frame,
              enhanced: false,
              enhancementError: error.message
            });
          }
        }
        
        return {
          ...stack,
          frames: enhancedFrames,
          sourceMapResolved: true
        };
      },
      
      // Add context information to stack frames
      enhanceWithContext: async (stack, contextData = {}) => {
        const enhancedFrames = [];
        
        for (const frame of stack.frames) {
          const frameContext = await this.getFrameContext(frame, contextData);
          
          enhancedFrames.push({
            ...frame,
            context: frameContext,
            contextEnhanced: true
          });
        }
        
        return {
          ...stack,
          frames: enhancedFrames,
          contextEnhanced: true
        };
      },
      
      // Add code snippets around error lines
      enhanceWithCodeSnippets: async (stack) => {
        const enhancedFrames = [];
        
        for (const frame of stack.frames) {
          try {
            const codeSnippet = await this.getCodeSnippet(
              frame.fileName, 
              frame.lineNumber,
              5 // lines before and after
            );
            
            enhancedFrames.push({
              ...frame,
              codeSnippet,
              snippetEnhanced: true
            });
          } catch (error) {
            enhancedFrames.push({
              ...frame,
              snippetEnhanced: false,
              snippetError: error.message
            });
          }
        }
        
        return {
          ...stack,
          frames: enhancedFrames,
          snippetEnhanced: true
        };
      },
      
      // Classify and categorize stack trace
      enhanceWithClassification: (stack) => {
        const classification = {
          category: this.categorizeError(stack),
          pattern: this.identifyErrorPattern(stack),
          complexity: this.assessComplexity(stack),
          userCodeRatio: this.calculateUserCodeRatio(stack),
          libraryInvolvement: this.identifyLibraryInvolvement(stack),
          frameworkInvolvement: this.identifyFrameworkInvolvement(stack)
        };
        
        return {
          ...stack,
          classification,
          classified: true
        };
      },
      
      // Add performance impact information
      enhanceWithPerformance: (stack, performanceData = {}) => {
        const performance = {
          captureTime: performanceData.captureTime || Date.now(),
          processingTime: performanceData.processingTime,
          memoryImpact: performanceData.memoryImpact,
          stackDepth: stack.frames.length,
          deepestFrame: stack.frames[stack.frames.length - 1],
          
          // Analyze call patterns
          recursiveFrames: this.detectRecursion(stack.frames),
          hotspots: this.identifyHotspots(stack.frames),
          bottlenecks: this.identifyBottlenecks(stack.frames)
        };
        
        return {
          ...stack,
          performance,
          performanceEnhanced: true
        };
      }
    };
  }
  
  setupSourceMapResolver() {
    return {
      // Resolve original source location using source maps
      resolve: async (fileName, lineNumber, columnNumber) => {
        try {
          // In a real implementation, this would use a source map library
          // like 'source-map' to resolve the original location
          
          const sourceMapUrl = await this.getSourceMapUrl(fileName);
          if (!sourceMapUrl) return null;
          
          const sourceMap = await this.loadSourceMap(sourceMapUrl);
          if (!sourceMap) return null;
          
          // Mock resolution - real implementation would use SourceMapConsumer
          return {
            source: 'src/original-file.js',
            line: lineNumber - 10, // Mock transformation
            column: columnNumber,
            name: 'originalFunctionName'
          };
          
        } catch (error) {
          this.logger.warn('Source map resolution failed', {
            fileName,
            lineNumber,
            columnNumber,
            error: error.message
          });
          return null;
        }
      },
      
      // Get source map URL from file
      getSourceMapUrl: async (fileName) => {
        // Mock implementation - would read actual file
        return fileName.endsWith('.js') ? `${fileName}.map` : null;
      },
      
      // Load and parse source map
      loadSourceMap: async (sourceMapUrl) => {
        // Mock implementation - would load and parse actual source map
        return {
          version: 3,
          sources: ['src/original.js'],
          mappings: 'AAAA,SAAS...'
        };
      }
    };
  }
  
  setupStackFilters() {
    return {
      // Filter out internal Node.js frames
      filterNodeInternals: (frames) => {
        return frames.filter(frame => 
          !frame.fileName.includes('node:') &&
          !frame.fileName.includes('internal/') &&
          !frame.fileName.includes('<anonymous>')
        );
      },
      
      // Filter out library frames
      filterLibraryFrames: (frames) => {
        const libraryPatterns = [
          /node_modules/,
          /\.min\.js$/,
          /webpack/,
          /babel/
        ];
        
        return frames.filter(frame => 
          !libraryPatterns.some(pattern => pattern.test(frame.fileName))
        );
      },
      
      // Keep only application frames
      keepApplicationFrames: (frames, appPath = process.cwd()) => {
        return frames.filter(frame => 
          frame.fileName.startsWith(appPath) &&
          !frame.fileName.includes('node_modules')
        );
      },
      
      // Remove duplicate frames
      removeDuplicates: (frames) => {
        const seen = new Set();
        return frames.filter(frame => {
          const key = `${frame.fileName}:${frame.lineNumber}:${frame.functionName}`;
          if (seen.has(key)) {
            return false;
          }
          seen.add(key);
          return true;
        });
      }
    };
  }
  
  captureStackTrace(error = null, skipFrames = 0) {
    const startTime = process.hrtime.bigint();
    
    // Create or use existing error for stack trace
    const errorObj = error || new Error('Stack trace capture');
    
    // Parse stack trace
    const rawStack = errorObj.stack || '';
    const frames = this.parseStackTrace(rawStack, skipFrames + 1);
    
    const endTime = process.hrtime.bigint();
    const captureTime = Number(endTime - startTime) / 1000000; // milliseconds
    
    const stackTrace = {
      // Stack trace metadata
      id: this.generateStackId(),
      capturedAt: new Date().toISOString(),
      captureTime,
      
      // Error information
      error: error ? {
        name: error.name,
        message: error.message,
        code: error.code,
        errno: error.errno,
        syscall: error.syscall,
        path: error.path
      } : null,
      
      // Raw stack information
      raw: {
        stack: rawStack,
        framesCount: frames.length
      },
      
      // Parsed frames
      frames,
      
      // Stack trace fingerprint for deduplication
      fingerprint: this.generateStackFingerprint(frames),
      
      // Processing metadata
      processing: {
        skipFrames,
        enhanced: false,
        filtered: false,
        sourceMapResolved: false,
        contextEnhanced: false
      }
    };
    
    return stackTrace;
  }
  
  parseStackTrace(rawStack, skipFrames = 0) {
    const lines = rawStack.split('\n');
    const frames = [];
    
    // Skip the error message line and any additional frames
    const startIndex = 1 + skipFrames;
    
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line.startsWith('at ')) continue;
      
      const frame = this.parseStackFrame(line);
      if (frame) {
        frames.push({
          ...frame,
          index: frames.length,
          depth: frames.length
        });
      }
    }
    
    return frames;
  }
  
  parseStackFrame(line) {
    // Parse different stack frame formats:
    // at functionName (fileName:lineNumber:columnNumber)
    // at fileName:lineNumber:columnNumber
    // at Object.functionName (fileName:lineNumber:columnNumber)
    
    const patterns = [
      // at Object.method (file:line:col)
      /at\s+(.+?)\s+\((.+?):(\d+):(\d+)\)/,
      // at file:line:col
      /at\s+(.+?):(\d+):(\d+)/,
      // at functionName (file:line:col)
      /at\s+([^(]+?)\s+\((.+?):(\d+):(\d+)\)/
    ];
    
    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        if (match.length === 5) {
          // Pattern with function name and location
          return {
            functionName: match[1].trim(),
            fileName: match[2],
            lineNumber: parseInt(match[3]),
            columnNumber: parseInt(match[4]),
            raw: line
          };
        } else if (match.length === 4) {
          // Pattern with just location
          return {
            functionName: '<anonymous>',
            fileName: match[1],
            lineNumber: parseInt(match[2]),
            columnNumber: parseInt(match[3]),
            raw: line
          };
        }
      }
    }
    
    // Fallback for unrecognized formats
    return {
      functionName: '<unknown>',
      fileName: '<unknown>',
      lineNumber: 0,
      columnNumber: 0,
      raw: line
    };
  }
  
  async enhanceStackTrace(stackTrace, options = {}) {
    let enhanced = { ...stackTrace };
    
    try {
      // Apply source map enhancement
      if (options.sourceMaps !== false) {
        enhanced = await this.stackEnhancers.enhanceWithSourceMaps(enhanced);
      }
      
      // Add context information
      if (options.context) {
        enhanced = await this.stackEnhancers.enhanceWithContext(enhanced, options.context);
      }
      
      // Add code snippets
      if (options.codeSnippets) {
        enhanced = await this.stackEnhancers.enhanceWithCodeSnippets(enhanced);
      }
      
      // Classify the stack trace
      if (options.classify !== false) {
        enhanced = this.stackEnhancers.enhanceWithClassification(enhanced);
      }
      
      // Add performance information
      if (options.performance) {
        enhanced = this.stackEnhancers.enhanceWithPerformance(enhanced, options.performance);
      }
      
      // Apply filters
      if (options.filters) {
        enhanced = this.applyStackFilters(enhanced, options.filters);
      }
      
      enhanced.processing.enhanced = true;
      enhanced.enhancedAt = new Date().toISOString();
      
      return enhanced;
      
    } catch (error) {
      this.logger.error('Stack trace enhancement failed', {
        stackId: stackTrace.id,
        error: error.message,
        options
      });
      
      return {
        ...stackTrace,
        processing: {
          ...stackTrace.processing,
          enhanced: false,
          enhancementError: error.message
        }
      };
    }
  }
  
  applyStackFilters(stackTrace, filters) {
    let filteredFrames = [...stackTrace.frames];
    
    if (filters.includes('nodeInternals')) {
      filteredFrames = this.stackFilters.filterNodeInternals(filteredFrames);
    }
    
    if (filters.includes('libraries')) {
      filteredFrames = this.stackFilters.filterLibraryFrames(filteredFrames);
    }
    
    if (filters.includes('applicationOnly')) {
      filteredFrames = this.stackFilters.keepApplicationFrames(filteredFrames);
    }
    
    if (filters.includes('duplicates')) {
      filteredFrames = this.stackFilters.removeDuplicates(filteredFrames);
    }
    
    return {
      ...stackTrace,
      frames: filteredFrames,
      processing: {
        ...stackTrace.processing,
        filtered: true,
        filtersApplied: filters,
        originalFrameCount: stackTrace.frames.length,
        filteredFrameCount: filteredFrames.length
      }
    };
  }
  
  logWithStackTrace(level, message, error, options = {}) {
    const stackTrace = this.captureStackTrace(error, options.skipFrames);
    
    // Enhance stack trace if requested
    const enhancePromise = options.enhance ? 
      this.enhanceStackTrace(stackTrace, options) : 
      Promise.resolve(stackTrace);
    
    enhancePromise.then(enhancedStack => {
      const logEntry = {
        message,
        error: error ? {
          name: error.name,
          message: error.message,
          code: error.code
        } : null,
        
        stackTrace: {
          id: enhancedStack.id,
          fingerprint: enhancedStack.fingerprint,
          frames: enhancedStack.frames.slice(0, options.maxFrames || 20),
          totalFrames: enhancedStack.frames.length,
          enhanced: enhancedStack.processing.enhanced,
          classification: enhancedStack.classification
        },
        
        debugging: {
          stackTraceId: enhancedStack.id,
          topFrame: enhancedStack.frames[0],
          userCodeFrame: this.findFirstUserCodeFrame(enhancedStack.frames),
          errorPattern: enhancedStack.classification?.pattern,
          suggestedActions: this.getSuggestedActions(enhancedStack)
        },
        
        metadata: {
          captureTime: enhancedStack.captureTime,
          enhancementTime: enhancedStack.enhancementTime,
          frameCount: enhancedStack.frames.length,
          filtered: enhancedStack.processing.filtered
        },
        
        timestamp: new Date().toISOString(),
        level: level.toUpperCase()
      };
      
      this.logger[level](message, logEntry);
      
      // Store in cache for potential reuse
      this.stackCache.set(enhancedStack.fingerprint, enhancedStack);
      
    }).catch(enhancementError => {
      // Fallback to basic logging if enhancement fails
      this.logger[level](message, {
        error: error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : null,
        enhancementError: enhancementError.message,
        timestamp: new Date().toISOString(),
        level: level.toUpperCase()
      });
    });
  }
  
  async getFrameContext(frame, contextData) {
    return {
      // File context
      file: {
        exists: await this.fileExists(frame.fileName),
        size: await this.getFileSize(frame.fileName),
        lastModified: await this.getFileLastModified(frame.fileName),
        gitInfo: await this.getGitInfo(frame.fileName)
      },
      
      // Function context
      function: {
        name: frame.functionName,
        isAnonymous: frame.functionName === '<anonymous>',
        isNative: frame.fileName.includes('native'),
        isUserCode: this.isUserCode(frame.fileName)
      },
      
      // Runtime context
      runtime: {
        nodeVersion: process.version,
        platform: process.platform,
        architecture: process.arch,
        ...contextData
      }
    };
  }
  
  async getCodeSnippet(fileName, lineNumber, contextLines = 5) {
    try {
      const fs = require('fs').promises;
      const content = await fs.readFile(fileName, 'utf8');
      const lines = content.split('\n');
      
      const startLine = Math.max(0, lineNumber - contextLines - 1);
      const endLine = Math.min(lines.length, lineNumber + contextLines);
      
      const snippet = {
        errorLine: lineNumber,
        startLine: startLine + 1,
        endLine,
        lines: []
      };
      
      for (let i = startLine; i < endLine; i++) {
        snippet.lines.push({
          number: i + 1,
          content: lines[i],
          isErrorLine: i + 1 === lineNumber,
          highlighted: i + 1 === lineNumber
        });
      }
      
      return snippet;
      
    } catch (error) {
      return {
        error: error.message,
        errorLine: lineNumber,
        available: false
      };
    }
  }
  
  categorizeError(stack) {
    const frames = stack.frames;
    const topFrame = frames[0];
    
    if (!topFrame) return 'unknown';
    
    // Network errors
    if (topFrame.fileName.includes('http') || 
        topFrame.fileName.includes('net') ||
        topFrame.functionName.includes('request')) {
      return 'network';
    }
    
    // Database errors
    if (topFrame.fileName.includes('database') ||
        topFrame.fileName.includes('mysql') ||
        topFrame.fileName.includes('postgres') ||
        topFrame.functionName.includes('query')) {
      return 'database';
    }
    
    // File system errors
    if (topFrame.fileName.includes('fs') ||
        topFrame.functionName.includes('readFile') ||
        topFrame.functionName.includes('writeFile')) {
      return 'filesystem';
    }
    
    // Authentication/authorization errors
    if (topFrame.fileName.includes('auth') ||
        topFrame.functionName.includes('authenticate') ||
        topFrame.functionName.includes('authorize')) {
      return 'authentication';
    }
    
    // Validation errors
    if (topFrame.functionName.includes('validate') ||
        topFrame.functionName.includes('check') ||
        topFrame.fileName.includes('validation')) {
      return 'validation';
    }
    
    return 'application';
  }
  
  identifyErrorPattern(stack) {
    const frames = stack.frames;
    
    // Check for recursion
    if (this.detectRecursion(frames).length > 0) {
      return 'recursive_call';
    }
    
    // Check for promise rejection patterns
    if (frames.some(f => f.functionName.includes('Promise'))) {
      return 'promise_rejection';
    }
    
    // Check for callback hell
    if (frames.filter(f => f.functionName.includes('callback')).length > 3) {
      return 'callback_hell';
    }
    
    // Check for async/await pattern
    if (frames.some(f => f.functionName.includes('async'))) {
      return 'async_await';
    }
    
    return 'standard';
  }
  
  assessComplexity(stack) {
    const frameCount = stack.frames.length;
    const uniqueFiles = new Set(stack.frames.map(f => f.fileName)).size;
    const userCodeFrames = stack.frames.filter(f => this.isUserCode(f.fileName)).length;
    
    if (frameCount > 50 || uniqueFiles > 20) return 'high';
    if (frameCount > 20 || uniqueFiles > 10) return 'medium';
    return 'low';
  }
  
  calculateUserCodeRatio(stack) {
    const userCodeFrames = stack.frames.filter(f => this.isUserCode(f.fileName)).length;
    return userCodeFrames / stack.frames.length;
  }
  
  identifyLibraryInvolvement(stack) {
    const libraries = new Set();
    
    stack.frames.forEach(frame => {
      if (frame.fileName.includes('node_modules')) {
        const match = frame.fileName.match(/node_modules\/([^\/]+)/);
        if (match) {
          libraries.add(match[1]);
        }
      }
    });
    
    return Array.from(libraries);
  }
  
  identifyFrameworkInvolvement(stack) {
    const frameworks = ['express', 'koa', 'fastify', 'hapi', 'nestjs'];
    const involved = [];
    
    stack.frames.forEach(frame => {
      frameworks.forEach(framework => {
        if (frame.fileName.includes(framework) || 
            frame.functionName.toLowerCase().includes(framework)) {
          if (!involved.includes(framework)) {
            involved.push(framework);
          }
        }
      });
    });
    
    return involved;
  }
  
  detectRecursion(frames) {
    const functionCounts = {};
    const recursiveFrames = [];
    
    frames.forEach((frame, index) => {
      const key = `${frame.fileName}:${frame.functionName}`;
      
      if (functionCounts[key]) {
        functionCounts[key].count++;
        functionCounts[key].indices.push(index);
      } else {
        functionCounts[key] = { count: 1, indices: [index] };
      }
    });
    
    Object.entries(functionCounts).forEach(([key, data]) => {
      if (data.count > 1) {
        recursiveFrames.push({
          function: key,
          occurrences: data.count,
          indices: data.indices
        });
      }
    });
    
    return recursiveFrames;
  }
  
  identifyHotspots(frames) {
    // Identify frequently called functions
    const functionCounts = {};
    
    frames.forEach(frame => {
      const key = frame.functionName;
      functionCounts[key] = (functionCounts[key] || 0) + 1;
    });
    
    return Object.entries(functionCounts)
      .filter(([, count]) => count > 2)
      .map(([func, count]) => ({ function: func, calls: count }))
      .sort((a, b) => b.calls - a.calls);
  }
  
  identifyBottlenecks(frames) {
    // Simple bottleneck identification based on deep call stacks
    const bottlenecks = [];
    
    for (let i = 0; i < frames.length - 5; i++) {
      const window = frames.slice(i, i + 5);
      const uniqueFunctions = new Set(window.map(f => f.functionName)).size;
      
      if (uniqueFunctions === 1) {
        bottlenecks.push({
          function: window[0].functionName,
          startIndex: i,
          depth: 5
        });
      }
    }
    
    return bottlenecks;
  }
  
  isUserCode(fileName) {
    return !fileName.includes('node_modules') && 
           !fileName.includes('node:') &&
           !fileName.includes('internal/') &&
           fileName.startsWith('/') &&
           !fileName.includes('.min.');
  }
  
  findFirstUserCodeFrame(frames) {
    return frames.find(frame => this.isUserCode(frame.fileName));
  }
  
  getSuggestedActions(stack) {
    const actions = [];
    
    if (stack.classification?.category === 'network') {
      actions.push('Check network connectivity and service availability');
      actions.push('Implement retry logic with exponential backoff');
    }
    
    if (stack.classification?.category === 'database') {
      actions.push('Verify database connection and query syntax');
      actions.push('Check database logs for additional error details');
    }
    
    if (stack.classification?.pattern === 'recursive_call') {
      actions.push('Review recursive function for proper termination conditions');
      actions.push('Consider iterative alternatives to reduce stack depth');
    }
    
    if (stack.classification?.complexity === 'high') {
      actions.push('Consider breaking down complex operations into smaller functions');
      actions.push('Review error handling and propagation strategies');
    }
    
    return actions;
  }
  
  generateStackId() {
    return `stack_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  generateStackFingerprint(frames) {
    // Create a fingerprint based on the top frames
    const topFrames = frames.slice(0, 5);
    const signature = topFrames.map(f => 
      `${f.functionName}:${f.fileName.split('/').pop()}:${f.lineNumber}`
    ).join('|');
    
    return require('crypto')
      .createHash('md5')
      .update(signature)
      .digest('hex');
  }
  
  // Utility methods for file operations
  async fileExists(fileName) {
    try {
      await require('fs').promises.access(fileName);
      return true;
    } catch {
      return false;
    }
  }
  
  async getFileSize(fileName) {
    try {
      const stats = await require('fs').promises.stat(fileName);
      return stats.size;
    } catch {
      return null;
    }
  }
  
  async getFileLastModified(fileName) {
    try {
      const stats = await require('fs').promises.stat(fileName);
      return stats.mtime.toISOString();
    } catch {
      return null;
    }
  }
  
  async getGitInfo(fileName) {
    // Mock implementation - would use git commands in practice
    return {
      branch: 'main',
      commit: 'abc123def456',
      author: 'developer@example.com',
      lastModified: '2024-01-15T10:30:00Z'
    };
  }
  
  getStackTraceStatistics() {
    return {
      totalCaptured: this.stackCache.size,
      cacheSize: this.estimateCacheSize(),
      topErrorPatterns: this.getTopErrorPatterns(),
      topErrorCategories: this.getTopErrorCategories()
    };
  }
  
  estimateCacheSize() {
    let size = 0;
    this.stackCache.forEach(stack => {
      size += JSON.stringify(stack).length;
    });
    return size;
  }
  
  getTopErrorPatterns() {
    const patterns = {};
    this.stackCache.forEach(stack => {
      if (stack.classification?.pattern) {
        patterns[stack.classification.pattern] = 
          (patterns[stack.classification.pattern] || 0) + 1;
      }
    });
    
    return Object.entries(patterns)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);
  }
  
  getTopErrorCategories() {
    const categories = {};
    this.stackCache.forEach(stack => {
      if (stack.classification?.category) {
        categories[stack.classification.category] = 
          (categories[stack.classification.category] || 0) + 1;
      }
    });
    
    return Object.entries(categories)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5);
  }
}
```

### 2. **Stack Trace Formatting and Presentation**
Advanced formatting options for different output formats and debugging scenarios.

```javascript
// Stack trace formatting and presentation
class StackTraceFormatter {
  constructor(logger) {
    this.logger = logger.child({ component: 'StackTraceFormatter' });
    this.formatters = this.setupFormatters();
    this.themes = this.setupThemes();
    this.outputTargets = this.setupOutputTargets();
  }
  
  setupFormatters() {
    return {
      // Compact format for production logs
      compact: (stackTrace) => {
        const topFrame = stackTrace.frames[0];
        const userFrame = stackTrace.frames.find(f => this.isUserCode(f.fileName));
        
        return {
          summary: `${stackTrace.error?.name || 'Error'}: ${stackTrace.error?.message || 'Unknown error'}`,
          location: userFrame ? `${userFrame.fileName}:${userFrame.lineNumber}` : 'Unknown location',
          frames: stackTrace.frames.length,
          fingerprint: stackTrace.fingerprint,
          category: stackTrace.classification?.category,
          pattern: stackTrace.classification?.pattern
        };
      },
      
      // Detailed format for development
      detailed: (stackTrace) => {
        return {
          error: stackTrace.error,
          classification: stackTrace.classification,
          performance: stackTrace.performance,
          frames: stackTrace.frames.map(frame => ({
            function: frame.functionName,
            location: `${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}`,
            isUserCode: this.isUserCode(frame.fileName),
            context: frame.context,
            codeSnippet: frame.codeSnippet
          })),
          metadata: {
            capturedAt: stackTrace.capturedAt,
            enhanced: stackTrace.processing.enhanced,
            frameCount: stackTrace.frames.length
          }
        };
      },
      
      // JSON format for structured logging
      json: (stackTrace) => {
        return JSON.stringify({
          stackTrace: {
            id: stackTrace.id,
            error: stackTrace.error,
            frames: stackTrace.frames,
            classification: stackTrace.classification,
            processing: stackTrace.processing,
            metadata: {
              capturedAt: stackTrace.capturedAt,
              fingerprint: stackTrace.fingerprint
            }
          }
        }, null, 2);
      },
      
      // Human-readable format with colors
      pretty: (stackTrace, theme = 'default') => {
        const colors = this.themes[theme];
        let output = '';
        
        // Error header
        if (stackTrace.error) {
          output += `${colors.error}${stackTrace.error.name}: ${stackTrace.error.message}${colors.reset}\n`;
        }
        
        // Classification info
        if (stackTrace.classification) {
          output += `${colors.info}Category: ${stackTrace.classification.category}, `;
          output += `Pattern: ${stackTrace.classification.pattern}${colors.reset}\n`;
        }
        
        // Stack frames
        output += `${colors.header}Stack Trace:${colors.reset}\n`;
        
        stackTrace.frames.forEach((frame, index) => {
          const isUserCode = this.isUserCode(frame.fileName);
          const color = isUserCode ? colors.userCode : colors.systemCode;
          
          output += `${color}  ${index + 1}. ${frame.functionName} `;
          output += `(${frame.fileName}:${frame.lineNumber}:${frame.columnNumber})${colors.reset}\n`;
          
          // Add code snippet if available
          if (frame.codeSnippet && frame.codeSnippet.lines) {
            frame.codeSnippet.lines.forEach(line => {
              const lineColor = line.isErrorLine ? colors.errorLine : colors.codeLine;
              output += `${lineColor}    ${line.number}: ${line.content}${colors.reset}\n`;
            });
          }
        });
        
        return output;
      },
      
      // Markdown format for documentation
      markdown: (stackTrace) => {
        let md = '';
        
        // Error information
        if (stackTrace.error) {
          md += `## Error: ${stackTrace.error.name}\n\n`;
          md += `**Message:** ${stackTrace.error.message}\n\n`;
        }
        
        // Classification
        if (stackTrace.classification) {
          md += `**Category:** ${stackTrace.classification.category}\n`;
          md += `**Pattern:** ${stackTrace.classification.pattern}\n`;
          md += `**Complexity:** ${stackTrace.classification.complexity}\n\n`;
        }
        
        // Stack frames
        md += `## Stack Trace\n\n`;
        md += `Total frames: ${stackTrace.frames.length}\n\n`;
        
        stackTrace.frames.forEach((frame, index) => {
          md += `### Frame ${index + 1}\n\n`;
          md += `- **Function:** \`${frame.functionName}\`\n`;
          md += `- **Location:** \`${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}\`\n`;
          md += `- **User Code:** ${this.isUserCode(frame.fileName) ? 'Yes' : 'No'}\n`;
          
          if (frame.codeSnippet && frame.codeSnippet.lines) {
            md += `\n**Code Context:**\n\n\`\`\`javascript\n`;
            frame.codeSnippet.lines.forEach(line => {
              const marker = line.isErrorLine ? '>>> ' : '    ';
              md += `${marker}${line.number}: ${line.content}\n`;
            });
            md += `\`\`\`\n\n`;
          }
        });
        
        return md;
      },
      
      // HTML format for web display
      html: (stackTrace) => {
        let html = '<div class="stack-trace">';
        
        // Error header
        if (stackTrace.error) {
          html += `<div class="error-header">`;
          html += `<h3>${stackTrace.error.name}: ${stackTrace.error.message}</h3>`;
          html += `</div>`;
        }
        
        // Classification info
        if (stackTrace.classification) {
          html += `<div class="classification">`;
          html += `<span class="category">Category: ${stackTrace.classification.category}</span>`;
          html += `<span class="pattern">Pattern: ${stackTrace.classification.pattern}</span>`;
          html += `</div>`;
        }
        
        // Stack frames
        html += `<div class="frames">`;
        stackTrace.frames.forEach((frame, index) => {
          const userCode = this.isUserCode(frame.fileName);
          const frameClass = userCode ? 'user-code' : 'system-code';
          
          html += `<div class="frame ${frameClass}">`;
          html += `<div class="frame-header">`;
          html += `<span class="index">${index + 1}.</span>`;
          html += `<span class="function">${frame.functionName}</span>`;
          html += `<span class="location">${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}</span>`;
          html += `</div>`;
          
          // Code snippet
          if (frame.codeSnippet && frame.codeSnippet.lines) {
            html += `<div class="code-snippet">`;
            frame.codeSnippet.lines.forEach(line => {
              const lineClass = line.isErrorLine ? 'error-line' : 'code-line';
              html += `<div class="${lineClass}">`;
              html += `<span class="line-number">${line.number}</span>`;
              html += `<span class="line-content">${this.escapeHtml(line.content)}</span>`;
              html += `</div>`;
            });
            html += `</div>`;
          }
          
          html += `</div>`;
        });
        html += `</div>`;
        
        html += '</div>';
        return html;
      }
    };
  }
  
  setupThemes() {
    return {
      default: {
        error: '\x1b[31m',      // Red
        info: '\x1b[36m',       // Cyan
        header: '\x1b[1m',      // Bold
        userCode: '\x1b[33m',   // Yellow
        systemCode: '\x1b[90m', // Dark gray
        errorLine: '\x1b[41m',  // Red background
        codeLine: '\x1b[37m',   // White
        reset: '\x1b[0m'        // Reset
      },
      
      dark: {
        error: '\x1b[91m',      // Bright red
        info: '\x1b[96m',       // Bright cyan
        header: '\x1b[1;37m',   // Bold white
        userCode: '\x1b[93m',   // Bright yellow
        systemCode: '\x1b[37m', // Light gray
        errorLine: '\x1b[101m', // Bright red background
        codeLine: '\x1b[97m',   // Bright white
        reset: '\x1b[0m'
      },
      
      minimal: {
        error: '',
        info: '',
        header: '',
        userCode: '',
        systemCode: '',
        errorLine: '',
        codeLine: '',
        reset: ''
      }
    };
  }
  
  setupOutputTargets() {
    return {
      // Console output with colors
      console: (formattedStack, options = {}) => {
        const theme = options.theme || 'default';
        if (options.format === 'pretty') {
          console.log(this.formatters.pretty(formattedStack, theme));
        } else {
          console.log(JSON.stringify(this.formatters.compact(formattedStack), null, 2));
        }
      },
      
      // File output
      file: async (formattedStack, options = {}) => {
        const fs = require('fs').promises;
        const format = options.format || 'json';
        const fileName = options.fileName || `stack-trace-${Date.now()}.log`;
        
        let content;
        switch (format) {
          case 'json':
            content = this.formatters.json(formattedStack);
            break;
          case 'markdown':
            content = this.formatters.markdown(formattedStack);
            break;
          default:
            content = JSON.stringify(this.formatters.detailed(formattedStack), null, 2);
        }
        
        await fs.writeFile(fileName, content, 'utf8');
        return fileName;
      },
      
      // HTTP endpoint
      http: async (formattedStack, options = {}) => {
        const endpoint = options.endpoint;
        if (!endpoint) throw new Error('HTTP endpoint required');
        
        const payload = {
          stackTrace: this.formatters.detailed(formattedStack),
          timestamp: new Date().toISOString(),
          source: options.source || 'application'
        };
        
        // Mock HTTP request - in practice, would use fetch or axios
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            console.log(`Would send to ${endpoint}:`, payload);
            resolve({ success: true, endpoint });
          }, 100);
        });
      },
      
      // Database storage
      database: async (formattedStack, options = {}) => {
        // Mock database storage
        const record = {
          id: formattedStack.id,
          fingerprint: formattedStack.fingerprint,
          error_name: formattedStack.error?.name,
          error_message: formattedStack.error?.message,
          category: formattedStack.classification?.category,
          pattern: formattedStack.classification?.pattern,
          frame_count: formattedStack.frames.length,
          raw_stack: JSON.stringify(formattedStack),
          created_at: new Date().toISOString()
        };
        
        console.log('Would store in database:', record);
        return { success: true, id: record.id };
      }
    };
  }
  
  format(stackTrace, formatType = 'compact', options = {}) {
    const formatter = this.formatters[formatType];
    if (!formatter) {
      throw new Error(`Unknown format type: ${formatType}`);
    }
    
    try {
      return formatter(stackTrace, options.theme);
    } catch (error) {
      this.logger.error('Stack trace formatting failed', {
        formatType,
        error: error.message,
        stackId: stackTrace.id
      });
      
      // Fallback to basic format
      return this.formatters.compact(stackTrace);
    }
  }
  
  async output(stackTrace, target = 'console', options = {}) {
    const outputHandler = this.outputTargets[target];
    if (!outputHandler) {
      throw new Error(`Unknown output target: ${target}`);
    }
    
    // Format stack trace
    const formatType = options.format || 'compact';
    const formatted = this.format(stackTrace, formatType, options);
    
    try {
      return await outputHandler(stackTrace, { ...options, formatted });
    } catch (error) {
      this.logger.error('Stack trace output failed', {
        target,
        error: error.message,
        stackId: stackTrace.id
      });
      
      // Fallback to console
      if (target !== 'console') {
        return await this.outputTargets.console(stackTrace, options);
      }
      
      throw error;
    }
  }
  
  formatAndLog(level, stackTrace, options = {}) {
    const formatType = options.format || 'detailed';
    const formatted = this.format(stackTrace, formatType, options);
    
    const logEntry = {
      message: `Stack trace captured: ${stackTrace.error?.name || 'Unknown error'}`,
      stackTrace: formatted,
      metadata: {
        stackId: stackTrace.id,
        formatType,
        enhanced: stackTrace.processing.enhanced,
        frameCount: stackTrace.frames.length
      },
      timestamp: new Date().toISOString(),
      level: level.toUpperCase()
    };
    
    this.logger[level](logEntry.message, logEntry);
    return logEntry;
  }
  
  isUserCode(fileName) {
    return !fileName.includes('node_modules') && 
           !fileName.includes('node:') &&
           !fileName.includes('internal/') &&
           fileName.startsWith('/') &&
           !fileName.includes('.min.');
  }
  
  escapeHtml(text) {
    const escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    
    return text.replace(/[&<>"']/g, char => escapeMap[char]);
  }
  
  generateCSS() {
    return `
      .stack-trace {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 12px;
        line-height: 1.4;
        background: #f8f8f8;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 16px;
        max-width: 100%;
        overflow-x: auto;
      }
      
      .error-header h3 {
        margin: 0 0 12px 0;
        color: #d73a49;
        font-size: 14px;
        font-weight: 600;
      }
      
      .classification {
        margin-bottom: 16px;
        padding: 8px;
        background: #f1f8ff;
        border-left: 3px solid #0366d6;
        border-radius: 3px;
      }
      
      .classification span {
        margin-right: 16px;
        font-size: 11px;
        color: #586069;
      }
      
      .frame {
        margin-bottom: 12px;
        border-left: 2px solid #e1e4e8;
        padding-left: 12px;
      }
      
      .frame.user-code {
        border-left-color: #f66a0a;
        background: #fff8f0;
      }
      
      .frame-header {
        margin-bottom: 4px;
      }
      
      .index {
        color: #6a737d;
        margin-right: 8px;
      }
      
      .function {
        font-weight: 600;
        color: #005cc5;
        margin-right: 8px;
      }
      
      .location {
        color: #6a737d;
        font-size: 11px;
      }
      
      .code-snippet {
        margin-top: 8px;
        background: #f6f8fa;
        border-radius: 3px;
        overflow-x: auto;
      }
      
      .code-line, .error-line {
        padding: 2px 8px;
        white-space: pre;
      }
      
      .error-line {
        background: #ffeef0;
        border-left: 3px solid #d73a49;
      }
      
      .line-number {
        color: #6a737d;
        margin-right: 12px;
        min-width: 30px;
        display: inline-block;
        text-align: right;
      }
      
      .line-content {
        color: #24292e;
      }
    `;
  }
}
```

## Integration Example

### **Complete Stack Trace Logging System**
```javascript
// Complete integration example
class StackTraceLoggingSystem {
  constructor(logger) {
    this.logger = logger;
    this.analyzer = new StackTraceAnalyzer(logger);
    this.formatter = new StackTraceFormatter(logger);
  }
  
  async logError(error, context = {}, options = {}) {
    try {
      // Capture enhanced stack trace
      const stackTrace = this.analyzer.captureStackTrace(error);
      const enhanced = await this.analyzer.enhanceStackTrace(stackTrace, {
        sourceMaps: true,
        context: context,
        codeSnippets: true,
        classify: true,
        performance: true,
        filters: ['nodeInternals', 'duplicates']
      });
      
      // Format for different outputs
      const compactFormat = this.formatter.format(enhanced, 'compact');
      const detailedFormat = this.formatter.format(enhanced, 'detailed');
      
      // Log with structured format
      this.logger.error('Application error occurred', {
        error: {
          name: error.name,
          message: error.message,
          code: error.code
        },
        stackTrace: compactFormat,
        context,
        debugging: {
          stackId: enhanced.id,
          fingerprint: enhanced.fingerprint,
          category: enhanced.classification?.category,
          pattern: enhanced.classification?.pattern,
          userCodeFrame: this.analyzer.findFirstUserCodeFrame(enhanced.frames),
          suggestedActions: this.analyzer.getSuggestedActions(enhanced)
        },
        timestamp: new Date().toISOString()
      });
      
      // Output detailed version for development
      if (process.env.NODE_ENV === 'development') {
        await this.formatter.output(enhanced, 'console', {
          format: 'pretty',
          theme: 'default'
        });
      }
      
      // Store in database for analysis
      if (options.store) {
        await this.formatter.output(enhanced, 'database');
      }
      
      return enhanced;
      
    } catch (analysisError) {
      // Fallback to basic error logging
      this.logger.error('Error analysis failed', {
        originalError: {
          name: error.name,
          message: error.message,
          stack: error.stack
        },
        analysisError: analysisError.message,
        context
      });
    }
  }
}

// Usage example
const system = new StackTraceLoggingSystem(logger);

try {
  // Some operation that might fail
  throw new Error('Something went wrong');
} catch (error) {
  system.logError(error, {
    userId: 'user123',
    operation: 'data_processing',
    requestId: 'req_456'
  }, {
    store: true
  });
}
```

---

**Previous**: [2.2.6 Context Information](./2.2.6_Context_Information.md)  
**Next**: [2.3 Logger Configuration](../2.3_Logger_Configuration/README.md)
