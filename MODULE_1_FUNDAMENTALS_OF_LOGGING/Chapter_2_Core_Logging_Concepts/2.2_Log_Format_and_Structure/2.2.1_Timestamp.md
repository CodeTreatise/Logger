# 2.2.1 Timestamp

## Understanding Timestamps in Logging

Timestamps are fundamental components of log entries that provide temporal context to events. They enable chronological ordering, event correlation, performance analysis, and debugging by establishing when specific events occurred. Proper timestamp implementation is crucial for effective log analysis, troubleshooting, and system monitoring.

## Timestamp Formats and Standards

### 1. **ISO 8601 Standard (Recommended)**
The ISO 8601 standard provides a universal, unambiguous timestamp format that ensures consistency across systems.

```javascript
// ISO 8601 timestamp implementation
class ISO8601TimestampLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'ISO8601TimestampLogger' });
    this.timestampFormatter = this.setupTimestampFormatter();
  }
  
  setupTimestampFormatter() {
    return {
      // Basic ISO 8601 format
      basic: () => new Date().toISOString(),
      
      // ISO 8601 with milliseconds
      withMilliseconds: () => {
        const now = new Date();
        return now.toISOString();
      },
      
      // ISO 8601 with microseconds (simulation)
      withMicroseconds: () => {
        const now = new Date();
        const microseconds = Math.floor(Math.random() * 1000);
        return now.toISOString().replace('Z', `${microseconds.toString().padStart(3, '0')}Z`);
      },
      
      // ISO 8601 with timezone
      withTimezone: (timezone = 'UTC') => {
        const now = new Date();
        if (timezone === 'UTC') {
          return now.toISOString();
        }
        return now.toLocaleString('sv-SE', { timeZone: timezone }).replace(' ', 'T') + this.getTimezoneOffset(timezone);
      },
      
      // ISO 8601 with custom precision
      withCustomPrecision: (precision = 'milliseconds') => {
        const now = new Date();
        const iso = now.toISOString();
        
        switch (precision) {
          case 'seconds':
            return iso.split('.')[0] + 'Z';
          case 'milliseconds':
            return iso;
          case 'microseconds':
            // Simulate microsecond precision
            const microseconds = Math.floor(Math.random() * 1000);
            return iso.replace(/(\.\d{3})Z$/, `$1${microseconds.toString().padStart(3, '0')}Z`);
          default:
            return iso;
        }
      }
    };
  }
  
  logWithTimestamp(level, message, data = {}, timestampFormat = 'basic') {
    const timestamp = this.timestampFormatter[timestampFormat]();
    
    const logEntry = {
      timestamp,
      level: level.toUpperCase(),
      message,
      ...data,
      
      // Timestamp metadata
      timestampMetadata: {
        format: timestampFormat,
        precision: this.getTimestampPrecision(timestamp),
        timezone: this.extractTimezone(timestamp),
        epochMilliseconds: Date.now(),
        epochNanoseconds: process.hrtime.bigint(),
        clockSource: 'system',
        accuracy: this.getClockAccuracy()
      }
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  // Comprehensive timestamp examples
  demonstrateTimestampFormats() {
    const examples = {
      // Standard ISO 8601 formats
      basic: this.timestampFormatter.basic(),
      withMilliseconds: this.timestampFormatter.withMilliseconds(),
      withMicroseconds: this.timestampFormatter.withMicroseconds(),
      
      // Timezone variations
      utc: this.timestampFormatter.withTimezone('UTC'),
      easternTime: this.timestampFormatter.withTimezone('America/New_York'),
      pacificTime: this.timestampFormatter.withTimezone('America/Los_Angeles'),
      london: this.timestampFormatter.withTimezone('Europe/London'),
      tokyo: this.timestampFormatter.withTimezone('Asia/Tokyo'),
      
      // Precision variations
      secondPrecision: this.timestampFormatter.withCustomPrecision('seconds'),
      millisecondPrecision: this.timestampFormatter.withCustomPrecision('milliseconds'),
      microsecondPrecision: this.timestampFormatter.withCustomPrecision('microseconds')
    };
    
    this.logger.info('Timestamp format examples', {
      examples,
      formatComparison: this.compareTimestampFormats(examples),
      recommendations: this.getTimestampRecommendations()
    });
    
    return examples;
  }
  
  getTimestampPrecision(timestamp) {
    if (timestamp.includes('.')) {
      const fractionalPart = timestamp.split('.')[1].replace('Z', '');
      if (fractionalPart.length >= 6) return 'microseconds';
      if (fractionalPart.length >= 3) return 'milliseconds';
      return 'seconds';
    }
    return 'seconds';
  }
  
  extractTimezone(timestamp) {
    if (timestamp.endsWith('Z')) return 'UTC';
    const match = timestamp.match(/([+-]\d{2}:\d{2})$/);
    return match ? match[1] : 'local';
  }
  
  getClockAccuracy() {
    // Simulate clock accuracy assessment
    return {
      source: 'NTP',
      driftRate: '±0.5ms/hour',
      lastSync: new Date(Date.now() - Math.random() * 3600000).toISOString(),
      accuracy: '±1ms'
    };
  }
}
```

### 2. **Unix Timestamp Formats**
Unix timestamps provide precise, numeric time representation.

```javascript
// Unix timestamp implementation
class UnixTimestampLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'UnixTimestampLogger' });
    this.epochReference = new Date('1970-01-01T00:00:00.000Z');
  }
  
  generateUnixTimestamps() {
    const now = new Date();
    
    return {
      // Unix timestamp in seconds
      epochSeconds: Math.floor(now.getTime() / 1000),
      
      // Unix timestamp in milliseconds
      epochMilliseconds: now.getTime(),
      
      // Unix timestamp in microseconds (simulated)
      epochMicroseconds: now.getTime() * 1000 + Math.floor(Math.random() * 1000),
      
      // Unix timestamp in nanoseconds (Node.js high-resolution time)
      epochNanoseconds: process.hrtime.bigint(),
      
      // Float representation with fractional seconds
      epochFloat: now.getTime() / 1000,
      
      // String representation for precision
      epochString: (now.getTime() / 1000).toFixed(6)
    };
  }
  
  logWithUnixTimestamp(level, message, data = {}) {
    const timestamps = this.generateUnixTimestamps();
    
    const logEntry = {
      ...timestamps,
      level: level.toUpperCase(),
      message,
      ...data,
      
      // Unix timestamp metadata
      timestampInfo: {
        epochReference: this.epochReference.toISOString(),
        currentEpoch: timestamps.epochSeconds,
        uptime: process.uptime(),
        hrtime: process.hrtime(),
        clockResolution: this.getClockResolution(),
        platformSpecific: this.getPlatformTimestampInfo()
      }
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  getClockResolution() {
    // Measure clock resolution
    const start = process.hrtime.bigint();
    const measurements = [];
    
    for (let i = 0; i < 1000; i++) {
      measurements.push(process.hrtime.bigint() - start);
    }
    
    const minResolution = measurements.reduce((min, curr) => curr < min && curr > 0n ? curr : min, BigInt(Number.MAX_SAFE_INTEGER));
    
    return {
      nanoseconds: Number(minResolution),
      microseconds: Number(minResolution) / 1000,
      milliseconds: Number(minResolution) / 1000000,
      description: `~${Number(minResolution)}ns resolution`
    };
  }
  
  getPlatformTimestampInfo() {
    return {
      platform: process.platform,
      nodeVersion: process.version,
      v8Version: process.versions.v8,
      timezoneOffset: new Date().getTimezoneOffset(),
      locale: Intl.DateTimeFormat().resolvedOptions(),
      systemUptime: require('os').uptime(),
      loadAverage: require('os').loadavg()
    };
  }
}
```

### 3. **Custom Timestamp Formats**
Application-specific timestamp formats for specialized use cases.

```javascript
// Custom timestamp formats
class CustomTimestampLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'CustomTimestampLogger' });
    this.customFormatters = this.setupCustomFormatters();
  }
  
  setupCustomFormatters() {
    return {
      // Human-readable format
      humanReadable: () => {
        const now = new Date();
        return now.toLocaleString('en-US', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          timeZoneName: 'short'
        });
      },
      
      // Compact format for space-constrained logs
      compact: () => {
        const now = new Date();
        const year = now.getFullYear().toString().slice(-2);
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hour = now.getHours().toString().padStart(2, '0');
        const minute = now.getMinutes().toString().padStart(2, '0');
        const second = now.getSeconds().toString().padStart(2, '0');
        const ms = now.getMilliseconds().toString().padStart(3, '0');
        
        return `${year}${month}${day}${hour}${minute}${second}${ms}`;
      },
      
      // Log-specific format with sequence
      logSequence: (() => {
        let sequence = 0;
        return () => {
          sequence++;
          const now = new Date();
          return `${now.getTime()}.${sequence.toString().padStart(6, '0')}`;
        };
      })(),
      
      // Business day format (excluding weekends/holidays)
      businessTime: () => {
        const now = new Date();
        const dayOfWeek = now.getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
        const isBusinessHours = now.getHours() >= 9 && now.getHours() < 17;
        
        return {
          timestamp: now.toISOString(),
          businessDay: !isWeekend,
          businessHours: isBusinessHours,
          dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek],
          quarter: Math.floor((now.getMonth() + 3) / 3),
          fiscalYear: now.getMonth() >= 9 ? now.getFullYear() + 1 : now.getFullYear()
        };
      },
      
      // High-resolution with performance context
      highResolution: () => {
        const now = new Date();
        const hrTime = process.hrtime.bigint();
        const cpuUsage = process.cpuUsage();
        const memUsage = process.memoryUsage();
        
        return {
          iso: now.toISOString(),
          epochNs: hrTime.toString(),
          performanceNow: performance.now(),
          cpuUser: cpuUsage.user,
          cpuSystem: cpuUsage.system,
          memoryRSS: memUsage.rss,
          memoryHeapUsed: memUsage.heapUsed,
          uptime: process.uptime()
        };
      },
      
      // Distributed system format with node information
      distributed: () => {
        const now = new Date();
        const nodeInfo = {
          nodeId: process.env.NODE_ID || require('os').hostname(),
          processId: process.pid,
          instanceId: process.env.INSTANCE_ID || `${require('os').hostname()}-${process.pid}`,
          region: process.env.AWS_REGION || process.env.REGION || 'local',
          availabilityZone: process.env.AWS_AVAILABILITY_ZONE || 'local-az',
          version: process.env.APP_VERSION || require('../../package.json')?.version || '1.0.0'
        };
        
        return {
          timestamp: now.toISOString(),
          epoch: now.getTime(),
          ...nodeInfo,
          logicalClock: this.getLogicalClock(),
          vectorClock: this.getVectorClock()
        };
      }
    };
  }
  
  logWithCustomTimestamp(level, message, data = {}, format = 'humanReadable') {
    const timestamp = this.customFormatters[format]();
    
    const logEntry = {
      customTimestamp: timestamp,
      level: level.toUpperCase(),
      message,
      ...data,
      
      // Custom timestamp metadata
      timestampMetadata: {
        format,
        generatedAt: new Date().toISOString(),
        customFormatVersion: '1.0',
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        locale: Intl.DateTimeFormat().resolvedOptions().locale
      }
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  getLogicalClock() {
    // Lamport logical clock simulation
    if (!this.logicalClockValue) {
      this.logicalClockValue = 0;
    }
    return ++this.logicalClockValue;
  }
  
  getVectorClock() {
    // Vector clock simulation for distributed systems
    const nodeId = process.env.NODE_ID || require('os').hostname();
    if (!this.vectorClock) {
      this.vectorClock = { [nodeId]: 0 };
    }
    this.vectorClock[nodeId]++;
    return { ...this.vectorClock };
  }
}
```

## Timestamp Precision and Performance

### 1. **Precision Requirements Analysis**
```javascript
// Timestamp precision analysis
class TimestampPrecisionAnalyzer {
  constructor(logger) {
    this.logger = logger.child({ component: 'TimestampPrecisionAnalyzer' });
    this.precisionRequirements = this.definePrecisionRequirements();
  }
  
  definePrecisionRequirements() {
    return {
      // Use case based precision requirements
      useCases: {
        businessLogging: {
          minimumPrecision: 'seconds',
          recommendedPrecision: 'milliseconds',
          description: 'User actions, business events, transactions'
        },
        
        performanceMonitoring: {
          minimumPrecision: 'milliseconds',
          recommendedPrecision: 'microseconds',
          description: 'Response times, latency measurements, throughput'
        },
        
        debugging: {
          minimumPrecision: 'milliseconds',
          recommendedPrecision: 'nanoseconds',
          description: 'Code execution flow, algorithm analysis'
        },
        
        securityAuditing: {
          minimumPrecision: 'milliseconds',
          recommendedPrecision: 'milliseconds',
          description: 'Authentication, authorization, security events'
        },
        
        systemMonitoring: {
          minimumPrecision: 'seconds',
          recommendedPrecision: 'milliseconds',
          description: 'Resource usage, health checks, alerts'
        },
        
        distributedTracing: {
          minimumPrecision: 'microseconds',
          recommendedPrecision: 'nanoseconds',
          description: 'Service-to-service calls, request tracing'
        },
        
        financialTransactions: {
          minimumPrecision: 'milliseconds',
          recommendedPrecision: 'microseconds',
          description: 'Trading, payments, financial operations'
        },
        
        complianceLogging: {
          minimumPrecision: 'seconds',
          recommendedPrecision: 'milliseconds',
          description: 'Regulatory compliance, audit trails'
        }
      },
      
      // Performance impact analysis
      performanceImpact: {
        seconds: {
          overhead: 'minimal',
          cpuImpact: '< 0.1%',
          memoryImpact: 'negligible',
          storageImpact: 'low'
        },
        
        milliseconds: {
          overhead: 'low',
          cpuImpact: '< 0.5%',
          memoryImpact: 'minimal',
          storageImpact: 'medium'
        },
        
        microseconds: {
          overhead: 'medium',
          cpuImpact: '1-2%',
          memoryImpact: 'low',
          storageImpact: 'high'
        },
        
        nanoseconds: {
          overhead: 'high',
          cpuImpact: '2-5%',
          memoryImpact: 'medium',
          storageImpact: 'very high'
        }
      }
    };
  }
  
  analyzeTimestampRequirements(useCase, volume, performance) {
    const requirements = this.precisionRequirements.useCases[useCase];
    const impact = this.precisionRequirements.performanceImpact[requirements?.recommendedPrecision] || {};
    
    const analysis = {
      useCase,
      requirements,
      recommendations: {
        precision: this.selectOptimalPrecision(useCase, volume, performance),
        format: this.selectOptimalFormat(useCase, volume, performance),
        implementation: this.getImplementationRecommendations(useCase, volume, performance)
      },
      performanceImpact: impact,
      volumeConsiderations: this.analyzeVolumeImpact(volume, requirements?.recommendedPrecision),
      alternatives: this.getAlternativeOptions(useCase, volume, performance)
    };
    
    this.logger.info('Timestamp requirements analysis', analysis);
    return analysis;
  }
  
  selectOptimalPrecision(useCase, volume, performance) {
    const requirements = this.precisionRequirements.useCases[useCase];
    if (!requirements) return 'milliseconds';
    
    // High volume systems may need to reduce precision
    if (volume > 100000) { // > 100k logs per second
      if (requirements.recommendedPrecision === 'nanoseconds') return 'microseconds';
      if (requirements.recommendedPrecision === 'microseconds') return 'milliseconds';
    }
    
    // Performance-critical systems may need to reduce precision
    if (performance === 'critical') {
      if (requirements.recommendedPrecision === 'nanoseconds') return 'microseconds';
      if (requirements.recommendedPrecision === 'microseconds') return 'milliseconds';
    }
    
    return requirements.recommendedPrecision;
  }
  
  measureTimestampPerformance() {
    const iterations = 100000;
    const measurements = {};
    
    // Measure different timestamp generation methods
    const methods = {
      'new Date().toISOString()': () => new Date().toISOString(),
      'Date.now()': () => Date.now(),
      'process.hrtime.bigint()': () => process.hrtime.bigint(),
      'performance.now()': () => performance.now(),
      'new Date().getTime()': () => new Date().getTime()
    };
    
    for (const [name, method] of Object.entries(methods)) {
      const start = process.hrtime.bigint();
      
      for (let i = 0; i < iterations; i++) {
        method();
      }
      
      const end = process.hrtime.bigint();
      const durationNs = Number(end - start);
      
      measurements[name] = {
        totalTimeNs: durationNs,
        avgTimeNs: durationNs / iterations,
        avgTimeMicros: (durationNs / iterations) / 1000,
        avgTimeMs: (durationNs / iterations) / 1000000,
        operationsPerSecond: Math.floor((iterations * 1000000000) / durationNs)
      };
    }
    
    this.logger.info('Timestamp performance measurements', {
      iterations,
      measurements,
      recommendations: this.getPerformanceRecommendations(measurements)
    });
    
    return measurements;
  }
}
```

## Timezone Handling

### 1. **Timezone Management**
```javascript
// Comprehensive timezone handling
class TimezoneManager {
  constructor(logger) {
    this.logger = logger.child({ component: 'TimezoneManager' });
    this.timezoneConfig = this.setupTimezoneConfiguration();
  }
  
  setupTimezoneConfiguration() {
    return {
      // Default timezone settings
      default: {
        application: 'UTC',
        logging: 'UTC',
        display: 'local',
        storage: 'UTC'
      },
      
      // Timezone conversion rules
      conversionRules: {
        'always_utc': {
          description: 'Always log in UTC',
          implementation: (date) => date.toISOString()
        },
        
        'preserve_local': {
          description: 'Preserve local timezone information',
          implementation: (date) => {
            const offset = date.getTimezoneOffset();
            const offsetHours = Math.floor(Math.abs(offset) / 60);
            const offsetMinutes = Math.abs(offset) % 60;
            const offsetSign = offset <= 0 ? '+' : '-';
            return date.toISOString().replace('Z', `${offsetSign}${offsetHours.toString().padStart(2, '0')}:${offsetMinutes.toString().padStart(2, '0')}`);
          }
        },
        
        'business_timezone': {
          description: 'Convert to business timezone',
          implementation: (date, businessTz = 'America/New_York') => {
            return date.toLocaleString('sv-SE', { timeZone: businessTz }).replace(' ', 'T') + this.getTimezoneOffset(businessTz);
          }
        }
      },
      
      // Common timezone mappings
      commonTimezones: {
        'UTC': 'Coordinated Universal Time',
        'America/New_York': 'Eastern Time (US & Canada)',
        'America/Chicago': 'Central Time (US & Canada)',
        'America/Denver': 'Mountain Time (US & Canada)',
        'America/Los_Angeles': 'Pacific Time (US & Canada)',
        'Europe/London': 'Greenwich Mean Time',
        'Europe/Paris': 'Central European Time',
        'Asia/Tokyo': 'Japan Standard Time',
        'Asia/Shanghai': 'China Standard Time',
        'Australia/Sydney': 'Australian Eastern Time'
      }
    };
  }
  
  logWithTimezone(level, message, data = {}, timezoneStrategy = 'always_utc') {
    const now = new Date();
    const strategy = this.timezoneConfig.conversionRules[timezoneStrategy];
    
    if (!strategy) {
      throw new Error(`Unknown timezone strategy: ${timezoneStrategy}`);
    }
    
    const timestamp = strategy.implementation(now);
    
    const logEntry = {
      timestamp,
      level: level.toUpperCase(),
      message,
      ...data,
      
      // Timezone metadata
      timezoneInfo: {
        strategy: timezoneStrategy,
        originalTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        logTimezone: this.extractTimezone(timestamp),
        utcOffset: now.getTimezoneOffset(),
        isDST: this.isDaylightSavingTime(now),
        systemTimezone: process.env.TZ || 'system_default',
        conversion: {
          utc: now.toISOString(),
          local: now.toString(),
          epoch: now.getTime()
        }
      }
    };
    
    this.logger[level](message, logEntry);
    return logEntry;
  }
  
  isDaylightSavingTime(date) {
    const jan = new Date(date.getFullYear(), 0, 1);
    const jul = new Date(date.getFullYear(), 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset()) !== date.getTimezoneOffset();
  }
  
  getTimezoneOffset(timezone) {
    const now = new Date();
    const utc = new Date(now.toLocaleString('en-US', { timeZone: 'UTC' }));
    const tz = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
    const offset = (utc.getTime() - tz.getTime()) / (1000 * 60);
    
    const hours = Math.floor(Math.abs(offset) / 60);
    const minutes = Math.abs(offset) % 60;
    const sign = offset >= 0 ? '+' : '-';
    
    return `${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }
  
  extractTimezone(timestamp) {
    if (timestamp.endsWith('Z')) return 'UTC';
    const match = timestamp.match(/([+-]\d{2}:\d{2})$/);
    return match ? match[1] : 'unknown';
  }
}
```

## Best Practices for Timestamps

### 1. **Timestamp Implementation Guidelines**
```javascript
// Best practices implementation
const timestampBestPractices = {
  // Always use consistent format across the application
  consistency: {
    rule: 'Use the same timestamp format throughout the application',
    implementation: () => new Date().toISOString(),
    benefits: ['Easy log correlation', 'Simplified parsing', 'Reduced confusion']
  },
  
  // Include timezone information
  timezoneAwareness: {
    rule: 'Always include timezone information',
    implementation: (timezone = 'UTC') => {
      const now = new Date();
      return timezone === 'UTC' ? now.toISOString() : 
        now.toLocaleString('sv-SE', { timeZone: timezone }).replace(' ', 'T') + getTimezoneOffset(timezone);
    },
    benefits: ['Avoid timezone confusion', 'Enable global log correlation', 'Support distributed teams']
  },
  
  // Use appropriate precision
  precisionOptimization: {
    rule: 'Choose timestamp precision based on use case',
    implementation: {
      business: () => new Date().toISOString().split('.')[0] + 'Z', // Second precision
      performance: () => new Date().toISOString(), // Millisecond precision
      debugging: () => process.hrtime.bigint().toString() // Nanosecond precision
    },
    benefits: ['Optimal performance', 'Appropriate detail level', 'Reduced storage costs']
  },
  
  // Monotonic timestamps for ordering
  monotonicOrdering: {
    rule: 'Ensure timestamp ordering even with clock adjustments',
    implementation: (() => {
      let lastTimestamp = 0;
      let sequence = 0;
      
      return () => {
        const now = Date.now();
        if (now === lastTimestamp) {
          sequence++;
        } else {
          sequence = 0;
          lastTimestamp = now;
        }
        return `${now}.${sequence.toString().padStart(6, '0')}`;
      };
    })(),
    benefits: ['Guaranteed ordering', 'Handle clock adjustments', 'Unique timestamps']
  }
};
```

---

**Previous**: [2.1.7 Choosing Appropriate Log Levels](../2.1_Log_Levels_and_Severity/2.1.7_Choosing_Appropriate_Log_Levels.md)  
**Next**: [2.2.2 Log Level](./2.2.2_Log_Level.md)
