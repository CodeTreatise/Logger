# 2.1.5 ERROR: Error Conditions

## Understanding ERROR Level Logging

ERROR level logging captures exceptional conditions that prevent normal operation from continuing. These are actual errors that require immediate attention, cause functionality to fail, or result in data loss or corruption. ERROR logs are critical for debugging failures, maintaining system reliability, and ensuring business continuity.

## Characteristics of ERROR Logging

### 1. **Application Errors and Exceptions**
ERROR logging captures unhandled exceptions, application failures, and critical business logic errors.

```javascript
// Application error logging
class ApplicationErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'ApplicationErrorLogger' });
    this.errorMetrics = {
      totalErrors: 0,
      errorsByType: new Map(),
      errorsByEndpoint: new Map(),
      recentErrors: []
    };
    
    // Set up error tracking
    this.setupErrorTracking();
  }
  
  async handleApplicationError(error, context = {}) {
    const errorId = this.generateErrorId();
    const timestamp = new Date().toISOString();
    
    // Increment error counters
    this.errorMetrics.totalErrors++;
    const errorType = error.constructor.name;
    this.errorMetrics.errorsByType.set(errorType, 
      (this.errorMetrics.errorsByType.get(errorType) || 0) + 1);
    
    if (context.endpoint) {
      this.errorMetrics.errorsByEndpoint.set(context.endpoint,
        (this.errorMetrics.errorsByEndpoint.get(context.endpoint) || 0) + 1);
    }
    
    const errorDetails = {
      errorId,
      timestamp,
      errorType,
      message: error.message,
      stack: error.stack,
      
      // Error classification
      classification: {
        category: this.classifyError(error),
        severity: this.assessErrorSeverity(error, context),
        recoverable: this.isRecoverableError(error),
        userImpact: this.assessUserImpact(error, context),
        businessImpact: this.assessBusinessImpact(error, context)
      },
      
      // Context information
      context: {
        userId: context.userId,
        sessionId: context.sessionId,
        requestId: context.requestId,
        correlationId: context.correlationId,
        endpoint: context.endpoint,
        method: context.method,
        userAgent: context.userAgent,
        ipAddress: this.maskIP(context.ipAddress),
        timestamp: context.timestamp
      },
      
      // Application state
      applicationState: {
        nodeVersion: process.version,
        platform: process.platform,
        pid: process.pid,
        uptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage(),
        activeHandles: process._getActiveHandles().length,
        activeRequests: process._getActiveRequests().length
      },
      
      // Request details (if applicable)
      request: context.request ? {
        method: context.request.method,
        url: context.request.url,
        headers: this.sanitizeHeaders(context.request.headers),
        body: this.sanitizeRequestBody(context.request.body),
        params: context.request.params,
        query: context.request.query,
        contentLength: context.request.headers['content-length'],
        contentType: context.request.headers['content-type']
      } : undefined,
      
      // Database context (if applicable)
      database: context.database ? {
        query: this.sanitizeQuery(context.database.query),
        parameters: this.sanitizeParameters(context.database.parameters),
        connection: context.database.connection,
        transactionId: context.database.transactionId,
        isolationLevel: context.database.isolationLevel,
        affectedRows: context.database.affectedRows
      } : undefined,
      
      // External service context (if applicable)
      externalService: context.externalService ? {
        serviceName: context.externalService.name,
        endpoint: context.externalService.endpoint,
        method: context.externalService.method,
        requestId: context.externalService.requestId,
        responseStatus: context.externalService.responseStatus,
        responseTime: context.externalService.responseTime,
        retryAttempt: context.externalService.retryAttempt,
        circuitBreakerState: context.externalService.circuitBreakerState
      } : undefined,
      
      // Error propagation
      propagation: {
        originatingService: this.identifyOriginatingService(error, context),
        errorChain: this.buildErrorChain(error),
        relatedErrors: this.findRelatedErrors(error, context),
        cascadingEffects: this.identifyCascadingEffects(error, context)
      },
      
      // Recovery information
      recovery: {
        autoRecoveryAttempted: false,
        recoveryStrategy: this.identifyRecoveryStrategy(error, context),
        fallbackUsed: context.fallbackUsed || false,
        userNotified: false,
        escalationRequired: this.requiresEscalation(error, context)
      },
      
      // Debugging information
      debugging: {
        reproducible: this.isReproducible(error, context),
        reproductionSteps: this.generateReproductionSteps(error, context),
        relatedCode: this.identifyRelatedCode(error),
        possibleCauses: this.identifyPossibleCauses(error, context),
        similarIncidents: await this.findSimilarIncidents(error)
      }
    };
    
    // Log the error
    this.logger.error('Application error occurred', errorDetails);
    
    // Store in recent errors for pattern analysis
    this.errorMetrics.recentErrors.push({
      errorId,
      timestamp: Date.now(),
      type: errorType,
      context: context.endpoint || 'unknown'
    });
    
    // Keep only last 100 errors
    if (this.errorMetrics.recentErrors.length > 100) {
      this.errorMetrics.recentErrors.shift();
    }
    
    // Attempt automatic recovery if possible
    if (errorDetails.classification.recoverable) {
      await this.attemptAutoRecovery(error, context, errorId);
    }
    
    // Notify monitoring systems
    await this.notifyMonitoringSystems(errorDetails);
    
    // Check for error patterns
    this.analyzeErrorPatterns();
    
    return errorId;
  }
  
  async attemptAutoRecovery(error, context, errorId) {
    try {
      const recoveryStrategy = this.identifyRecoveryStrategy(error, context);
      
      this.logger.error('Attempting automatic error recovery', {
        errorId,
        recoveryStrategy: recoveryStrategy.name,
        recoverySteps: recoveryStrategy.steps,
        estimatedRecoveryTime: recoveryStrategy.estimatedTime,
        successProbability: recoveryStrategy.successProbability
      });
      
      const recoveryResult = await this.executeRecoveryStrategy(recoveryStrategy, context);
      
      if (recoveryResult.success) {
        this.logger.error('Automatic error recovery successful', {
          errorId,
          recoveryStrategy: recoveryStrategy.name,
          recoveryTime: recoveryResult.recoveryTime,
          recoveryActions: recoveryResult.actions,
          systemState: recoveryResult.systemState
        });
        
        return true;
      } else {
        this.logger.error('Automatic error recovery failed', {
          errorId,
          recoveryStrategy: recoveryStrategy.name,
          failureReason: recoveryResult.failureReason,
          partialRecovery: recoveryResult.partialRecovery,
          nextSteps: recoveryResult.nextSteps,
          escalationRequired: true
        });
        
        return false;
      }
    } catch (recoveryError) {
      this.logger.error('Error during automatic recovery attempt', {
        originalErrorId: errorId,
        recoveryError: recoveryError.message,
        recoveryErrorStack: recoveryError.stack,
        systemCompromised: this.assessSystemCompromise(recoveryError),
        immediateAction: 'manual_intervention_required'
      });
      
      return false;
    }
  }
  
  analyzeErrorPatterns() {
    const recentWindow = Date.now() - (5 * 60 * 1000); // Last 5 minutes
    const recentErrors = this.errorMetrics.recentErrors.filter(
      error => error.timestamp > recentWindow
    );
    
    if (recentErrors.length === 0) return;
    
    // Check for error spikes
    if (recentErrors.length > 10) {
      const errorSpike = this.analyzeErrorSpike(recentErrors);
      
      this.logger.error('Error spike detected', {
        patternType: 'error_spike',
        timeWindow: '5_minutes',
        errorCount: recentErrors.length,
        spikeAnalysis: errorSpike,
        affectedEndpoints: this.getAffectedEndpoints(recentErrors),
        commonErrorTypes: this.getMostCommonErrorTypes(recentErrors),
        possibleCauses: this.identifySpikeCauses(errorSpike),
        recommendedActions: this.getSpikeMitigationActions(errorSpike)
      });
    }
    
    // Check for recurring errors
    const recurringPatterns = this.identifyRecurringPatterns(recentErrors);
    if (recurringPatterns.length > 0) {
      for (const pattern of recurringPatterns) {
        this.logger.error('Recurring error pattern detected', {
          patternType: 'recurring_error',
          pattern: pattern.description,
          occurrences: pattern.occurrences,
          frequency: pattern.frequency,
          affectedComponents: pattern.affectedComponents,
          rootCauseHypothesis: pattern.rootCauseHypothesis,
          investigationPriority: pattern.priority,
          suggestedFixes: pattern.suggestedFixes
        });
      }
    }
    
    // Check for cascading failures
    const cascadingFailures = this.identifyCascadingFailures(recentErrors);
    if (cascadingFailures.length > 0) {
      for (const cascade of cascadingFailures) {
        this.logger.error('Cascading failure detected', {
          patternType: 'cascading_failure',
          primaryFailure: cascade.primary,
          secondaryFailures: cascade.secondary,
          propagationPath: cascade.propagationPath,
          impactRadius: cascade.impactRadius,
          isolationStrategy: cascade.isolationStrategy,
          recoveryPlan: cascade.recoveryPlan
        });
      }
    }
  }
}
```

### 2. **System and Infrastructure Errors**
ERROR logging captures critical system failures, infrastructure issues, and resource exhaustion.

```javascript
// System and infrastructure error logging
class SystemErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'SystemErrorLogger' });
    this.systemHealth = {
      lastHealthCheck: null,
      consecutiveFailures: 0,
      systemState: 'unknown'
    };
  }
  
  async logDatabaseError(error, operation, context = {}) {
    const errorId = this.generateErrorId();
    
    const databaseErrorDetails = {
      errorId,
      timestamp: new Date().toISOString(),
      errorType: 'database_error',
      
      // Database error classification
      classification: {
        category: this.classifyDatabaseError(error),
        severity: this.assessDatabaseErrorSeverity(error, operation),
        transient: this.isTransientDatabaseError(error),
        retryable: this.isRetryableDatabaseError(error),
        dataIntegrity: this.hasDataIntegrityImpact(error, operation)
      },
      
      // Error details
      error: {
        message: error.message,
        code: error.code,
        sqlState: error.sqlState,
        detail: error.detail,
        hint: error.hint,
        position: error.position,
        constraint: error.constraint,
        schema: error.schema,
        table: error.table,
        column: error.column
      },
      
      // Operation context
      operation: {
        type: operation.type, // 'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DDL'
        query: this.sanitizeQuery(operation.query),
        parameters: this.sanitizeParameters(operation.parameters),
        transactionId: operation.transactionId,
        isolationLevel: operation.isolationLevel,
        timeout: operation.timeout,
        retryAttempt: operation.retryAttempt || 0
      },
      
      // Connection details
      connection: {
        connectionId: context.connectionId,
        poolName: context.poolName,
        database: context.database,
        user: context.user,
        host: context.host,
        port: context.port,
        ssl: context.ssl,
        connectionAge: context.connectionAge,
        queriesExecuted: context.queriesExecuted
      },
      
      // Database state
      databaseState: {
        activeConnections: await this.getActiveConnections(),
        totalConnections: await this.getTotalConnections(),
        maxConnections: await this.getMaxConnections(),
        queuedQueries: await this.getQueuedQueries(),
        averageQueryTime: await this.getAverageQueryTime(),
        slowQueries: await this.getSlowQueryCount(),
        locksHeld: await this.getLocksHeld(),
        blockedQueries: await this.getBlockedQueries()
      },
      
      // Performance metrics
      performance: {
        queryExecutionTime: operation.executionTime,
        parseTime: operation.parseTime,
        planTime: operation.planTime,
        bufferHits: operation.bufferHits,
        bufferMisses: operation.bufferMisses,
        diskReads: operation.diskReads,
        tempFiles: operation.tempFiles,
        memoryUsage: operation.memoryUsage
      },
      
      // Impact assessment
      impact: {
        operationsAffected: this.getAffectedOperations(error),
        usersAffected: this.getAffectedUsers(context),
        dataConsistency: this.checkDataConsistency(error, operation),
        serviceAvailability: this.checkServiceAvailability(),
        businessContinuity: this.assessBusinessContinuity(error)
      },
      
      // Recovery information
      recovery: {
        automaticRetry: this.shouldRetry(error, operation),
        fallbackStrategy: this.identifyFallbackStrategy(error, operation),
        rollbackRequired: this.requiresRollback(error, operation),
        manualIntervention: this.requiresManualIntervention(error),
        estimatedRecoveryTime: this.estimateRecoveryTime(error)
      }
    };
    
    this.logger.error('Database error occurred', databaseErrorDetails);
    
    // Attempt connection recovery if needed
    if (this.isConnectionError(error)) {
      await this.attemptConnectionRecovery(context, errorId);
    }
    
    // Check for database health degradation
    await this.checkDatabaseHealth(errorId);
    
    return errorId;
  }
  
  async logNetworkError(error, request, context = {}) {
    const errorId = this.generateErrorId();
    
    const networkErrorDetails = {
      errorId,
      timestamp: new Date().toISOString(),
      errorType: 'network_error',
      
      // Network error classification
      classification: {
        category: this.classifyNetworkError(error),
        severity: this.assessNetworkErrorSeverity(error, request),
        transient: this.isTransientNetworkError(error),
        retryable: this.isRetryableNetworkError(error),
        infrastructureIssue: this.isInfrastructureIssue(error)
      },
      
      // Error details
      error: {
        message: error.message,
        code: error.code,
        errno: error.errno,
        syscall: error.syscall,
        hostname: error.hostname,
        port: error.port,
        address: error.address
      },
      
      // Request details
      request: {
        method: request.method,
        url: this.sanitizeUrl(request.url),
        headers: this.sanitizeHeaders(request.headers),
        timeout: request.timeout,
        retryAttempt: request.retryAttempt || 0,
        maxRetries: request.maxRetries || 0,
        retryDelay: request.retryDelay,
        circuitBreakerState: request.circuitBreakerState
      },
      
      // Network diagnostics
      diagnostics: {
        dnsResolution: await this.checkDNSResolution(request.hostname),
        connectivity: await this.checkConnectivity(request.hostname, request.port),
        latency: await this.measureLatency(request.hostname),
        packetLoss: await this.measurePacketLoss(request.hostname),
        bandwidth: await this.measureBandwidth(request.hostname),
        routeTrace: await this.getRouteTrace(request.hostname)
      },
      
      // Service health
      serviceHealth: {
        serviceName: context.serviceName,
        endpoint: request.url,
        averageResponseTime: await this.getAverageResponseTime(context.serviceName),
        errorRate: await this.getErrorRate(context.serviceName),
        availability: await this.getAvailability(context.serviceName),
        lastSuccessfulRequest: await this.getLastSuccessfulRequest(context.serviceName),
        currentStatus: await this.getServiceStatus(context.serviceName)
      },
      
      // Infrastructure context
      infrastructure: {
        region: context.region,
        datacenter: context.datacenter,
        loadBalancer: context.loadBalancer,
        cdn: context.cdn,
        proxy: context.proxy,
        networkProvider: context.networkProvider,
        internetGateway: context.internetGateway
      },
      
      // Impact assessment
      impact: {
        dependentServices: this.getDependentServices(context.serviceName),
        affectedFeatures: this.getAffectedFeatures(context.serviceName),
        userImpact: this.assessNetworkUserImpact(error, context),
        businessImpact: this.assessNetworkBusinessImpact(error, context),
        slaViolation: this.checkSLAViolation(error, context)
      },
      
      // Mitigation strategies
      mitigation: {
        circuitBreakerTriggered: this.shouldTriggerCircuitBreaker(error, context),
        fallbackService: this.identifyFallbackService(context.serviceName),
        cacheUsage: this.canUseCachedResponse(request),
        loadBalancerFailover: this.canFailoverLoadBalancer(context),
        alternativeEndpoint: this.getAlternativeEndpoint(context.serviceName)
      }
    };
    
    this.logger.error('Network error occurred', networkErrorDetails);
    
    // Trigger circuit breaker if needed
    if (networkErrorDetails.mitigation.circuitBreakerTriggered) {
      await this.triggerCircuitBreaker(context.serviceName, errorId);
    }
    
    // Update service health metrics
    await this.updateServiceHealthMetrics(context.serviceName, error);
    
    return errorId;
  }
  
  async logMemoryError(error, context = {}) {
    const errorId = this.generateErrorId();
    const memoryUsage = process.memoryUsage();
    
    const memoryErrorDetails = {
      errorId,
      timestamp: new Date().toISOString(),
      errorType: 'memory_error',
      
      // Memory error classification
      classification: {
        category: this.classifyMemoryError(error),
        severity: 'critical', // Memory errors are always critical
        oomKill: this.isOOMKill(error),
        heapExhaustion: this.isHeapExhaustion(error),
        memoryLeak: this.isMemoryLeak(error, context)
      },
      
      // Error details
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name,
        code: error.code
      },
      
      // Memory diagnostics
      memory: {
        current: {
          heapUsedMB: Math.round(memoryUsage.heapUsed / 1024 / 1024),
          heapTotalMB: Math.round(memoryUsage.heapTotal / 1024 / 1024),
          externalMB: Math.round(memoryUsage.external / 1024 / 1024),
          rssMB: Math.round(memoryUsage.rss / 1024 / 1024),
          utilizationPercentage: Math.round((memoryUsage.heapUsed / memoryUsage.heapTotal) * 100)
        },
        limits: {
          heapSizeLimit: this.getHeapSizeLimit(),
          physicalMemory: this.getPhysicalMemory(),
          availableMemory: this.getAvailableMemory(),
          maxOldSpaceSize: this.getMaxOldSpaceSize()
        },
        trend: this.analyzeMemoryTrend(),
        gcStats: this.getGCStats(),
        largestObjects: await this.identifyLargestObjects(),
        suspectedLeaks: await this.identifySuspectedLeaks()
      },
      
      // System context
      system: {
        platform: process.platform,
        arch: process.arch,
        nodeVersion: process.version,
        v8Version: process.versions.v8,
        pid: process.pid,
        uptime: process.uptime(),
        cpuUsage: process.cpuUsage(),
        loadAverage: require('os').loadavg()
      },
      
      // Application context
      application: {
        activeConnections: await this.getActiveConnections(),
        pendingRequests: this.getPendingRequests(),
        cacheSize: this.getCacheSize(),
        sessionCount: this.getSessionCount(),
        workerProcesses: this.getWorkerProcesses(),
        backgroundJobs: this.getBackgroundJobs()
      },
      
      // Recovery actions
      recovery: {
        immediateActions: this.getImmediateMemoryActions(),
        gcTriggered: this.triggerGarbageCollection(),
        cacheCleared: this.clearCaches(),
        connectionsClosed: this.closeIdleConnections(),
        processRestart: this.shouldRestartProcess(),
        escalationRequired: true
      }
    };
    
    this.logger.error('Memory error occurred', memoryErrorDetails);
    
    // Immediate memory recovery attempts
    await this.attemptMemoryRecovery(errorId);
    
    // Alert monitoring systems
    await this.alertCriticalMemoryIssue(memoryErrorDetails);
    
    return errorId;
  }
}
```

### 3. **Data Integrity and Security Errors**
ERROR logging captures data corruption, security violations, and integrity failures.

```javascript
// Data integrity and security error logging
class DataSecurityErrorLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'DataSecurityErrorLogger' });
    this.securityMetrics = {
      securityViolations: 0,
      dataIntegrityIssues: 0,
      unauthorizedAccess: 0
    };
  }
  
  async logDataIntegrityError(error, operation, context = {}) {
    const errorId = this.generateErrorId();
    this.securityMetrics.dataIntegrityIssues++;
    
    const dataIntegrityErrorDetails = {
      errorId,
      timestamp: new Date().toISOString(),
      errorType: 'data_integrity_error',
      
      // Data integrity classification
      classification: {
        integrityType: this.classifyIntegrityViolation(error),
        severity: this.assessIntegritySeverity(error, operation),
        dataCorruption: this.hasDataCorruption(error),
        constraintViolation: this.isConstraintViolation(error),
        businessRuleViolation: this.isBusinessRuleViolation(error, operation)
      },
      
      // Error details
      error: {
        message: error.message,
        constraint: error.constraint,
        violationType: error.violationType,
        expectedValue: error.expectedValue,
        actualValue: error.actualValue,
        validationRules: error.validationRules
      },
      
      // Data context
      data: {
        entityType: operation.entityType,
        entityId: operation.entityId,
        fieldName: error.fieldName,
        tableName: operation.tableName,
        operation: operation.type, // 'CREATE', 'UPDATE', 'DELETE'
        transactionId: operation.transactionId,
        dataState: this.captureDataState(operation)
      },
      
      // Integrity checks
      integrity: {
        checksumValidation: await this.validateChecksums(operation),
        foreignKeyIntegrity: await this.checkForeignKeyIntegrity(operation),
        uniqueConstraints: await this.checkUniqueConstraints(operation),
        businessRules: await this.validateBusinessRules(operation),
        referentialIntegrity: await this.checkReferentialIntegrity(operation)
      },
      
      // Impact assessment
      impact: {
        affectedRecords: await this.countAffectedRecords(operation),
        relatedEntities: await this.findRelatedEntities(operation),
        dataConsistency: await this.assessDataConsistency(operation),
        businessProcesses: this.getAffectedBusinessProcesses(operation),
        complianceImplications: this.getComplianceImplications(error)
      },
      
      // Remediation
      remediation: {
        rollbackRequired: this.requiresRollback(error, operation),
        dataRecovery: this.getDataRecoveryOptions(operation),
        compensatingTransactions: this.getCompensatingTransactions(operation),
        auditTrail: await this.createAuditTrail(operation, error),
        notificationRequired: this.requiresNotification(error, operation)
      }
    };
    
    this.logger.error('Data integrity error occurred', dataIntegrityErrorDetails);
    
    // Immediate data protection measures
    await this.protectDataIntegrity(operation, errorId);
    
    return errorId;
  }
  
  async logSecurityViolation(violation, context = {}) {
    const errorId = this.generateErrorId();
    this.securityMetrics.securityViolations++;
    
    const securityViolationDetails = {
      errorId,
      timestamp: new Date().toISOString(),
      errorType: 'security_violation',
      
      // Security classification
      classification: {
        violationType: violation.type, // 'unauthorized_access', 'injection_attempt', 'privilege_escalation'
        severity: this.assessSecuritySeverity(violation),
        threatLevel: this.assessThreatLevel(violation),
        sophistication: this.assessAttackSophistication(violation),
        persistence: this.assessAttackPersistence(violation)
      },
      
      // Violation details
      violation: {
        description: violation.description,
        attackVector: violation.attackVector,
        targetResource: violation.targetResource,
        attemptedAction: violation.attemptedAction,
        authenticationMethod: violation.authenticationMethod,
        authorizationFailure: violation.authorizationFailure
      },
      
      // Attacker context
      attacker: {
        sourceIP: this.hashIP(context.sourceIP),
        userAgent: context.userAgent,
        sessionId: context.sessionId,
        userId: context.userId,
        geolocation: context.geolocation,
        deviceFingerprint: this.hashDeviceFingerprint(context.deviceFingerprint),
        behaviorProfile: this.analyzeBehaviorProfile(context)
      },
      
      // Security context
      security: {
        authenticationStatus: context.authenticationStatus,
        authorizationStatus: context.authorizationStatus,
        sessionValidity: context.sessionValidity,
        mfaStatus: context.mfaStatus,
        riskScore: this.calculateRiskScore(violation, context),
        threatIndicators: this.identifyThreatIndicators(violation, context)
      },
      
      // System defense
      defense: {
        firewallRules: this.getApplicableFirewallRules(context),
        rateLimit: this.getRateLimitStatus(context),
        blockedByWAF: context.blockedByWAF,
        honeypotTriggered: context.honeypotTriggered,
        anomalyDetection: this.getAnomalyDetectionResults(violation, context)
      },
      
      // Impact assessment
      impact: {
        dataExposed: this.assessDataExposure(violation),
        systemCompromise: this.assessSystemCompromise(violation),
        privilegesObtained: this.assessPrivilegesObtained(violation),
        lateralMovement: this.assessLateralMovement(violation),
        businessImpact: this.assessSecurityBusinessImpact(violation)
      },
      
      // Response actions
      response: {
        automaticBlocking: this.shouldAutomaticallyBlock(violation, context),
        sessionTermination: this.shouldTerminateSession(violation, context),
        accountSuspension: this.shouldSuspendAccount(violation, context),
        alertGeneration: this.shouldGenerateAlert(violation),
        forensicCollection: this.shouldCollectForensics(violation)
      }
    };
    
    this.logger.error('Security violation detected', securityViolationDetails);
    
    // Immediate security response
    await this.executeSecurityResponse(violation, context, errorId);
    
    // Update threat intelligence
    await this.updateThreatIntelligence(violation, context);
    
    return errorId;
  }
}
```

## When to Use ERROR Logging

### 1. **Unhandled Exceptions**
- Application crashes or unrecoverable errors
- Runtime exceptions that prevent operation completion
- Stack overflow or memory exhaustion
- Critical system failures

### 2. **Data and Security Issues**
- Data corruption or integrity violations
- Security breaches or unauthorized access
- Authentication or authorization failures
- Compliance violations

### 3. **External Service Failures**
- Database connection failures
- Network timeouts or connection errors
- Third-party service unavailability
- API rate limit violations

### 4. **Business Logic Failures**
- Transaction failures
- Payment processing errors
- Order fulfillment failures
- Critical business rule violations

## Best Practices for ERROR Logging

### 1. **Comprehensive Error Context**
```javascript
// Comprehensive error context logging
class ComprehensiveErrorLogger {
  constructor(logger) {
    this.logger = logger;
    this.errorContext = new Map();
  }
  
  logError(error, context = {}) {
    const errorId = this.generateErrorId();
    const fullContext = this.buildFullContext(error, context);
    
    this.logger.error('Error occurred', {
      errorId,
      error: {
        message: error.message,
        stack: error.stack,
        name: error.name,
        cause: error.cause
      },
      context: fullContext,
      recovery: this.identifyRecoveryActions(error, fullContext),
      escalation: this.determineEscalationPath(error, fullContext),
      monitoring: this.getMonitoringLinks(errorId),
      documentation: this.getDocumentationLinks(error)
    });
    
    this.errorContext.set(errorId, { error, context: fullContext, timestamp: Date.now() });
    return errorId;
  }
}
```

### 2. **Error Correlation and Tracking**
```javascript
// Error correlation and tracking
class ErrorCorrelationTracker {
  constructor(logger) {
    this.logger = logger;
    this.errorChains = new Map();
    this.correlationWindow = 300000; // 5 minutes
  }
  
  trackCorrelatedError(error, correlationId, context = {}) {
    const errorId = this.generateErrorId();
    
    // Find related errors
    const relatedErrors = this.findRelatedErrors(correlationId);
    
    // Build error chain
    const errorChain = this.buildErrorChain(error, relatedErrors);
    
    this.logger.error('Correlated error detected', {
      errorId,
      correlationId,
      error: this.serializeError(error),
      context,
      errorChain,
      relatedErrors: relatedErrors.map(e => e.errorId),
      rootCause: this.identifyRootCause(errorChain),
      cascade: this.analyzeCascadeEffect(errorChain)
    });
    
    this.errorChains.set(errorId, {
      error,
      correlationId,
      context,
      relatedErrors,
      timestamp: Date.now()
    });
    
    return errorId;
  }
}
```

### 3. **Error Recovery and Escalation**
```javascript
// Error recovery and escalation
class ErrorRecoveryManager {
  constructor(logger) {
    this.logger = logger;
    this.recoveryStrategies = new Map();
    this.escalationRules = new Map();
  }
  
  async handleErrorWithRecovery(error, context = {}) {
    const errorId = this.generateErrorId();
    
    // Log the error
    this.logger.error('Error occurred - attempting recovery', {
      errorId,
      error: this.serializeError(error),
      context,
      recoveryAttempt: 1
    });
    
    // Attempt recovery
    const recoveryResult = await this.attemptRecovery(error, context, errorId);
    
    if (recoveryResult.success) {
      this.logger.error('Error recovery successful', {
        errorId,
        recoveryStrategy: recoveryResult.strategy,
        recoveryTime: recoveryResult.time,
        systemState: recoveryResult.systemState
      });
    } else {
      this.logger.error('Error recovery failed - escalating', {
        errorId,
        recoveryAttempts: recoveryResult.attempts,
        escalationLevel: this.determineEscalationLevel(error),
        urgency: this.assessUrgency(error, context),
        escalationPath: this.getEscalationPath(error)
      });
      
      await this.escalateError(error, context, errorId);
    }
    
    return errorId;
  }
}
```

---

**Previous**: [2.1.4 WARN: Warning Conditions](./2.1.4_WARN_Warning_Conditions.md)  
**Next**: [2.1.6 FATAL/CRITICAL: Severe Error Events](./2.1.6_FATAL_CRITICAL_Severe_Error_Events.md)
