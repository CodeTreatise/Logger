# 2.1.4 WARN: Warning Conditions

## Understanding WARN Level Logging

WARN level logging captures potentially problematic situations that don't prevent the application from functioning but indicate conditions that could lead to errors or degraded performance. These warnings help developers and operators identify issues before they become critical problems, enabling proactive maintenance and optimization.

## Characteristics of WARN Logging

### 1. **Degraded Performance Detection**
WARN logging identifies performance issues that could impact user experience or system efficiency.

```javascript
// Performance degradation warning logging
class PerformanceWarningLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'PerformanceWarningLogger' });
    this.performanceThresholds = {
      responseTime: 1000,     // 1 second
      memoryUsage: 0.85,      // 85% of heap
      cpuUsage: 80,           // 80% CPU utilization
      diskUsage: 90,          // 90% disk utilization
      connectionPool: 0.9,     // 90% pool utilization
      queueSize: 1000,        // 1000 items in queue
      errorRate: 0.05         // 5% error rate
    };
    
    this.performanceHistory = {
      responseTime: [],
      memoryUsage: [],
      cpuUsage: [],
      errorRate: []
    };
    
    // Start performance monitoring
    this.startPerformanceMonitoring();
  }
  
  async monitorResponseTime(operation, executionTime) {
    this.performanceHistory.responseTime.push({
      operation,
      time: executionTime,
      timestamp: Date.now()
    });
    
    // Keep only last 100 measurements
    if (this.performanceHistory.responseTime.length > 100) {
      this.performanceHistory.responseTime.shift();
    }
    
    if (executionTime > this.performanceThresholds.responseTime) {
      const avgResponseTime = this.calculateAverageResponseTime(operation);
      const percentile95 = this.calculatePercentile(operation, 95);
      
      this.logger.warn('Slow response time detected', {
        operation,
        responseTime: executionTime,
        threshold: this.performanceThresholds.responseTime,
        exceedsThresholdBy: executionTime - this.performanceThresholds.responseTime,
        performanceMetrics: {
          averageResponseTime: avgResponseTime,
          percentile95: percentile95,
          recentTrend: this.analyzeResponseTimeTrend(operation),
          slowRequestsLast10Min: this.countSlowRequestsRecent(operation, 10)
        },
        potentialCauses: this.identifyPotentialCauses(operation, executionTime),
        recommendedActions: this.getPerformanceRecommendations(operation, executionTime),
        userImpact: this.assessUserImpact(executionTime),
        alertLevel: this.determineAlertLevel(executionTime)
      });
    }
    
    // Warn about trending performance degradation
    if (this.isPerformanceDegrading(operation)) {
      this.logger.warn('Performance degradation trend detected', {
        operation,
        currentResponseTime: executionTime,
        trendAnalysis: this.analyzePerformanceTrend(operation),
        degradationRate: this.calculateDegradationRate(operation),
        projectedImpact: this.projectPerformanceImpact(operation),
        recommendedActions: ['investigate_bottlenecks', 'scale_resources', 'optimize_queries']
      });
    }
  }
  
  monitorMemoryUsage() {
    const memUsage = process.memoryUsage();
    const heapUsedMB = memUsage.heapUsed / 1024 / 1024;
    const heapTotalMB = memUsage.heapTotal / 1024 / 1024;
    const utilizationRatio = memUsage.heapUsed / memUsage.heapTotal;
    
    this.performanceHistory.memoryUsage.push({
      heapUsed: heapUsedMB,
      heapTotal: heapTotalMB,
      utilization: utilizationRatio,
      timestamp: Date.now()
    });
    
    if (utilizationRatio > this.performanceThresholds.memoryUsage) {
      const memoryTrend = this.analyzeMemoryTrend();
      const gcMetrics = this.getGCMetrics();
      
      this.logger.warn('High memory usage detected', {
        memoryUsage: {
          heapUsedMB: Math.round(heapUsedMB),
          heapTotalMB: Math.round(heapTotalMB),
          utilizationPercentage: Math.round(utilizationRatio * 100),
          externalMB: Math.round(memUsage.external / 1024 / 1024),
          rssMB: Math.round(memUsage.rss / 1024 / 1024)
        },
        threshold: Math.round(this.performanceThresholds.memoryUsage * 100) + '%',
        memoryTrend: memoryTrend,
        gcMetrics: gcMetrics,
        potentialLeaks: this.identifyPotentialMemoryLeaks(),
        largestObjects: this.identifyLargestObjects(),
        recommendedActions: [
          'investigate_memory_leaks',
          'optimize_object_retention',
          'increase_heap_size',
          'implement_memory_profiling'
        ],
        riskLevel: this.assessMemoryRiskLevel(utilizationRatio)
      });
    }
  }
  
  async monitorConnectionPools() {
    const pools = await this.getAllConnectionPools();
    
    for (const pool of pools) {
      const utilization = pool.active / pool.max;
      
      if (utilization > this.performanceThresholds.connectionPool) {
        this.logger.warn('High connection pool utilization', {
          poolName: pool.name,
          poolType: pool.type, // 'database', 'cache', 'external_service'
          utilization: {
            active: pool.active,
            idle: pool.idle,
            max: pool.max,
            utilizationPercentage: Math.round(utilization * 100),
            waiting: pool.waiting
          },
          threshold: Math.round(this.performanceThresholds.connectionPool * 100) + '%',
          poolHealth: {
            averageWaitTime: pool.averageWaitTime,
            longestWaitTime: pool.longestWaitTime,
            timeoutCount: pool.timeoutCount,
            errorRate: pool.errorRate
          },
          trends: {
            utilizationTrend: this.analyzePoolUtilizationTrend(pool.name),
            demandPattern: this.analyzeConnectionDemandPattern(pool.name),
            peakUtilization: this.getPoolPeakUtilization(pool.name)
          },
          recommendations: this.getPoolOptimizationRecommendations(pool),
          impactAssessment: {
            affectedOperations: this.getAffectedOperations(pool.name),
            userImpact: this.assessPoolUserImpact(utilization),
            businessImpact: this.assessPoolBusinessImpact(pool)
          }
        });
      }
    }
  }
  
  monitorQueueSizes() {
    const queues = this.getAllQueues();
    
    for (const queue of queues) {
      if (queue.size > this.performanceThresholds.queueSize) {
        const processingRate = this.calculateProcessingRate(queue.name);
        const estimatedProcessingTime = queue.size / processingRate;
        
        this.logger.warn('Queue size threshold exceeded', {
          queueName: queue.name,
          queueType: queue.type, // 'task', 'message', 'event', 'job'
          queueMetrics: {
            currentSize: queue.size,
            threshold: this.performanceThresholds.queueSize,
            exceedsBy: queue.size - this.performanceThresholds.queueSize,
            processingRate: Math.round(processingRate * 100) / 100, // per second
            estimatedProcessingTime: Math.round(estimatedProcessingTime)
          },
          queueHealth: {
            oldestItemAge: queue.oldestItemAge,
            averageItemAge: queue.averageItemAge,
            failedItems: queue.failedItems,
            retryItems: queue.retryItems,
            deadLetterItems: queue.deadLetterItems
          },
          processingAnalysis: {
            activeWorkers: queue.activeWorkers,
            maxWorkers: queue.maxWorkers,
            workerUtilization: queue.activeWorkers / queue.maxWorkers,
            averageProcessingTime: queue.averageProcessingTime,
            throughputLast5Min: this.calculateRecentThroughput(queue.name, 5)
          },
          recommendations: this.getQueueOptimizationRecommendations(queue),
          riskAssessment: {
            backlogGrowthRate: this.calculateBacklogGrowthRate(queue.name),
            timeToOverflow: this.estimateTimeToOverflow(queue),
            businessImpact: this.assessQueueBacklogImpact(queue)
          }
        });
      }
    }
  }
}
```

### 2. **Resource Constraints and Limits**
WARN logging identifies when resources approach their limits or constraints.

```javascript
// Resource constraint warning logging
class ResourceConstraintLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'ResourceConstraintLogger' });
    this.resourceLimits = {
      diskSpace: 90,          // 90% disk usage
      fileDescriptors: 85,    // 85% of available file descriptors
      networkConnections: 80, // 80% of connection limit
      cacheMemory: 85,        // 85% cache memory usage
      rateLimits: 90,         // 90% of rate limit
      quotaUsage: 85          // 85% of quota usage
    };
  }
  
  async monitorDiskSpace() {
    const diskUsage = await this.getDiskUsage();
    
    for (const mount of diskUsage) {
      const usagePercentage = (mount.used / mount.total) * 100;
      
      if (usagePercentage > this.resourceLimits.diskSpace) {
        const freeSpaceGB = (mount.total - mount.used) / (1024 * 1024 * 1024);
        const estimatedDaysLeft = this.estimateDiskSpaceExhaustion(mount);
        
        this.logger.warn('High disk space usage detected', {
          mountPoint: mount.path,
          diskUsage: {
            usedGB: Math.round((mount.used / (1024 * 1024 * 1024)) * 100) / 100,
            totalGB: Math.round((mount.total / (1024 * 1024 * 1024)) * 100) / 100,
            freeGB: Math.round(freeSpaceGB * 100) / 100,
            usagePercentage: Math.round(usagePercentage * 100) / 100
          },
          threshold: this.resourceLimits.diskSpace + '%',
          growth: {
            dailyGrowthMB: this.calculateDailyDiskGrowth(mount.path),
            weeklyTrend: this.analyzeDiskUsageTrend(mount.path),
            estimatedDaysLeft: estimatedDaysLeft
          },
          largestDirectories: await this.findLargestDirectories(mount.path),
          recommendations: this.getDiskCleanupRecommendations(mount),
          businessImpact: {
            affectedServices: this.getServicesOnMount(mount.path),
            operationalRisk: this.assessDiskFullRisk(mount),
            criticalityLevel: this.assessMountCriticality(mount.path)
          }
        });
      }
    }
  }
  
  monitorFileDescriptors() {
    const fdUsage = this.getFileDescriptorUsage();
    const usagePercentage = (fdUsage.used / fdUsage.limit) * 100;
    
    if (usagePercentage > this.resourceLimits.fileDescriptors) {
      this.logger.warn('High file descriptor usage', {
        fileDescriptors: {
          used: fdUsage.used,
          limit: fdUsage.limit,
          available: fdUsage.limit - fdUsage.used,
          usagePercentage: Math.round(usagePercentage * 100) / 100
        },
        threshold: this.resourceLimits.fileDescriptors + '%',
        breakdown: {
          sockets: fdUsage.sockets,
          files: fdUsage.files,
          pipes: fdUsage.pipes,
          other: fdUsage.other
        },
        trends: {
          growthRate: this.calculateFDGrowthRate(),
          peakUsage: this.getFDPeakUsage(),
          estimatedExhaustion: this.estimateFDExhaustion()
        },
        analysis: {
          topProcesses: this.getTopFDConsumers(),
          leakedDescriptors: this.identifyPotentialFDLeaks(),
          optimization: this.getFDOptimizationSuggestions()
        },
        riskAssessment: {
          timeToLimit: this.estimateTimeToFDLimit(),
          impactOfExhaustion: this.assessFDExhaustionImpact(),
          mitigationOptions: this.getFDMitigationOptions()
        }
      });
    }
  }
  
  async monitorRateLimits() {
    const rateLimits = await this.getAllRateLimits();
    
    for (const limit of rateLimits) {
      const usagePercentage = (limit.current / limit.max) * 100;
      
      if (usagePercentage > this.resourceLimits.rateLimits) {
        const timeWindow = limit.window; // in seconds
        const resetTime = limit.resetTime;
        
        this.logger.warn('Rate limit threshold approached', {
          rateLimitName: limit.name,
          service: limit.service,
          endpoint: limit.endpoint,
          usage: {
            current: limit.current,
            max: limit.max,
            remaining: limit.max - limit.current,
            usagePercentage: Math.round(usagePercentage * 100) / 100,
            timeWindow: timeWindow,
            timeUntilReset: Math.max(0, resetTime - Date.now())
          },
          threshold: this.resourceLimits.rateLimits + '%',
          rateLimitAnalysis: {
            requestPattern: this.analyzeRequestPattern(limit.name),
            peakUsage: this.getRateLimitPeakUsage(limit.name),
            violationHistory: this.getRateLimitViolationHistory(limit.name),
            clientDistribution: this.getRateLimitClientDistribution(limit.name)
          },
          businessContext: {
            affectedUsers: this.getAffectedUserCount(limit),
            businessOperations: this.getAffectedBusinessOperations(limit),
            revenueImpact: this.estimateRateLimitRevenueImpact(limit)
          },
          recommendations: {
            optimizationSuggestions: this.getRateLimitOptimizationSuggestions(limit),
            capacityPlanning: this.getRateLimitCapacityPlanning(limit),
            clientGuidance: this.getRateLimitClientGuidance(limit)
          }
        });
      }
    }
  }
  
  async monitorExternalServiceQuotas() {
    const services = await this.getExternalServices();
    
    for (const service of services) {
      for (const quota of service.quotas) {
        const usagePercentage = (quota.used / quota.limit) * 100;
        
        if (usagePercentage > this.resourceLimits.quotaUsage) {
          this.logger.warn('External service quota threshold approached', {
            serviceName: service.name,
            serviceType: service.type,
            quotaType: quota.type, // 'requests', 'storage', 'compute', 'bandwidth'
            usage: {
              used: quota.used,
              limit: quota.limit,
              remaining: quota.limit - quota.used,
              usagePercentage: Math.round(usagePercentage * 100) / 100,
              resetPeriod: quota.resetPeriod,
              nextReset: quota.nextReset
            },
            threshold: this.resourceLimits.quotaUsage + '%',
            quotaAnalysis: {
              usageTrend: this.analyzeQuotaUsageTrend(service.name, quota.type),
              projectedExhaustion: this.projectQuotaExhaustion(quota),
              seasonalPatterns: this.analyzeQuotaSeasonality(service.name, quota.type),
              burstUsage: this.analyzeQuotaBurstUsage(service.name, quota.type)
            },
            serviceHealth: {
              availability: service.availability,
              responseTime: service.averageResponseTime,
              errorRate: service.errorRate,
              rateLimitHits: service.rateLimitHits
            },
            businessImpact: {
              dependentFeatures: this.getDependentFeatures(service.name),
              criticalOperations: this.getCriticalOperations(service.name),
              userImpact: this.assessQuotaUserImpact(service, quota),
              costImplications: this.analyzeQuotaCostImplications(service, quota)
            },
            mitigation: {
              alternativeServices: this.getAlternativeServices(service.name),
              quotaIncreaseOptions: this.getQuotaIncreaseOptions(service, quota),
              usageOptimization: this.getUsageOptimizationOptions(service, quota),
              cachingStrategies: this.getCachingStrategies(service.name)
            }
          });
        }
      }
    }
  }
}
```

### 3. **Configuration and Compatibility Issues**
WARN logging identifies configuration problems and compatibility issues that could cause problems.

```javascript
// Configuration and compatibility warning logging
class ConfigurationWarningLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'ConfigurationWarningLogger' });
    this.compatibilityRules = this.loadCompatibilityRules();
    this.configurationRules = this.loadConfigurationRules();
  }
  
  validateConfiguration(config) {
    const warnings = [];
    
    // Check for deprecated configuration options
    const deprecatedOptions = this.findDeprecatedOptions(config);
    if (deprecatedOptions.length > 0) {
      this.logger.warn('Deprecated configuration options detected', {
        deprecatedOptions: deprecatedOptions.map(option => ({
          path: option.path,
          currentValue: option.value,
          deprecatedSince: option.deprecatedSince,
          replacedBy: option.replacedBy,
          removalVersion: option.removalVersion,
          migrationGuide: option.migrationGuide
        })),
        migrationRequired: true,
        urgency: this.assessDeprecationUrgency(deprecatedOptions),
        automaticMigration: this.checkAutomaticMigrationAvailable(deprecatedOptions),
        recommendations: this.getDeprecationRecommendations(deprecatedOptions)
      });
      warnings.push(...deprecatedOptions);
    }
    
    // Check for insecure configuration
    const securityIssues = this.identifySecurityIssues(config);
    if (securityIssues.length > 0) {
      this.logger.warn('Insecure configuration detected', {
        securityIssues: securityIssues.map(issue => ({
          type: issue.type,
          severity: issue.severity,
          description: issue.description,
          location: issue.location,
          currentValue: issue.obfuscateValue ? '[HIDDEN]' : issue.value,
          recommendedValue: issue.recommendedValue,
          securityImplications: issue.implications,
          remediationSteps: issue.remediation
        })),
        overallRiskLevel: this.calculateOverallSecurityRisk(securityIssues),
        complianceImpact: this.assessComplianceImpact(securityIssues),
        immediateActions: this.getImmediateSecurityActions(securityIssues)
      });
      warnings.push(...securityIssues);
    }
    
    // Check for performance impact configurations
    const performanceIssues = this.identifyPerformanceIssues(config);
    if (performanceIssues.length > 0) {
      this.logger.warn('Performance-impacting configuration detected', {
        performanceIssues: performanceIssues.map(issue => ({
          setting: issue.setting,
          currentValue: issue.currentValue,
          impact: issue.impact,
          severity: issue.severity,
          expectedPerformanceDegradation: issue.expectedDegradation,
          recommendedValue: issue.recommendedValue,
          tuningGuidance: issue.tuningGuidance
        })),
        aggregatedImpact: this.calculateAggregatedPerformanceImpact(performanceIssues),
        optimizationPriority: this.prioritizeOptimizations(performanceIssues),
        benchmarkComparison: this.compareWithBenchmarks(config)
      });
      warnings.push(...performanceIssues);
    }
    
    // Check for missing required configurations
    const missingConfigs = this.identifyMissingConfigurations(config);
    if (missingConfigs.length > 0) {
      this.logger.warn('Missing recommended configurations', {
        missingConfigurations: missingConfigs.map(missing => ({
          setting: missing.setting,
          category: missing.category,
          importance: missing.importance,
          defaultBehavior: missing.defaultBehavior,
          recommendedValue: missing.recommendedValue,
          consequences: missing.consequences,
          configurationExample: missing.example
        })),
        operationalRisk: this.assessOperationalRisk(missingConfigs),
        maintenanceImpact: this.assessMaintenanceImpact(missingConfigs),
        monitoringGaps: this.identifyMonitoringGaps(missingConfigs)
      });
      warnings.push(...missingConfigs);
    }
    
    return warnings;
  }
  
  checkVersionCompatibility(dependencies) {
    const compatibilityIssues = [];
    
    for (const dependency of dependencies) {
      const compatibility = this.checkDependencyCompatibility(dependency);
      
      if (!compatibility.fullyCompatible) {
        const issue = {
          dependency: dependency.name,
          currentVersion: dependency.version,
          issues: compatibility.issues,
          riskLevel: compatibility.riskLevel
        };
        
        this.logger.warn('Version compatibility issue detected', {
          dependencyName: dependency.name,
          currentVersion: dependency.version,
          compatibilityIssues: compatibility.issues.map(issue => ({
            type: issue.type, // 'breaking_change', 'deprecated_api', 'security_vulnerability'
            severity: issue.severity,
            description: issue.description,
            affectedFeatures: issue.affectedFeatures,
            introducedInVersion: issue.introducedInVersion,
            fixedInVersion: issue.fixedInVersion
          })),
          riskAssessment: {
            riskLevel: compatibility.riskLevel,
            businessImpact: compatibility.businessImpact,
            technicalImpact: compatibility.technicalImpact,
            timeToAddress: compatibility.timeToAddress
          },
          recommendations: {
            recommendedVersion: compatibility.recommendedVersion,
            migrationStrategy: compatibility.migrationStrategy,
            testingRequirements: compatibility.testingRequirements,
            rollbackPlan: compatibility.rollbackPlan
          },
          alternatives: {
            alternativeVersions: compatibility.alternativeVersions,
            alternativePackages: compatibility.alternativePackages,
            workarounds: compatibility.workarounds
          }
        });
        
        compatibilityIssues.push(issue);
      }
    }
    
    return compatibilityIssues;
  }
  
  monitorEnvironmentDrift(currentEnv, expectedEnv) {
    const driftDetection = this.detectEnvironmentDrift(currentEnv, expectedEnv);
    
    if (driftDetection.hasDrift) {
      this.logger.warn('Environment configuration drift detected', {
        environment: currentEnv.name,
        driftSummary: {
          totalDifferences: driftDetection.differences.length,
          criticalDifferences: driftDetection.critical.length,
          warningDifferences: driftDetection.warnings.length,
          infoDifferences: driftDetection.info.length
        },
        criticalDrift: driftDetection.critical.map(drift => ({
          setting: drift.setting,
          currentValue: drift.currentValue,
          expectedValue: drift.expectedValue,
          impact: drift.impact,
          lastChanged: drift.lastChanged,
          changedBy: drift.changedBy,
          reason: drift.reason
        })),
        driftAnalysis: {
          driftTrend: this.analyzeDriftTrend(currentEnv.name),
          mostCommonDrifts: this.getMostCommonDrifts(),
          driftFrequency: this.calculateDriftFrequency(currentEnv.name),
          stabilityScore: this.calculateEnvironmentStability(currentEnv.name)
        },
        remediation: {
          autoFixable: driftDetection.autoFixable,
          manualFixRequired: driftDetection.manualFixRequired,
          approvalRequired: driftDetection.approvalRequired,
          estimatedRemediationTime: this.estimateRemediationTime(driftDetection)
        },
        compliance: {
          complianceViolations: this.identifyComplianceViolations(driftDetection),
          auditRequirements: this.getAuditRequirements(driftDetection),
          governanceActions: this.getRequiredGovernanceActions(driftDetection)
        }
      });
    }
  }
}
```

## When to Use WARN Logging

### 1. **Performance Degradation**
- Response times exceeding acceptable thresholds
- Memory usage approaching limits
- Connection pool utilization issues
- Queue backlogs building up

### 2. **Resource Constraints**
- Disk space running low
- File descriptor exhaustion approaching
- Rate limits being approached
- External service quotas nearly exhausted

### 3. **Configuration Issues**
- Deprecated settings in use
- Insecure configurations
- Missing recommended configurations
- Version compatibility problems

### 4. **Operational Anomalies**
- Unusual traffic patterns
- Unexpected error rate increases
- Service degradation indicators
- Security policy violations

## Best Practices for WARN Logging

### 1. **Actionable Warnings**
```javascript
// Actionable warning logging
class ActionableWarningLogger {
  constructor(logger) {
    this.logger = logger;
  }
  
  warn(message, data = {}) {
    this.logger.warn(message, {
      ...data,
      // Always include actionable information
      recommendations: data.recommendations || this.generateRecommendations(data),
      urgency: data.urgency || this.assessUrgency(data),
      impact: data.impact || this.assessImpact(data),
      timeToAddress: data.timeToAddress || this.estimateTimeToAddress(data),
      monitoringUrl: this.generateMonitoringUrl(data),
      documentationUrl: this.generateDocumentationUrl(data)
    });
  }
  
  generateRecommendations(data) {
    // Generate context-specific recommendations
    return [
      'Monitor the situation closely',
      'Consider scaling resources',
      'Review configuration settings',
      'Check system health dashboard'
    ];
  }
}
```

### 2. **Threshold-Based Warnings**
```javascript
// Threshold-based warning system
class ThresholdWarningSystem {
  constructor(logger) {
    this.logger = logger;
    this.thresholds = new Map();
    this.warningCooldowns = new Map();
  }
  
  setThreshold(metric, warning, critical, cooldown = 300000) { // 5 minutes
    this.thresholds.set(metric, { warning, critical, cooldown });
  }
  
  checkThreshold(metric, value, context = {}) {
    const threshold = this.thresholds.get(metric);
    if (!threshold) return;
    
    const lastWarning = this.warningCooldowns.get(metric);
    const now = Date.now();
    
    // Respect cooldown period
    if (lastWarning && (now - lastWarning) < threshold.cooldown) {
      return;
    }
    
    if (value >= threshold.critical) {
      this.logger.error(`Critical threshold exceeded for ${metric}`, {
        metric,
        value,
        threshold: threshold.critical,
        severity: 'critical',
        ...context
      });
    } else if (value >= threshold.warning) {
      this.logger.warn(`Warning threshold exceeded for ${metric}`, {
        metric,
        value,
        threshold: threshold.warning,
        severity: 'warning',
        ...context
      });
      
      this.warningCooldowns.set(metric, now);
    }
  }
}
```

### 3. **Progressive Warning Escalation**
```javascript
// Progressive warning escalation
class ProgressiveWarningSystem {
  constructor(logger) {
    this.logger = logger;
    this.warningStates = new Map();
  }
  
  escalateWarning(condition, severity, data = {}) {
    const state = this.warningStates.get(condition) || {
      level: 0,
      firstSeen: Date.now(),
      lastSeen: Date.now(),
      count: 0
    };
    
    state.lastSeen = Date.now();
    state.count++;
    
    // Escalate based on persistence
    const duration = state.lastSeen - state.firstSeen;
    if (duration > 300000 && state.level < 3) { // 5 minutes
      state.level++;
    }
    
    const escalationLevels = ['initial', 'persistent', 'chronic', 'critical'];
    
    this.logger.warn(`${escalationLevels[state.level]} warning: ${condition}`, {
      condition,
      severity,
      escalationLevel: state.level,
      escalationName: escalationLevels[state.level],
      duration,
      occurrenceCount: state.count,
      urgency: this.calculateUrgency(state.level, duration),
      ...data
    });
    
    this.warningStates.set(condition, state);
  }
}
```

---

**Previous**: [2.1.3 INFO: General Information](./2.1.3_INFO_General_Information.md)  
**Next**: [2.1.5 ERROR: Error Conditions](./2.1.5_ERROR_Error_Conditions.md)
