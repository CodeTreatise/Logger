# 2.1.7 Choosing Appropriate Log Levels

## Guidelines for Log Level Selection

Choosing the appropriate log level is crucial for effective logging strategy. The right log level ensures that important information is captured without overwhelming the logging system or obscuring critical events. This guide provides comprehensive criteria and decision-making frameworks for selecting optimal log levels in different scenarios.

## Log Level Decision Framework

### 1. **Impact-Based Classification System**
A systematic approach to choosing log levels based on impact assessment.

```javascript
// Impact-based log level decision system
class LogLevelDecisionEngine {
  constructor(logger) {
    this.logger = logger;
    this.impactCriteria = this.setupImpactCriteria();
    this.contextualFactors = this.setupContextualFactors();
    this.environmentRules = this.setupEnvironmentRules();
  }
  
  // Primary log level decision method
  determineLogLevel(event, context = {}) {
    const analysis = this.analyzeEvent(event, context);
    const logLevel = this.calculateOptimalLevel(analysis);
    
    // Log the decision for transparency
    this.logger.debug('Log level decision', {
      event: event.type,
      analysis,
      decidedLevel: logLevel,
      reasoning: this.getDecisionReasoning(analysis, logLevel),
      context: context
    });
    
    return logLevel;
  }
  
  analyzeEvent(event, context) {
    return {
      // Business impact assessment
      businessImpact: this.assessBusinessImpact(event, context),
      
      // Technical impact assessment
      technicalImpact: this.assessTechnicalImpact(event, context),
      
      // User impact assessment
      userImpact: this.assessUserImpact(event, context),
      
      // Operational impact assessment
      operationalImpact: this.assessOperationalImpact(event, context),
      
      // Security impact assessment
      securityImpact: this.assessSecurityImpact(event, context),
      
      // Performance impact assessment
      performanceImpact: this.assessPerformanceImpact(event, context),
      
      // Compliance impact assessment
      complianceImpact: this.assessComplianceImpact(event, context),
      
      // Frequency and volume analysis
      frequency: this.analyzeEventFrequency(event),
      
      // Contextual factors
      environment: context.environment || process.env.NODE_ENV,
      component: context.component,
      criticality: context.criticality || 'medium',
      audience: context.audience || ['developers', 'operations']
    };
  }
  
  assessBusinessImpact(event, context) {
    const businessCriteria = {
      // Revenue impact
      revenueImpact: {
        none: 0,        // No revenue impact
        minimal: 1,     // < $1K potential impact
        moderate: 2,    // $1K - $10K potential impact
        significant: 3, // $10K - $100K potential impact
        critical: 4,    // > $100K potential impact
        severe: 5       // Major revenue loss or business disruption
      },
      
      // Customer impact
      customerImpact: {
        none: 0,        // No customer impact
        minimal: 1,     // Individual customer inconvenience
        moderate: 2,    // Multiple customers affected
        significant: 3, // Large customer segment affected
        critical: 4,    // Major customer experience degradation
        severe: 5       // Service unavailable to customers
      },
      
      // Business process impact
      processImpact: {
        none: 0,        // No process impact
        minimal: 1,     // Minor process delay
        moderate: 2,    // Process degradation
        significant: 3, // Process disruption
        critical: 4,    // Critical process failure
        severe: 5       // Business continuity threat
      },
      
      // Compliance and legal impact
      complianceImpact: {
        none: 0,        // No compliance issues
        minimal: 1,     // Minor compliance concern
        moderate: 2,    // Potential compliance violation
        significant: 3, // Likely compliance violation
        critical: 4,    // Definite compliance violation
        severe: 5       // Legal/regulatory violation
      },
      
      // Reputation impact
      reputationImpact: {
        none: 0,        // No reputation impact
        minimal: 1,     // Minor internal concern
        moderate: 2,    // Customer complaints possible
        significant: 3, // Public relations concern
        critical: 4,    // Brand damage risk
        severe: 5       // Major reputation damage
      }
    };
    
    // Calculate overall business impact score
    const scores = this.calculateImpactScores(event, context, businessCriteria);
    const maxScore = Math.max(...Object.values(scores));
    const avgScore = Object.values(scores).reduce((a, b) => a + b, 0) / Object.values(scores).length;
    
    return {
      scores,
      maxScore,
      avgScore,
      severity: this.scoresToSeverity(maxScore, avgScore),
      reasoning: this.getImpactReasoning(scores, businessCriteria)
    };
  }
  
  assessTechnicalImpact(event, context) {
    const technicalCriteria = {
      // System availability
      availability: {
        none: 0,        // No availability impact
        minimal: 1,     // < 0.1% availability impact
        moderate: 2,    // 0.1% - 1% availability impact
        significant: 3, // 1% - 5% availability impact
        critical: 4,    // 5% - 20% availability impact
        severe: 5       // > 20% availability impact or complete outage
      },
      
      // Performance degradation
      performance: {
        none: 0,        // No performance impact
        minimal: 1,     // < 5% performance degradation
        moderate: 2,    // 5% - 15% performance degradation
        significant: 3, // 15% - 30% performance degradation
        critical: 4,    // 30% - 60% performance degradation
        severe: 5       // > 60% performance degradation
      },
      
      // Data integrity
      dataIntegrity: {
        none: 0,        // No data integrity issues
        minimal: 1,     // Minor data inconsistency
        moderate: 2,    // Data validation failures
        significant: 3, // Data corruption risk
        critical: 4,    // Data corruption detected
        severe: 5       // Massive data loss or corruption
      },
      
      // Security posture
      security: {
        none: 0,        // No security implications
        minimal: 1,     // Minor security logging
        moderate: 2,    // Security event detected
        significant: 3, // Security violation
        critical: 4,    // Security breach attempt
        severe: 5       // Security breach confirmed
      },
      
      // System resource impact
      resources: {
        none: 0,        // No resource impact
        minimal: 1,     // < 5% resource increase
        moderate: 2,    // 5% - 15% resource increase
        significant: 3, // 15% - 30% resource increase
        critical: 4,    // 30% - 60% resource increase
        severe: 5       // > 60% resource increase or exhaustion
      }
    };
    
    const scores = this.calculateImpactScores(event, context, technicalCriteria);
    const maxScore = Math.max(...Object.values(scores));
    const avgScore = Object.values(scores).reduce((a, b) => a + b, 0) / Object.values(scores).length;
    
    return {
      scores,
      maxScore,
      avgScore,
      severity: this.scoresToSeverity(maxScore, avgScore),
      reasoning: this.getImpactReasoning(scores, technicalCriteria)
    };
  }
  
  calculateOptimalLevel(analysis) {
    const { businessImpact, technicalImpact, userImpact, operationalImpact, 
            securityImpact, performanceImpact, complianceImpact, frequency, environment } = analysis;
    
    // Calculate weighted severity score
    const weightedScore = this.calculateWeightedSeverity({
      business: businessImpact.maxScore * 0.25,      // 25% weight
      technical: technicalImpact.maxScore * 0.20,    // 20% weight
      user: userImpact.maxScore * 0.15,              // 15% weight
      operational: operationalImpact.maxScore * 0.15, // 15% weight
      security: securityImpact.maxScore * 0.15,      // 15% weight
      performance: performanceImpact.maxScore * 0.05, // 5% weight
      compliance: complianceImpact.maxScore * 0.05   // 5% weight
    });
    
    // Apply frequency adjustments
    const frequencyAdjustedScore = this.applyFrequencyAdjustment(weightedScore, frequency);
    
    // Apply environment-specific rules
    const environmentAdjustedScore = this.applyEnvironmentAdjustment(frequencyAdjustedScore, environment);
    
    // Convert score to log level
    return this.scoreToLogLevel(environmentAdjustedScore, analysis);
  }
  
  scoreToLogLevel(score, analysis) {
    // Base log level mapping
    const baseLevelMapping = {
      0.0: 'trace',   // 0.0 - 0.5: Finest detail
      0.5: 'trace',   
      1.0: 'debug',   // 1.0 - 1.5: Development information
      1.5: 'debug',   
      2.0: 'info',    // 2.0 - 2.5: General information
      2.5: 'info',    
      3.0: 'warn',    // 3.0 - 3.5: Warning conditions
      3.5: 'warn',    
      4.0: 'error',   // 4.0 - 4.5: Error conditions
      4.5: 'error',   
      5.0: 'fatal'    // 5.0: Fatal conditions
    };
    
    // Find the appropriate level
    const scoreKeys = Object.keys(baseLevelMapping).map(Number).sort((a, b) => a - b);
    let selectedLevel = 'info'; // default
    
    for (let i = scoreKeys.length - 1; i >= 0; i--) {
      if (score >= scoreKeys[i]) {
        selectedLevel = baseLevelMapping[scoreKeys[i]];
        break;
      }
    }
    
    // Apply special case overrides
    selectedLevel = this.applySpecialCaseOverrides(selectedLevel, score, analysis);
    
    return selectedLevel;
  }
  
  applySpecialCaseOverrides(baseLevel, score, analysis) {
    let adjustedLevel = baseLevel;
    
    // Security events get elevated
    if (analysis.securityImpact.maxScore >= 4) {
      adjustedLevel = this.elevateLevel(adjustedLevel, 'error');
    }
    
    // Data integrity issues get elevated
    if (analysis.technicalImpact.scores.dataIntegrity >= 4) {
      adjustedLevel = this.elevateLevel(adjustedLevel, 'error');
    }
    
    // System availability issues get elevated
    if (analysis.technicalImpact.scores.availability >= 4) {
      adjustedLevel = this.elevateLevel(adjustedLevel, 'error');
    }
    
    // Fatal conditions override everything
    if (score >= 5.0 || 
        analysis.businessImpact.maxScore >= 5 || 
        analysis.technicalImpact.maxScore >= 5) {
      adjustedLevel = 'fatal';
    }
    
    // High-frequency events get demoted in production
    if (analysis.environment === 'production' && analysis.frequency.eventsPerMinute > 100) {
      adjustedLevel = this.demoteLevel(adjustedLevel, 1);
    }
    
    // Development environment allows more verbose logging
    if (analysis.environment === 'development') {
      adjustedLevel = this.demoteLevel(adjustedLevel, 1);
    }
    
    return adjustedLevel;
  }
}
```

### 2. **Context-Aware Log Level Selection**
Dynamic log level selection based on operational context.

```javascript
// Context-aware log level selection
class ContextualLogLevelSelector {
  constructor(logger) {
    this.logger = logger;
    this.contextRules = this.setupContextRules();
    this.adaptiveThresholds = this.setupAdaptiveThresholds();
  }
  
  selectLogLevel(message, data, context = {}) {
    const enrichedContext = this.enrichContext(context);
    const logLevel = this.determineContextualLevel(message, data, enrichedContext);
    
    return {
      level: logLevel,
      reasoning: this.getSelectionReasoning(logLevel, enrichedContext),
      adjustments: this.getAppliedAdjustments(logLevel, enrichedContext)
    };
  }
  
  enrichContext(baseContext) {
    return {
      ...baseContext,
      
      // Temporal context
      temporal: {
        timestamp: new Date(),
        businessHours: this.isBusinessHours(),
        maintenanceWindow: this.isMaintenanceWindow(),
        peakTraffic: this.isPeakTrafficPeriod(),
        weekday: this.isWeekday(),
        holiday: this.isHoliday()
      },
      
      // System context
      system: {
        environment: process.env.NODE_ENV,
        loadLevel: this.getCurrentLoadLevel(),
        errorRate: this.getCurrentErrorRate(),
        responseTime: this.getCurrentResponseTime(),
        resourceUtilization: this.getResourceUtilization(),
        activeUsers: this.getActiveUserCount()
      },
      
      // Operational context
      operational: {
        onCallStatus: this.getOnCallStatus(),
        incidentActive: this.isIncidentActive(),
        deploymentActive: this.isDeploymentActive(),
        alertingState: this.getAlertingState(),
        monitoringMode: this.getMonitoringMode()
      },
      
      // Business context
      business: {
        businessCriticalOperation: this.isBusinessCriticalOperation(baseContext),
        customerImpact: this.hasCustomerImpact(baseContext),
        complianceRelevant: this.isComplianceRelevant(baseContext),
        auditRequired: this.isAuditRequired(baseContext),
        financialImpact: this.hasFinancialImpact(baseContext)
      },
      
      // Component context
      component: {
        criticality: baseContext.criticality || this.assessComponentCriticality(baseContext.component),
        healthStatus: this.getComponentHealthStatus(baseContext.component),
        dependencies: this.getComponentDependencies(baseContext.component),
        slaRequirements: this.getComponentSLARequirements(baseContext.component),
        errorHistory: this.getComponentErrorHistory(baseContext.component)
      }
    };
  }
  
  determineContextualLevel(message, data, context) {
    const baseLevel = this.getBaseLogLevel(message, data);
    let adjustedLevel = baseLevel;
    
    // Apply temporal adjustments
    adjustedLevel = this.applyTemporalAdjustments(adjustedLevel, context.temporal);
    
    // Apply system load adjustments
    adjustedLevel = this.applySystemLoadAdjustments(adjustedLevel, context.system);
    
    // Apply operational adjustments
    adjustedLevel = this.applyOperationalAdjustments(adjustedLevel, context.operational);
    
    // Apply business criticality adjustments
    adjustedLevel = this.applyBusinessAdjustments(adjustedLevel, context.business);
    
    // Apply component-specific adjustments
    adjustedLevel = this.applyComponentAdjustments(adjustedLevel, context.component);
    
    return adjustedLevel;
  }
  
  applyTemporalAdjustments(level, temporal) {
    let adjustedLevel = level;
    
    // During business hours, elevate important events
    if (temporal.businessHours && this.isImportantEvent(level)) {
      adjustedLevel = this.elevateLevel(adjustedLevel);
    }
    
    // During maintenance windows, demote routine events
    if (temporal.maintenanceWindow && this.isRoutineEvent(level)) {
      adjustedLevel = this.demoteLevel(adjustedLevel);
    }
    
    // During peak traffic, be more selective
    if (temporal.peakTraffic) {
      adjustedLevel = this.applyPeakTrafficFilter(adjustedLevel);
    }
    
    // During off-hours, elevate errors for on-call visibility
    if (!temporal.businessHours && level === 'error') {
      adjustedLevel = this.elevateLevel(adjustedLevel);
    }
    
    return adjustedLevel;
  }
  
  applySystemLoadAdjustments(level, system) {
    let adjustedLevel = level;
    
    // High load conditions - reduce verbose logging
    if (system.loadLevel === 'high') {
      if (['trace', 'debug'].includes(level)) {
        adjustedLevel = 'info';
      }
    }
    
    // Critical load conditions - only errors and above
    if (system.loadLevel === 'critical') {
      if (['trace', 'debug', 'info'].includes(level)) {
        adjustedLevel = 'warn';
      }
    }
    
    // High error rate - elevate warnings to errors
    if (system.errorRate > 0.05 && level === 'warn') { // > 5% error rate
      adjustedLevel = 'error';
    }
    
    // Poor response times - elevate performance warnings
    if (system.responseTime > 5000 && level === 'warn') { // > 5 seconds
      adjustedLevel = 'error';
    }
    
    return adjustedLevel;
  }
}
```

### 3. **Environment-Specific Log Level Strategies**
Tailored log level strategies for different environments.

```javascript
// Environment-specific log level strategies
class EnvironmentLogLevelStrategy {
  constructor(logger) {
    this.logger = logger;
    this.strategies = this.setupEnvironmentStrategies();
  }
  
  getEnvironmentStrategy(environment) {
    return this.strategies[environment] || this.strategies.default;
  }
  
  setupEnvironmentStrategies() {
    return {
      // Development environment strategy
      development: {
        description: 'Verbose logging for development and debugging',
        defaultLevel: 'debug',
        levelMappings: {
          trace: 'trace',    // Keep all trace logs
          debug: 'debug',    // Keep all debug logs
          info: 'info',      // Keep all info logs
          warn: 'warn',      // Keep all warnings
          error: 'error',    // Keep all errors
          fatal: 'fatal'     // Keep all fatal logs
        },
        specialRules: [
          {
            condition: 'high_frequency_event',
            action: 'sample',
            rate: 0.1 // Sample 10% of high-frequency events
          },
          {
            condition: 'performance_trace',
            action: 'elevate',
            from: 'trace',
            to: 'debug'
          }
        ],
        volumeControls: {
          maxLogsPerSecond: 1000,
          burstAllowance: 5000,
          backpressureHandling: 'queue'
        }
      },
      
      // Testing environment strategy
      testing: {
        description: 'Balanced logging for testing environments',
        defaultLevel: 'info',
        levelMappings: {
          trace: 'debug',    // Promote trace to debug
          debug: 'debug',    // Keep debug logs
          info: 'info',      // Keep info logs
          warn: 'warn',      // Keep warnings
          error: 'error',    // Keep errors
          fatal: 'fatal'     // Keep fatal logs
        },
        specialRules: [
          {
            condition: 'test_execution',
            action: 'elevate',
            description: 'Elevate test-related logs'
          },
          {
            condition: 'assertion_failure',
            action: 'force_level',
            level: 'error'
          }
        ],
        volumeControls: {
          maxLogsPerSecond: 500,
          burstAllowance: 2000,
          backpressureHandling: 'drop'
        }
      },
      
      // Staging environment strategy
      staging: {
        description: 'Production-like logging with additional debugging',
        defaultLevel: 'info',
        levelMappings: {
          trace: 'suppress', // Suppress trace logs
          debug: 'info',     // Promote debug to info
          info: 'info',      // Keep info logs
          warn: 'warn',      // Keep warnings
          error: 'error',    // Keep errors
          fatal: 'fatal'     // Keep fatal logs
        },
        specialRules: [
          {
            condition: 'deployment_activity',
            action: 'temporary_elevation',
            duration: '1h',
            elevateFrom: 'debug',
            elevateTo: 'info'
          },
          {
            condition: 'load_testing',
            action: 'sample',
            rate: 0.01 // Sample 1% during load testing
          }
        ],
        volumeControls: {
          maxLogsPerSecond: 200,
          burstAllowance: 1000,
          backpressureHandling: 'throttle'
        }
      },
      
      // Production environment strategy
      production: {
        description: 'Optimized logging for production performance',
        defaultLevel: 'warn',
        levelMappings: {
          trace: 'suppress', // Suppress trace logs
          debug: 'suppress', // Suppress debug logs
          info: 'info',      // Keep info logs
          warn: 'warn',      // Keep warnings
          error: 'error',    // Keep errors
          fatal: 'fatal'     // Keep fatal logs
        },
        specialRules: [
          {
            condition: 'business_critical_operation',
            action: 'force_level',
            level: 'info',
            description: 'Always log business-critical operations'
          },
          {
            condition: 'security_event',
            action: 'elevate',
            from: 'info',
            to: 'warn',
            description: 'Elevate security events'
          },
          {
            condition: 'performance_degradation',
            action: 'temporary_elevation',
            duration: '10m',
            elevateFrom: 'info',
            elevateTo: 'warn'
          },
          {
            condition: 'incident_mode',
            action: 'global_elevation',
            elevateBy: 1,
            description: 'Elevate all logs during incidents'
          }
        ],
        volumeControls: {
          maxLogsPerSecond: 100,
          burstAllowance: 500,
          backpressureHandling: 'circuit_breaker'
        },
        adaptiveControls: {
          errorRateThreshold: 0.01, // 1% error rate
          responseTimeThreshold: 2000, // 2 seconds
          memoryThreshold: 0.8, // 80% memory usage
          cpuThreshold: 0.7, // 70% CPU usage
          adaptiveActions: [
            'reduce_verbosity',
            'increase_sampling',
            'activate_circuit_breaker'
          ]
        }
      },
      
      // Default fallback strategy
      default: {
        description: 'Conservative default logging strategy',
        defaultLevel: 'info',
        levelMappings: {
          trace: 'suppress',
          debug: 'suppress',
          info: 'info',
          warn: 'warn',
          error: 'error',
          fatal: 'fatal'
        },
        volumeControls: {
          maxLogsPerSecond: 50,
          burstAllowance: 200,
          backpressureHandling: 'drop'
        }
      }
    };
  }
  
  applyEnvironmentStrategy(level, message, context) {
    const environment = context.environment || process.env.NODE_ENV || 'default';
    const strategy = this.getEnvironmentStrategy(environment);
    
    // Apply level mapping
    let adjustedLevel = strategy.levelMappings[level] || level;
    
    // Handle suppression
    if (adjustedLevel === 'suppress') {
      return null; // Don't log
    }
    
    // Apply special rules
    adjustedLevel = this.applySpecialRules(adjustedLevel, message, context, strategy.specialRules);
    
    // Apply volume controls
    const shouldLog = this.checkVolumeControls(adjustedLevel, strategy.volumeControls);
    
    if (!shouldLog) {
      return null; // Don't log due to volume controls
    }
    
    // Apply adaptive controls (production only)
    if (strategy.adaptiveControls) {
      adjustedLevel = this.applyAdaptiveControls(adjustedLevel, strategy.adaptiveControls);
    }
    
    return adjustedLevel;
  }
}
```

## Decision Trees and Flowcharts

### 1. **Log Level Decision Tree**
```javascript
// Log level decision tree implementation
class LogLevelDecisionTree {
  constructor() {
    this.decisionTree = this.buildDecisionTree();
  }
  
  buildDecisionTree() {
    return {
      // Root question: What type of event is this?
      question: 'event_type',
      branches: {
        // System failure or critical error
        system_failure: {
          question: 'system_impact',
          branches: {
            complete_outage: { level: 'fatal' },
            partial_outage: { level: 'error' },
            degraded_performance: { level: 'warn' },
            minor_issue: { level: 'info' }
          }
        },
        
        // Security-related event
        security_event: {
          question: 'security_severity',
          branches: {
            breach_confirmed: { level: 'fatal' },
            breach_attempted: { level: 'error' },
            suspicious_activity: { level: 'warn' },
            security_info: { level: 'info' }
          }
        },
        
        // Business operation
        business_operation: {
          question: 'business_criticality',
          branches: {
            mission_critical: {
              question: 'operation_result',
              branches: {
                failure: { level: 'error' },
                warning: { level: 'warn' },
                success: { level: 'info' }
              }
            },
            important: {
              question: 'operation_result',
              branches: {
                failure: { level: 'warn' },
                warning: { level: 'info' },
                success: { level: 'info' }
              }
            },
            routine: {
              question: 'environment',
              branches: {
                production: { level: 'debug' },
                development: { level: 'trace' }
              }
            }
          }
        },
        
        // Application error
        application_error: {
          question: 'error_recoverability',
          branches: {
            unrecoverable: { level: 'fatal' },
            recoverable_with_impact: { level: 'error' },
            recoverable_no_impact: { level: 'warn' },
            handled_gracefully: { level: 'info' }
          }
        },
        
        // Performance event
        performance_event: {
          question: 'performance_impact',
          branches: {
            severe_degradation: { level: 'error' },
            moderate_degradation: { level: 'warn' },
            minor_degradation: { level: 'info' },
            performance_info: { level: 'debug' }
          }
        },
        
        // User activity
        user_activity: {
          question: 'activity_significance',
          branches: {
            security_relevant: { level: 'warn' },
            business_relevant: { level: 'info' },
            routine_activity: { level: 'debug' },
            detailed_tracking: { level: 'trace' }
          }
        },
        
        // Development/debugging
        development_debug: {
          question: 'debug_level',
          branches: {
            critical_debug: { level: 'debug' },
            detailed_trace: { level: 'trace' }
          }
        }
      }
    };
  }
  
  traverseDecisionTree(eventData, currentNode = this.decisionTree) {
    // If we've reached a leaf node with a level, return it
    if (currentNode.level) {
      return currentNode.level;
    }
    
    // Get the answer to the current question
    const answer = this.getAnswerToQuestion(currentNode.question, eventData);
    
    // Find the matching branch
    const nextNode = currentNode.branches[answer];
    
    if (!nextNode) {
      // No matching branch, return default
      return 'info';
    }
    
    // Recursively traverse to the next node
    return this.traverseDecisionTree(eventData, nextNode);
  }
  
  getAnswerToQuestion(question, eventData) {
    switch (question) {
      case 'event_type':
        return this.classifyEventType(eventData);
      
      case 'system_impact':
        return this.assessSystemImpact(eventData);
      
      case 'security_severity':
        return this.assessSecuritySeverity(eventData);
      
      case 'business_criticality':
        return this.assessBusinessCriticality(eventData);
      
      case 'operation_result':
        return this.assessOperationResult(eventData);
      
      case 'error_recoverability':
        return this.assessErrorRecoverability(eventData);
      
      case 'performance_impact':
        return this.assessPerformanceImpact(eventData);
      
      case 'activity_significance':
        return this.assessActivitySignificance(eventData);
      
      case 'debug_level':
        return this.assessDebugLevel(eventData);
      
      case 'environment':
        return eventData.environment || process.env.NODE_ENV || 'production';
      
      default:
        return 'unknown';
    }
  }
}
```

## Common Log Level Selection Scenarios

### 1. **Typical Use Cases by Level**
```javascript
// Common scenarios and their appropriate log levels
const logLevelScenarios = {
  fatal: [
    'Application crash due to uncaught exception',
    'Database connection pool exhausted',
    'Critical security breach detected',
    'System running out of disk space',
    'Core service unavailable',
    'Data corruption detected',
    'Memory exhaustion causing termination',
    'Infrastructure failure causing outage'
  ],
  
  error: [
    'API request failed with 500 error',
    'Database transaction rolled back',
    'File upload failed due to storage error',
    'Payment processing failed',
    'User authentication failed multiple times',
    'External service integration error',
    'Configuration validation failed',
    'Background job processing failed'
  ],
  
  warn: [
    'API response time exceeded threshold',
    'Database connection pool reaching capacity',
    'Deprecated API endpoint used',
    'Configuration value missing, using default',
    'Rate limit approaching',
    'Cache miss rate higher than expected',
    'Temporary service degradation',
    'Non-critical validation failed'
  ],
  
  info: [
    'User successfully logged in',
    'Order processed successfully',
    'Scheduled job completed',
    'Application startup completed',
    'Configuration loaded',
    'Cache refreshed',
    'Health check passed',
    'Business metric reached milestone'
  ],
  
  debug: [
    'Method entry/exit for complex operations',
    'Variable values during troubleshooting',
    'Algorithm decision points',
    'Configuration details during startup',
    'Performance timing details',
    'State transitions in workflows',
    'Detailed error context',
    'Integration testing information'
  ],
  
  trace: [
    'Every step in complex algorithms',
    'All variable assignments in critical paths',
    'Detailed request/response data',
    'Loop iterations and conditions',
    'Memory allocation details',
    'Network packet-level information',
    'Database query parameter binding',
    'Microscopic performance measurements'
  ]
};
```

### 2. **Anti-Patterns to Avoid**
```javascript
// Common log level selection mistakes
const logLevelAntiPatterns = {
  overElevation: {
    description: 'Using higher log levels than necessary',
    examples: [
      'Logging routine operations as errors',
      'Using warn for informational messages',
      'Elevating debug information to info level'
    ],
    consequences: [
      'Alert fatigue from false alarms',
      'Important events buried in noise',
      'Inefficient resource usage'
    ],
    solutions: [
      'Use impact-based classification',
      'Regular log level review',
      'Implement gradual elevation rules'
    ]
  },
  
  underElevation: {
    description: 'Using lower log levels than appropriate',
    examples: [
      'Logging errors as warnings',
      'Using debug for business-critical information',
      'Suppressing important failure information'
    ],
    consequences: [
      'Missing critical issues',
      'Delayed incident response',
      'Insufficient audit trails'
    ],
    solutions: [
      'Define clear escalation criteria',
      'Regular severity assessment',
      'Business impact evaluation'
    ]
  },
  
  inconsistentLeveling: {
    description: 'Inconsistent log levels across similar scenarios',
    examples: [
      'Same error logged at different levels',
      'Inconsistent business operation logging',
      'Different levels for similar failures'
    ],
    consequences: [
      'Confusing monitoring alerts',
      'Inconsistent user experience',
      'Difficult log analysis'
    ],
    solutions: [
      'Establish logging standards',
      'Code review for consistency',
      'Automated log level validation'
    ]
  }
};
```

---

**Previous**: [2.1.6 FATAL/CRITICAL: Severe Error Events](./2.1.6_FATAL_CRITICAL_Severe_Error_Events.md)  
**Next**: [2.2 Log Format and Structure](../2.2_Log_Format_and_Structure/README.md)
