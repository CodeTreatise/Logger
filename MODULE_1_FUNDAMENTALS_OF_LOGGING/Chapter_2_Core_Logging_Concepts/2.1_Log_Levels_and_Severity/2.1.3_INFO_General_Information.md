# 2.1.3 INFO: General Information

## Understanding INFO Level Logging

INFO is the standard logging level for recording general informational messages about the normal operation of an application. It provides a balanced view of application activity without overwhelming detail, making it suitable for production environments while still offering valuable insights into application behavior and business operations.

## Characteristics of INFO Logging

### 1. **Business Operation Tracking**
INFO level is ideal for tracking significant business operations and milestones.

```javascript
// Business operation INFO logging
class BusinessOperationLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'BusinessOperationLogger' });
    this.operationMetrics = {
      ordersProcessed: 0,
      paymentsCompleted: 0,
      usersRegistered: 0,
      reportsGenerated: 0
    };
  }
  
  async processOrder(order) {
    const operationId = this.generateOperationId();
    const startTime = Date.now();
    
    this.logger.info('Order processing started', {
      operationId,
      orderId: order.id,
      customerId: order.customerId,
      orderValue: order.totalAmount,
      currency: order.currency,
      itemCount: order.items.length,
      channel: order.channel, // 'web', 'mobile', 'api', 'store'
      priority: order.priority,
      timestamp: new Date().toISOString()
    });
    
    try {
      // Inventory check
      const inventoryResult = await this.checkInventory(order);
      this.logger.info('Inventory check completed', {
        operationId,
        orderId: order.id,
        inventoryStatus: inventoryResult.status, // 'available', 'partial', 'unavailable'
        availableItems: inventoryResult.availableItems,
        backorderItems: inventoryResult.backorderItems,
        estimatedFulfillment: inventoryResult.estimatedFulfillment
      });
      
      // Payment processing
      const paymentResult = await this.processPayment(order);
      this.logger.info('Payment processing completed', {
        operationId,
        orderId: order.id,
        paymentStatus: paymentResult.status, // 'success', 'failed', 'pending'
        paymentMethod: paymentResult.method,
        transactionId: paymentResult.transactionId,
        authorizationCode: paymentResult.authorizationCode,
        processingTime: paymentResult.processingTime
      });
      
      // Order fulfillment
      const fulfillmentResult = await this.initiateFulfillment(order);
      this.logger.info('Order fulfillment initiated', {
        operationId,
        orderId: order.id,
        fulfillmentMethod: fulfillmentResult.method, // 'standard', 'express', 'same_day'
        warehouseLocation: fulfillmentResult.warehouse,
        estimatedDelivery: fulfillmentResult.estimatedDelivery,
        trackingNumber: fulfillmentResult.trackingNumber,
        shippingCarrier: fulfillmentResult.carrier
      });
      
      // Order completion
      const completedOrder = await this.completeOrder(order, {
        inventory: inventoryResult,
        payment: paymentResult,
        fulfillment: fulfillmentResult
      });
      
      const endTime = Date.now();
      const processingTime = endTime - startTime;
      
      this.operationMetrics.ordersProcessed++;
      
      this.logger.info('Order processing completed successfully', {
        operationId,
        orderId: order.id,
        customerId: order.customerId,
        finalStatus: completedOrder.status,
        totalProcessingTime: processingTime,
        orderValue: order.totalAmount,
        profitMargin: completedOrder.profitMargin,
        customerSatisfactionScore: completedOrder.satisfactionScore,
        totalOrdersToday: this.operationMetrics.ordersProcessed
      });
      
      // Business intelligence logging
      this.logBusinessIntelligence(order, completedOrder, processingTime);
      
      return completedOrder;
      
    } catch (error) {
      const endTime = Date.now();
      const processingTime = endTime - startTime;
      
      this.logger.info('Order processing failed', {
        operationId,
        orderId: order.id,
        customerId: order.customerId,
        failureReason: error.message,
        failureStage: this.determineFailureStage(error),
        processingTime,
        orderValue: order.totalAmount,
        recoveryAction: this.determineRecoveryAction(error),
        customerNotified: await this.notifyCustomerOfFailure(order, error)
      });
      
      throw error;
    }
  }
  
  logBusinessIntelligence(order, completedOrder, processingTime) {
    this.logger.info('Business intelligence metrics', {
      orderId: order.id,
      businessMetrics: {
        revenue: order.totalAmount,
        profit: completedOrder.profit,
        margin: completedOrder.profitMargin,
        customerLifetimeValue: completedOrder.customerLifetimeValue,
        customerSegment: completedOrder.customerSegment,
        productCategories: this.extractProductCategories(order.items),
        seasonalityFactor: this.calculateSeasonalityFactor(),
        marketingAttribution: order.marketingAttribution
      },
      operationalMetrics: {
        processingTime,
        fulfillmentTime: completedOrder.fulfillmentTime,
        systemsInvolved: completedOrder.systemsInvolved,
        automationRate: completedOrder.automationRate,
        humanInterventionRequired: completedOrder.humanInterventionRequired
      },
      qualityMetrics: {
        orderAccuracy: completedOrder.accuracy,
        customerSatisfaction: completedOrder.satisfactionScore,
        onTimeDeliveryProbability: completedOrder.onTimeDeliveryProbability,
        returnRiskScore: completedOrder.returnRiskScore
      }
    });
  }
  
  async registerUser(userData) {
    const registrationId = this.generateRegistrationId();
    
    this.logger.info('User registration started', {
      registrationId,
      registrationSource: userData.source, // 'web', 'mobile', 'social', 'api'
      userType: userData.type, // 'individual', 'business', 'premium'
      referralSource: userData.referralSource,
      marketingCampaign: userData.campaignId,
      deviceInfo: userData.deviceInfo,
      geoLocation: userData.geoLocation
    });
    
    try {
      // Email verification
      const emailVerification = await this.initiateEmailVerification(userData.email);
      this.logger.info('Email verification initiated', {
        registrationId,
        email: this.maskEmail(userData.email),
        verificationMethod: emailVerification.method,
        verificationSent: emailVerification.sent,
        expirationTime: emailVerification.expirationTime
      });
      
      // User account creation
      const newUser = await this.createUserAccount(userData, registrationId);
      
      this.operationMetrics.usersRegistered++;
      
      this.logger.info('User registration completed successfully', {
        registrationId,
        userId: newUser.id,
        username: newUser.username,
        accountType: newUser.accountType,
        subscriptionTier: newUser.subscriptionTier,
        registrationTime: new Date().toISOString(),
        welcomeEmailSent: await this.sendWelcomeEmail(newUser),
        totalRegistrationsToday: this.operationMetrics.usersRegistered,
        onboardingFlow: newUser.onboardingFlow
      });
      
      // User analytics
      this.logUserAnalytics(newUser, userData);
      
      return newUser;
      
    } catch (error) {
      this.logger.info('User registration failed', {
        registrationId,
        email: this.maskEmail(userData.email),
        failureReason: error.message,
        failureStage: this.determineRegistrationFailureStage(error),
        userNotified: await this.notifyRegistrationFailure(userData, error),
        retryPossible: this.isRetryPossible(error)
      });
      
      throw error;
    }
  }
  
  logUserAnalytics(newUser, registrationData) {
    this.logger.info('User registration analytics', {
      userId: newUser.id,
      demographics: {
        ageGroup: this.determineAgeGroup(registrationData.birthDate),
        location: registrationData.geoLocation,
        deviceType: registrationData.deviceInfo.type,
        platform: registrationData.deviceInfo.platform
      },
      acquisition: {
        channel: registrationData.source,
        campaign: registrationData.campaignId,
        referrer: registrationData.referralSource,
        cost: this.calculateAcquisitionCost(registrationData),
        ltv_prediction: this.predictLifetimeValue(registrationData)
      },
      behavior: {
        registrationCompletionTime: registrationData.completionTime,
        formInteractions: registrationData.formInteractions,
        hesitationPoints: registrationData.hesitationPoints,
        assistanceRequired: registrationData.assistanceRequired
      }
    });
  }
}
```

### 2. **System Lifecycle and Health Monitoring**
INFO logging captures important system events and health indicators.

```javascript
// System lifecycle and health INFO logging
class SystemHealthLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'SystemHealthLogger' });
    this.healthMetrics = {
      uptime: 0,
      requestCount: 0,
      errorCount: 0,
      lastHealthCheck: null
    };
    
    // Start health monitoring
    this.startHealthMonitoring();
  }
  
  logApplicationStartup(config) {
    const startupInfo = {
      applicationName: config.name,
      version: config.version,
      environment: config.environment,
      nodeVersion: process.version,
      platform: process.platform,
      architecture: process.arch,
      pid: process.pid,
      startupTime: new Date().toISOString(),
      configurationProfile: config.profile,
      databaseConnections: config.database?.connections || 0,
      cacheConfiguration: config.cache?.type || 'none',
      externalServices: Object.keys(config.externalServices || {}),
      featureFlags: Object.keys(config.featureFlags || {}),
      memoryLimit: config.memoryLimit || 'unlimited',
      cpuCores: require('os').cpus().length,
      totalMemory: require('os').totalmem(),
      freeMemory: require('os').freemem()
    };
    
    this.logger.info('Application startup initiated', startupInfo);
    
    // Log configuration summary (sanitized)
    this.logger.info('Configuration loaded', {
      configSections: Object.keys(config),
      databaseType: config.database?.type,
      logLevel: config.logging?.level,
      serverPort: config.server?.port,
      enabledFeatures: this.getEnabledFeatures(config),
      securitySettings: this.getSecuritySettings(config),
      performanceSettings: this.getPerformanceSettings(config)
    });
  }
  
  logApplicationReady(services, timing) {
    this.logger.info('Application startup completed successfully', {
      status: 'ready',
      totalStartupTime: timing.total,
      serviceInitializationTime: timing.services,
      databaseConnectionTime: timing.database,
      cacheInitializationTime: timing.cache,
      middlewareSetupTime: timing.middleware,
      routeRegistrationTime: timing.routes,
      initializedServices: services.map(s => ({
        name: s.name,
        status: s.status,
        initTime: s.initTime,
        healthCheck: s.healthCheck
      })),
      serverListening: true,
      readinessProbe: '/health/ready',
      livenessProbe: '/health/live',
      metricsEndpoint: '/metrics'
    });
    
    this.healthMetrics.uptime = Date.now();
  }
  
  async performHealthCheck() {
    const healthCheckStart = Date.now();
    
    const healthStatus = {
      timestamp: new Date().toISOString(),
      status: 'healthy',
      checks: {}
    };
    
    try {
      // Database health check
      healthStatus.checks.database = await this.checkDatabaseHealth();
      
      // Cache health check
      healthStatus.checks.cache = await this.checkCacheHealth();
      
      // External services health check
      healthStatus.checks.externalServices = await this.checkExternalServicesHealth();
      
      // System resources check
      healthStatus.checks.systemResources = this.checkSystemResources();
      
      // Application metrics check
      healthStatus.checks.applicationMetrics = this.checkApplicationMetrics();
      
      const healthCheckEnd = Date.now();
      healthStatus.checkDuration = healthCheckEnd - healthCheckStart;
      
      // Determine overall health
      const allChecksHealthy = Object.values(healthStatus.checks)
        .every(check => check.status === 'healthy');
      
      healthStatus.status = allChecksHealthy ? 'healthy' : 'degraded';
      
      this.logger.info('Health check completed', healthStatus);
      
      this.healthMetrics.lastHealthCheck = Date.now();
      return healthStatus;
      
    } catch (error) {
      const healthCheckEnd = Date.now();
      
      this.logger.info('Health check failed', {
        timestamp: new Date().toISOString(),
        status: 'unhealthy',
        error: error.message,
        checkDuration: healthCheckEnd - healthCheckStart,
        partialResults: healthStatus.checks
      });
      
      throw error;
    }
  }
  
  logPeriodicMetrics() {
    const currentTime = Date.now();
    const uptime = currentTime - this.healthMetrics.uptime;
    
    this.logger.info('Periodic system metrics', {
      timestamp: new Date().toISOString(),
      uptime: {
        milliseconds: uptime,
        human: this.formatUptime(uptime)
      },
      requests: {
        total: this.healthMetrics.requestCount,
        rate: this.calculateRequestRate(),
        errors: this.healthMetrics.errorCount,
        errorRate: (this.healthMetrics.errorCount / this.healthMetrics.requestCount) * 100
      },
      memory: {
        usage: process.memoryUsage(),
        heapUsed: process.memoryUsage().heapUsed,
        heapTotal: process.memoryUsage().heapTotal,
        external: process.memoryUsage().external,
        rss: process.memoryUsage().rss
      },
      cpu: {
        usage: process.cpuUsage(),
        loadAverage: require('os').loadavg()
      },
      eventLoop: {
        lag: await this.measureEventLoopLag(),
        utilization: this.getEventLoopUtilization()
      },
      connections: {
        active: await this.getActiveConnections(),
        database: await this.getDatabaseConnections(),
        cache: await this.getCacheConnections()
      },
      queues: {
        sizes: await this.getQueueSizes(),
        processing: await this.getProcessingCounts(),
        backlog: await this.getBacklogCounts()
      }
    });
  }
  
  startHealthMonitoring() {
    // Periodic health checks every 30 seconds
    setInterval(() => {
      this.performHealthCheck().catch(error => {
        this.logger.error('Scheduled health check failed', { error: error.message });
      });
    }, 30000);
    
    // Periodic metrics logging every 5 minutes
    setInterval(() => {
      this.logPeriodicMetrics().catch(error => {
        this.logger.error('Periodic metrics collection failed', { error: error.message });
      });
    }, 300000);
  }
}
```

### 3. **User Activity and Business Event Tracking**
INFO level captures significant user activities and business events.

```javascript
// User activity and business event INFO logging
class UserActivityLogger {
  constructor(logger) {
    this.logger = logger.child({ component: 'UserActivityLogger' });
    this.sessionTracker = new Map();
    this.activityMetrics = {
      activeUsers: 0,
      totalSessions: 0,
      activeSessions: 0
    };
  }
  
  logUserLogin(user, loginInfo) {
    const sessionId = this.generateSessionId();
    const loginEvent = {
      eventType: 'user_login',
      sessionId,
      userId: user.id,
      username: user.username,
      loginMethod: loginInfo.method, // 'password', 'oauth', 'sso', 'biometric'
      deviceInfo: {
        type: loginInfo.device.type,
        os: loginInfo.device.os,
        browser: loginInfo.device.browser,
        mobile: loginInfo.device.mobile
      },
      location: {
        ip: this.maskIP(loginInfo.ip),
        country: loginInfo.geoLocation.country,
        city: loginInfo.geoLocation.city,
        timezone: loginInfo.timezone
      },
      security: {
        mfaUsed: loginInfo.mfaUsed,
        riskScore: loginInfo.riskScore,
        newDevice: loginInfo.newDevice,
        suspiciousActivity: loginInfo.suspiciousActivity
      },
      timestamp: new Date().toISOString(),
      lastLogin: user.lastLogin,
      loginCount: user.loginCount + 1
    };
    
    this.logger.info('User login successful', loginEvent);
    
    // Track session
    this.sessionTracker.set(sessionId, {
      userId: user.id,
      startTime: Date.now(),
      lastActivity: Date.now(),
      activityCount: 1
    });
    
    this.activityMetrics.totalSessions++;
    this.activityMetrics.activeSessions++;
    
    // Log user behavior insights
    this.logUserBehaviorInsights(user, loginInfo);
    
    return sessionId;
  }
  
  logUserActivity(sessionId, activity) {
    const session = this.sessionTracker.get(sessionId);
    if (!session) {
      this.logger.warn('Activity logged for unknown session', { sessionId, activity: activity.type });
      return;
    }
    
    const activityEvent = {
      eventType: 'user_activity',
      sessionId,
      userId: session.userId,
      activityType: activity.type, // 'page_view', 'api_call', 'feature_use', 'transaction'
      activityDetails: {
        action: activity.action,
        resource: activity.resource,
        parameters: this.sanitizeParameters(activity.parameters),
        result: activity.result,
        duration: activity.duration
      },
      context: {
        userAgent: activity.userAgent,
        referrer: activity.referrer,
        sessionDuration: Date.now() - session.startTime,
        sessionActivityCount: session.activityCount + 1
      },
      business: {
        featureUsed: activity.feature,
        businessValue: activity.businessValue,
        conversionEvent: activity.conversionEvent,
        revenueImpact: activity.revenueImpact
      },
      timestamp: new Date().toISOString()
    };
    
    this.logger.info('User activity recorded', activityEvent);
    
    // Update session tracking
    session.lastActivity = Date.now();
    session.activityCount++;
    
    // Track feature usage
    if (activity.feature) {
      this.logFeatureUsage(session.userId, activity.feature, activity);
    }
    
    // Track business events
    if (activity.businessValue > 0) {
      this.logBusinessEvent(session.userId, activity);
    }
  }
  
  logUserLogout(sessionId, logoutInfo) {
    const session = this.sessionTracker.get(sessionId);
    if (!session) {
      this.logger.warn('Logout attempted for unknown session', { sessionId });
      return;
    }
    
    const sessionDuration = Date.now() - session.startTime;
    
    const logoutEvent = {
      eventType: 'user_logout',
      sessionId,
      userId: session.userId,
      logoutType: logoutInfo.type, // 'manual', 'timeout', 'forced', 'security'
      sessionSummary: {
        duration: sessionDuration,
        humanDuration: this.formatDuration(sessionDuration),
        activitiesPerformed: session.activityCount,
        lastActivity: new Date(session.lastActivity).toISOString(),
        avgActivityInterval: sessionDuration / session.activityCount
      },
      performance: {
        avgResponseTime: logoutInfo.avgResponseTime,
        errorCount: logoutInfo.errorCount,
        slowRequestCount: logoutInfo.slowRequestCount
      },
      business: {
        goalsCompleted: logoutInfo.goalsCompleted,
        conversions: logoutInfo.conversions,
        revenue: logoutInfo.revenue,
        satisfaction: logoutInfo.satisfaction
      },
      timestamp: new Date().toISOString()
    };
    
    this.logger.info('User logout completed', logoutEvent);
    
    // Clean up session tracking
    this.sessionTracker.delete(sessionId);
    this.activityMetrics.activeSessions--;
    
    // Log session analytics
    this.logSessionAnalytics(logoutEvent);
  }
  
  logFeatureUsage(userId, featureName, activity) {
    this.logger.info('Feature usage tracked', {
      eventType: 'feature_usage',
      userId,
      featureName,
      usageContext: {
        firstTime: activity.firstTimeUse,
        proficiencyLevel: activity.proficiencyLevel,
        helpUsed: activity.helpUsed,
        timeToComplete: activity.timeToComplete,
        success: activity.success
      },
      featureMetrics: {
        adoptionRate: this.getFeatureAdoptionRate(featureName),
        usageFrequency: this.getFeatureUsageFrequency(featureName),
        userSatisfaction: activity.satisfaction,
        completionRate: this.getFeatureCompletionRate(featureName)
      },
      businessImpact: {
        productivityGain: activity.productivityGain,
        timesSaved: activity.timeSaved,
        errorReduction: activity.errorReduction,
        processImprovement: activity.processImprovement
      },
      timestamp: new Date().toISOString()
    });
  }
  
  logBusinessEvent(userId, event) {
    this.logger.info('Business event recorded', {
      eventType: 'business_event',
      userId,
      businessEventType: event.businessEventType, // 'purchase', 'subscription', 'upgrade', 'referral'
      eventDetails: {
        value: event.businessValue,
        currency: event.currency,
        category: event.category,
        product: event.product,
        quantity: event.quantity
      },
      attribution: {
        channel: event.channel,
        campaign: event.campaign,
        source: event.source,
        medium: event.medium
      },
      impact: {
        revenue: event.revenueImpact,
        profit: event.profitImpact,
        customerValue: event.customerValueImpact,
        retention: event.retentionImpact
      },
      context: {
        customerSegment: event.customerSegment,
        customerTier: event.customerTier,
        customerLifetimeValue: event.customerLifetimeValue,
        acquisitionDate: event.acquisitionDate
      },
      timestamp: new Date().toISOString()
    });
  }
}
```

## When to Use INFO Logging

### 1. **Production Environment**
- Normal application operation
- Business transaction completion
- User activity tracking
- System health monitoring

### 2. **Business Intelligence**
- Key performance indicators
- User behavior analytics
- Revenue and conversion tracking
- Customer journey milestones

### 3. **Operational Monitoring**
- Service availability
- Performance benchmarks
- Resource utilization
- SLA compliance

### 4. **Audit and Compliance**
- Regulatory reporting
- Security events
- Data access tracking
- Configuration changes

## Best Practices for INFO Logging

### 1. **Balance Detail and Noise**
```javascript
// Balanced INFO logging
class BalancedInfoLogger {
  constructor(logger) {
    this.logger = logger;
    this.infoFilters = {
      significance: 0.7, // Only log significant events
      frequency: 1000,   // Max 1000 INFO logs per minute
      businessValue: 10  // Minimum business value threshold
    };
  }
  
  info(message, data = {}) {
    if (this.shouldLog(message, data)) {
      this.logger.info(message, {
        ...data,
        significance: this.calculateSignificance(data),
        businessValue: data.businessValue || 0
      });
    }
  }
  
  shouldLog(message, data) {
    const significance = this.calculateSignificance(data);
    const businessValue = data.businessValue || 0;
    
    return significance >= this.infoFilters.significance ||
           businessValue >= this.infoFilters.businessValue ||
           this.isExceptionalEvent(message, data);
  }
}
```

### 2. **Structured Information**
```javascript
// Structured INFO logging
class StructuredInfoLogger {
  constructor(logger) {
    this.logger = logger;
  }
  
  logBusinessTransaction(transaction) {
    this.logger.info('Business transaction completed', {
      transaction: {
        id: transaction.id,
        type: transaction.type,
        amount: transaction.amount,
        currency: transaction.currency,
        status: transaction.status
      },
      customer: {
        id: transaction.customerId,
        segment: transaction.customerSegment,
        tier: transaction.customerTier
      },
      metrics: {
        processingTime: transaction.processingTime,
        systemsInvolved: transaction.systemsInvolved,
        automationLevel: transaction.automationLevel
      },
      business: {
        revenue: transaction.revenue,
        profit: transaction.profit,
        category: transaction.category
      }
    });
  }
}
```

### 3. **Performance Conscious**
```javascript
// Performance-conscious INFO logging
class PerformanceInfoLogger {
  constructor(logger) {
    this.logger = logger;
    this.logBuffer = [];
    this.bufferSize = 100;
    this.flushInterval = 5000; // 5 seconds
    
    this.startBufferFlushing();
  }
  
  info(message, data = {}) {
    // Buffer INFO logs to reduce I/O overhead
    this.logBuffer.push({
      level: 'info',
      message,
      data,
      timestamp: Date.now()
    });
    
    if (this.logBuffer.length >= this.bufferSize) {
      this.flushBuffer();
    }
  }
  
  flushBuffer() {
    if (this.logBuffer.length === 0) return;
    
    const logs = [...this.logBuffer];
    this.logBuffer = [];
    
    // Batch process logs
    logs.forEach(log => {
      this.logger.info(log.message, {
        ...log.data,
        buffered: true,
        bufferDelay: Date.now() - log.timestamp
      });
    });
  }
}
```

---

**Previous**: [2.1.2 DEBUG: Diagnostic Information](./2.1.2_DEBUG_Diagnostic_Information.md)  
**Next**: [2.1.4 WARN: Warning Conditions](./2.1.4_WARN_Warning_Conditions.md)
