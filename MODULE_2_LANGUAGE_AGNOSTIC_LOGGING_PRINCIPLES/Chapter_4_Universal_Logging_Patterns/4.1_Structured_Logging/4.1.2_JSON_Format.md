# 4.1.2 JSON Format

## Overview

JSON (JavaScript Object Notation) has emerged as the de facto standard for structured logging due to its universal compatibility, excellent tooling support, and optimal balance between human readability and machine parsability. Unlike traditional text-based logs, JSON format provides a standardized structure that enables automated processing, efficient querying, and seamless integration with modern log aggregation systems. JSON logging transforms unstructured text into well-defined objects with typed fields, making it the preferred choice for microservices, cloud-native applications, and enterprise logging infrastructure.

## Understanding JSON Structured Logging

### Core JSON Logging Principles
- **Object Structure**: Every log entry is a self-contained JSON object
- **Field Typing**: Automatic type preservation for strings, numbers, booleans, arrays, and nested objects
- **Schema Flexibility**: Dynamic field addition without breaking existing parsers
- **Unicode Support**: Native UTF-8 encoding for international characters
- **Nested Data**: Hierarchical information through nested objects and arrays

### JSON Format Advantages
- **Universal Compatibility**: Supported by virtually all programming languages and platforms
- **Tool Ecosystem**: Extensive support in log aggregation systems (ELK, Splunk, CloudWatch)
- **Query Efficiency**: Direct field access without complex parsing
- **Schema Evolution**: Backward-compatible field additions and modifications
- **Compression Friendly**: Repetitive field names compress well

### Standard JSON Log Schema
```json
{
  "timestamp": "2024-01-15T10:30:45.123Z",
  "level": "INFO",
  "message": "User authentication successful",
  "logger": "auth-service",
  "application": "user-management-api",
  "version": "1.2.3",
  "environment": "production",
  "host": "app-server-01",
  "pid": 12345,
  "thread": "main",
  "correlation_id": "req_abc123",
  "user_id": 78901,
  "duration_ms": 245,
  "metadata": {
    "ip_address": "192.168.1.100",
    "user_agent": "Mozilla/5.0...",
    "endpoint": "/api/auth/login",
    "method": "POST"
  }
}
```

## Advanced JSON Logging Management System

### Comprehensive JSON Logger

```javascript
const winston = require('winston');
const { DateTime } = require('luxon');
const os = require('os');

/**
 * Advanced JSON Logging Management System
 * Provides comprehensive JSON structured logging with schema validation,
 * type preservation, field transformation, and performance optimization
 */
class JSONLogger {
    constructor(options = {}) {
        this.config = {
            // JSON formatting options
            prettyPrint: options.prettyPrint || false,
            indentSize: options.indentSize || 2,
            enableColorOutput: options.enableColorOutput || false,
            sortKeys: options.sortKeys || false,
            enableMinification: options.enableMinification !== false,
            
            // Schema configuration
            enforceSchema: options.enforceSchema || false,
            schemaValidation: options.schemaValidation || false,
            requiredFields: options.requiredFields || ['timestamp', 'level', 'message'],
            optionalFields: options.optionalFields || [],
            forbiddenFields: options.forbiddenFields || ['password', 'secret', 'token'],
            
            // Field transformation
            enableFieldTransformation: options.enableFieldTransformation !== false,
            fieldAliases: options.fieldAliases || {},
            fieldFilters: options.fieldFilters || [],
            enableFieldFlattening: options.enableFieldFlattening || false,
            flatteningPrefix: options.flatteningPrefix || '',
            
            // Type handling
            preserveTypes: options.preserveTypes !== false,
            stringifyFunctions: options.stringifyFunctions || false,
            stringifyRegex: options.stringifyRegex || false,
            handleCircularReferences: options.handleCircularReferences !== false,
            maxDepth: options.maxDepth || 10,
            
            // Performance options
            enableCaching: options.enableCaching !== false,
            cacheSize: options.cacheSize || 1000,
            cacheTTL: options.cacheTTL || 300000, // 5 minutes
            enableAsyncSerialization: options.enableAsyncSerialization || false,
            batchSize: options.batchSize || 100,
            
            // Application metadata
            applicationName: options.applicationName || 'unknown',
            applicationVersion: options.applicationVersion || '1.0.0',
            environment: options.environment || 'development',
            hostname: os.hostname(),
            pid: process.pid,
            
            // Output options
            enableFileOutput: options.enableFileOutput !== false,
            enableConsoleOutput: options.enableConsoleOutput !== false,
            logDirectory: options.logDirectory || './logs',
            maxFileSize: options.maxFileSize || '20m',
            maxFiles: options.maxFiles || 5
        };
        
        this.schemaValidator = new JSONSchemaValidator(this.config);
        this.fieldTransformer = new FieldTransformer(this.config);
        this.typeSerializer = new TypeSerializer(this.config);
        this.performanceOptimizer = new PerformanceOptimizer(this.config);
        this.outputManager = new OutputManager(this.config);
        
        this.serializationCache = new Map();
        this.metrics = this._initializeMetrics();
        
        // Initialize Winston logger with JSON format
        this.logger = this._createJSONLogger();
    }
    
    /**
     * Log a message in JSON format
     */
    log(level, message, data = {}, options = {}) {
        const startTime = Date.now();
        
        try {
            // Create base log entry
            const baseEntry = this._createBaseEntry(level, message);
            
            // Merge with additional data
            const rawEntry = { ...baseEntry, ...data };
            
            // Validate schema if enabled
            if (this.config.enforceSchema) {
                this.schemaValidator.validate(rawEntry);
            }
            
            // Transform fields
            const transformedEntry = this.fieldTransformer.transform(rawEntry);
            
            // Serialize with type preservation
            const serializedEntry = this.typeSerializer.serialize(transformedEntry);
            
            // Apply performance optimizations
            const optimizedEntry = this.performanceOptimizer.optimize(serializedEntry);
            
            // Format as JSON
            const jsonEntry = this._formatJSON(optimizedEntry, options);
            
            // Output through Winston
            this.logger.log(level, jsonEntry);
            
            // Record metrics
            this._recordMetrics(startTime, level, JSON.stringify(jsonEntry).length);
            
            return jsonEntry;
            
        } catch (error) {
            this._handleJSONError(error, level, message, data);
            
            // Fallback to simple JSON
            const fallbackEntry = {
                timestamp: DateTime.now().toISO(),
                level: level.toUpperCase(),
                message: String(message),
                error: error.message,
                fallback: true
            };
            
            this.logger.log(level, fallbackEntry);
            return fallbackEntry;
        }
    }
    
    /**
     * Convenience methods for different log levels
     */
    info(message, data = {}, options = {}) {
        return this.log('info', message, data, options);
    }
    
    warn(message, data = {}, options = {}) {
        return this.log('warn', message, data, options);
    }
    
    error(message, data = {}, options = {}) {
        return this.log('error', message, data, options);
    }
    
    debug(message, data = {}, options = {}) {
        return this.log('debug', message, data, options);
    }
    
    /**
     * Log structured data directly as JSON
     */
    logJSON(level, jsonData, options = {}) {
        if (typeof jsonData === 'object' && jsonData !== null) {
            const { message, ...metadata } = jsonData;
            return this.log(level, message || 'JSON log entry', metadata, options);
        } else {
            return this.log(level, 'JSON log entry', { data: jsonData }, options);
        }
    }
    
    /**
     * Create child logger with additional context
     */
    child(contextData = {}) {
        const childLogger = Object.create(this);
        childLogger.contextData = { ...this.contextData, ...contextData };
        
        // Override log method to include context
        const originalLog = this.log.bind(this);
        childLogger.log = (level, message, data = {}, options = {}) => {
            const mergedData = { ...childLogger.contextData, ...data };
            return originalLog(level, message, mergedData, options);
        };
        
        return childLogger;
    }
    
    /**
     * Batch logging for high-volume scenarios
     */
    async logBatch(entries, options = {}) {
        const batchStartTime = Date.now();
        const results = [];
        
        try {
            // Process entries in chunks
            const chunkSize = options.chunkSize || this.config.batchSize;
            const chunks = this._chunkArray(entries, chunkSize);
            
            for (const chunk of chunks) {
                const chunkPromises = chunk.map(entry => {
                    return this.log(entry.level, entry.message, entry.data, entry.options);
                });
                
                const chunkResults = await Promise.all(chunkPromises);
                results.push(...chunkResults);
            }
            
            // Record batch metrics
            this.metrics.batchesProcessed++;
            this.metrics.batchProcessingTime += Date.now() - batchStartTime;
            
            return results;
            
        } catch (error) {
            this.metrics.batchErrors++;
            throw new Error(`Batch logging failed: ${error.message}`);
        }
    }
    
    /**
     * Create base log entry with standard fields
     */
    _createBaseEntry(level, message) {
        return {
            timestamp: DateTime.now().toISO(),
            level: level.toUpperCase(),
            message: String(message),
            logger: this.config.applicationName,
            application: this.config.applicationName,
            version: this.config.applicationVersion,
            environment: this.config.environment,
            hostname: this.config.hostname,
            pid: this.config.pid,
            thread: 'main' // Node.js is single-threaded
        };
    }
    
    /**
     * Format entry as JSON string
     */
    _formatJSON(entry, options = {}) {
        const formatOptions = { ...this.config, ...options };
        
        try {
            // Sort keys if requested
            const processedEntry = formatOptions.sortKeys ? 
                this._sortObjectKeys(entry) : entry;
            
            // Format JSON with appropriate spacing
            if (formatOptions.prettyPrint) {
                return JSON.stringify(processedEntry, null, formatOptions.indentSize);
            } else {
                return JSON.stringify(processedEntry);
            }
            
        } catch (error) {
            // Handle circular references and other JSON errors
            return this._handleJSONStringifyError(entry, error);
        }
    }
    
    /**
     * Handle JSON stringification errors
     */
    _handleJSONStringifyError(entry, error) {
        try {
            // Remove circular references and retry
            const cleanEntry = this._removeCircularReferences(entry);
            return JSON.stringify(cleanEntry);
        } catch (secondError) {
            // Final fallback
            return JSON.stringify({
                timestamp: DateTime.now().toISO(),
                level: 'ERROR',
                message: 'JSON serialization failed',
                originalError: error.message,
                serializationError: secondError.message,
                fallback: true
            });
        }
    }
    
    /**
     * Remove circular references from object
     */
    _removeCircularReferences(obj, seen = new WeakSet()) {
        if (obj === null || typeof obj !== 'object') {
            return obj;
        }
        
        if (seen.has(obj)) {
            return '[Circular Reference]';
        }
        
        seen.add(obj);
        
        if (Array.isArray(obj)) {
            return obj.map(item => this._removeCircularReferences(item, seen));
        }
        
        const result = {};
        for (const [key, value] of Object.entries(obj)) {
            result[key] = this._removeCircularReferences(value, seen);
        }
        
        return result;
    }
    
    /**
     * Sort object keys recursively
     */
    _sortObjectKeys(obj) {
        if (obj === null || typeof obj !== 'object' || Array.isArray(obj)) {
            return obj;
        }
        
        const sorted = {};
        const keys = Object.keys(obj).sort();
        
        for (const key of keys) {
            sorted[key] = this._sortObjectKeys(obj[key]);
        }
        
        return sorted;
    }
    
    /**
     * Split array into chunks
     */
    _chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }
    
    /**
     * Create Winston logger with JSON formatting
     */
    _createJSONLogger() {
        const transports = [];
        
        // Console transport
        if (this.config.enableConsoleOutput) {
            transports.push(new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize({ all: this.config.enableColorOutput }),
                    winston.format.timestamp(),
                    winston.format.json({ space: this.config.prettyPrint ? this.config.indentSize : 0 })
                )
            }));
        }
        
        // File transport
        if (this.config.enableFileOutput) {
            transports.push(new winston.transports.File({
                filename: `${this.config.logDirectory}/application.json`,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                ),
                maxsize: this.config.maxFileSize,
                maxFiles: this.config.maxFiles
            }));
        }
        
        return winston.createLogger({
            level: 'debug',
            format: winston.format.json(),
            transports: transports
        });
    }
    
    /**
     * Record performance metrics
     */
    _recordMetrics(startTime, level, outputSize) {
        this.metrics.totalLogs++;
        this.metrics.serializationTime += Date.now() - startTime;
        this.metrics.totalOutputSize += outputSize;
        this.metrics.levelCounts[level] = (this.metrics.levelCounts[level] || 0) + 1;
        
        const avgSerializationTime = this.metrics.serializationTime / this.metrics.totalLogs;
        if (avgSerializationTime > 10) { // 10ms threshold
            this.metrics.slowSerializations++;
        }
    }
    
    /**
     * Handle JSON logging errors
     */
    _handleJSONError(error, level, message, data) {
        this.metrics.serializationErrors++;
        
        console.error('JSON logging error:', {
            error: error.message,
            level,
            message,
            dataKeys: Object.keys(data),
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Initialize metrics tracking
     */
    _initializeMetrics() {
        return {
            totalLogs: 0,
            serializationTime: 0,
            slowSerializations: 0,
            serializationErrors: 0,
            batchesProcessed: 0,
            batchProcessingTime: 0,
            batchErrors: 0,
            totalOutputSize: 0,
            levelCounts: {},
            startTime: Date.now()
        };
    }
    
    /**
     * Get JSON logging statistics
     */
    getStatistics() {
        const avgSerializationTime = this.metrics.totalLogs > 0 ?
            this.metrics.serializationTime / this.metrics.totalLogs : 0;
        
        const avgOutputSize = this.metrics.totalLogs > 0 ?
            this.metrics.totalOutputSize / this.metrics.totalLogs : 0;
        
        const avgBatchTime = this.metrics.batchesProcessed > 0 ?
            this.metrics.batchProcessingTime / this.metrics.batchesProcessed : 0;
        
        return {
            totalLogs: this.metrics.totalLogs,
            averageSerializationTime: `${avgSerializationTime.toFixed(2)}ms`,
            averageOutputSize: `${avgOutputSize.toFixed(0)} bytes`,
            slowSerializations: this.metrics.slowSerializations,
            serializationErrors: this.metrics.serializationErrors,
            batchesProcessed: this.metrics.batchesProcessed,
            averageBatchTime: `${avgBatchTime.toFixed(2)}ms`,
            batchErrors: this.metrics.batchErrors,
            levelDistribution: this.metrics.levelCounts,
            uptime: `${Math.round((Date.now() - this.metrics.startTime) / 1000)}s`
        };
    }
}

/**
 * JSON Schema Validator for ensuring log entry compliance
 */
class JSONSchemaValidator {
    constructor(config) {
        this.config = config;
        this.schema = this._buildSchema();
    }
    
    validate(entry) {
        // Check required fields
        for (const field of this.config.requiredFields) {
            if (!entry.hasOwnProperty(field)) {
                throw new Error(`Required field '${field}' missing from log entry`);
            }
        }
        
        // Check forbidden fields
        for (const field of this.config.forbiddenFields) {
            if (entry.hasOwnProperty(field)) {
                throw new Error(`Forbidden field '${field}' found in log entry`);
            }
        }
        
        // Additional schema validation can be added here
        return true;
    }
    
    _buildSchema() {
        // Basic schema definition
        return {
            type: 'object',
            required: this.config.requiredFields,
            properties: {
                timestamp: { type: 'string', format: 'date-time' },
                level: { type: 'string', enum: ['DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'] },
                message: { type: 'string' },
                logger: { type: 'string' },
                application: { type: 'string' },
                version: { type: 'string' },
                environment: { type: 'string' },
                hostname: { type: 'string' },
                pid: { type: 'number' }
            }
        };
    }
}

/**
 * Field Transformer for modifying log entry fields
 */
class FieldTransformer {
    constructor(config) {
        this.config = config;
    }
    
    transform(entry) {
        let transformedEntry = { ...entry };
        
        // Apply field aliases
        transformedEntry = this._applyAliases(transformedEntry);
        
        // Apply field filters
        transformedEntry = this._applyFilters(transformedEntry);
        
        // Apply flattening if enabled
        if (this.config.enableFieldFlattening) {
            transformedEntry = this._flattenFields(transformedEntry);
        }
        
        return transformedEntry;
    }
    
    _applyAliases(entry) {
        const aliased = { ...entry };
        
        for (const [originalField, aliasField] of Object.entries(this.config.fieldAliases)) {
            if (aliased.hasOwnProperty(originalField)) {
                aliased[aliasField] = aliased[originalField];
                delete aliased[originalField];
            }
        }
        
        return aliased;
    }
    
    _applyFilters(entry) {
        const filtered = { ...entry };
        
        for (const filterField of this.config.fieldFilters) {
            delete filtered[filterField];
        }
        
        return filtered;
    }
    
    _flattenFields(entry, prefix = '') {
        const flattened = {};
        
        for (const [key, value] of Object.entries(entry)) {
            const newKey = prefix ? `${prefix}.${key}` : key;
            
            if (typeof value === 'object' && value !== null && !Array.isArray(value) && !(value instanceof Date)) {
                Object.assign(flattened, this._flattenFields(value, newKey));
            } else {
                flattened[newKey] = value;
            }
        }
        
        return flattened;
    }
}

/**
 * Type Serializer for handling different data types in JSON
 */
class TypeSerializer {
    constructor(config) {
        this.config = config;
    }
    
    serialize(entry) {
        const serialized = {};
        
        for (const [key, value] of Object.entries(entry)) {
            serialized[key] = this._serializeValue(value);
        }
        
        return serialized;
    }
    
    _serializeValue(value) {
        // Handle null and undefined
        if (value === null || value === undefined) {
            return value;
        }
        
        // Handle functions
        if (typeof value === 'function') {
            return this.config.stringifyFunctions ? value.toString() : '[Function]';
        }
        
        // Handle regex
        if (value instanceof RegExp) {
            return this.config.stringifyRegex ? value.toString() : value.source;
        }
        
        // Handle dates
        if (value instanceof Date) {
            return value.toISOString();
        }
        
        // Handle errors
        if (value instanceof Error) {
            return {
                name: value.name,
                message: value.message,
                stack: value.stack
            };
        }
        
        // Handle arrays
        if (Array.isArray(value)) {
            return value.map(item => this._serializeValue(item));
        }
        
        // Handle objects
        if (typeof value === 'object') {
            const serialized = {};
            for (const [k, v] of Object.entries(value)) {
                serialized[k] = this._serializeValue(v);
            }
            return serialized;
        }
        
        // Primitive types
        return value;
    }
}

/**
 * Performance Optimizer for JSON logging
 */
class PerformanceOptimizer {
    constructor(config) {
        this.config = config;
        this.cache = new Map();
    }
    
    optimize(entry) {
        // Apply caching if enabled
        if (this.config.enableCaching) {
            const cacheKey = this._generateCacheKey(entry);
            const cached = this.cache.get(cacheKey);
            
            if (cached && Date.now() - cached.timestamp < this.config.cacheTTL) {
                return cached.entry;
            }
            
            // Cache the entry
            this.cache.set(cacheKey, {
                entry,
                timestamp: Date.now()
            });
            
            // Cleanup old cache entries
            if (this.cache.size > this.config.cacheSize) {
                this._cleanupCache();
            }
        }
        
        return entry;
    }
    
    _generateCacheKey(entry) {
        // Generate a simple cache key based on entry structure
        const keys = Object.keys(entry).sort().join(',');
        return `${keys}_${JSON.stringify(entry).length}`;
    }
    
    _cleanupCache() {
        const entries = Array.from(this.cache.entries());
        entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
        
        // Remove oldest 25% of entries
        const removeCount = Math.floor(entries.length * 0.25);
        for (let i = 0; i < removeCount; i++) {
            this.cache.delete(entries[i][0]);
        }
    }
}

/**
 * Output Manager for handling different output destinations
 */
class OutputManager {
    constructor(config) {
        this.config = config;
    }
    
    // Additional output management methods can be added here
    // For now, output is handled by Winston transports
}

module.exports = {
    JSONLogger,
    JSONSchemaValidator,
    FieldTransformer,
    TypeSerializer,
    PerformanceOptimizer,
    OutputManager
};
```

### Usage Examples

#### Basic JSON Logging
```javascript
const { JSONLogger } = require('./JSONLogger');

const logger = new JSONLogger({
    applicationName: 'user-service',
    applicationVersion: '2.1.0',
    environment: 'production',
    prettyPrint: false,
    enforceSchema: true
});

// Simple JSON logging
logger.info('User created successfully', {
    user_id: 12345,
    username: 'john_doe',
    email: 'john@example.com',
    created_at: new Date(),
    is_verified: false,
    metadata: {
        source: 'web',
        registration_type: 'email',
        referrer: 'google'
    }
});

// Output:
// {"timestamp":"2024-01-15T10:30:45.123Z","level":"INFO","message":"User created successfully","logger":"user-service","application":"user-service","version":"2.1.0","environment":"production","hostname":"app-server-01","pid":12345,"thread":"main","user_id":12345,"username":"john_doe","email":"john@example.com","created_at":"2024-01-15T10:30:45.123Z","is_verified":false,"metadata":{"source":"web","registration_type":"email","referrer":"google"}}
```

#### Pretty-Print JSON for Development
```javascript
const devLogger = new JSONLogger({
    prettyPrint: true,
    indentSize: 2,
    sortKeys: true,
    environment: 'development'
});

devLogger.warn('Database connection slow', {
    database: 'users',
    connection_time_ms: 1500,
    threshold_ms: 1000,
    pool_stats: {
        active: 8,
        idle: 2,
        total: 10
    }
});

// Pretty-printed output:
// {
//   "application": "user-service",
//   "connection_time_ms": 1500,
//   "database": "users",
//   "environment": "development",
//   "hostname": "dev-machine",
//   "level": "WARN",
//   "logger": "user-service",
//   "message": "Database connection slow",
//   "pid": 12345,
//   "pool_stats": {
//     "active": 8,
//     "idle": 2,
//     "total": 10
//   },
//   "threshold_ms": 1000,
//   "thread": "main",
//   "timestamp": "2024-01-15T10:30:45.123Z",
//   "version": "2.1.0"
// }
```

#### Batch JSON Logging
```javascript
// High-volume batch logging
const batchEntries = [
    { level: 'info', message: 'Order processed', data: { order_id: 'ord_001', amount: 99.99 } },
    { level: 'info', message: 'Order processed', data: { order_id: 'ord_002', amount: 149.99 } },
    { level: 'info', message: 'Order processed', data: { order_id: 'ord_003', amount: 75.50 } }
];

logger.logBatch(batchEntries, { chunkSize: 10 })
    .then(results => {
        console.log(`Processed ${results.length} log entries`);
    })
    .catch(error => {
        console.error('Batch logging failed:', error);
    });
```

#### Child Logger with Context
```javascript
// Create child logger with request context
const requestLogger = logger.child({
    request_id: 'req_abc123',
    user_id: 456,
    session_id: 'sess_xyz789'
});

// All logs include context automatically
requestLogger.info('API endpoint accessed', {
    endpoint: '/api/users/456',
    method: 'GET',
    response_time_ms: 45
});

// Output includes both context and specific data:
// {"timestamp":"...","level":"INFO","message":"API endpoint accessed","request_id":"req_abc123","user_id":456,"session_id":"sess_xyz789","endpoint":"/api/users/456","method":"GET","response_time_ms":45,...}
```

## JSON Format Best Practices

### ‚úÖ **DO: JSON Format Best Practices**
- **Use consistent field names**: Maintain standard naming conventions across all logs
- **Preserve data types**: Keep numbers as numbers, booleans as booleans
- **Include timestamp in ISO 8601 format**: Ensure proper timezone handling
- **Structure nested data logically**: Group related fields in nested objects
- **Validate JSON structure**: Ensure proper formatting and avoid malformed JSON

### ‚ùå **DON'T: JSON Format Anti-patterns**
- **Create deeply nested objects**: Limit nesting depth for better queryability
- **Use inconsistent field types**: Don't mix strings and numbers for the same field
- **Include circular references**: Prevent JSON.stringify errors
- **Log overly large objects**: Consider truncating or summarizing large data
- **Ignore JSON escaping**: Properly handle special characters in string values

### üéØ **JSON Schema Example**
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["timestamp", "level", "message"],
  "properties": {
    "timestamp": {
      "type": "string",
      "format": "date-time"
    },
    "level": {
      "type": "string",
      "enum": ["DEBUG", "INFO", "WARN", "ERROR", "FATAL"]
    },
    "message": {
      "type": "string",
      "minLength": 1
    },
    "logger": {
      "type": "string"
    },
    "correlation_id": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9_-]+$"
    },
    "user_id": {
      "type": "integer",
      "minimum": 1
    },
    "metadata": {
      "type": "object",
      "additionalProperties": true
    }
  },
  "additionalProperties": true
}
```

JSON format provides the optimal balance of structure, flexibility, and tooling support for modern logging requirements! üìã
