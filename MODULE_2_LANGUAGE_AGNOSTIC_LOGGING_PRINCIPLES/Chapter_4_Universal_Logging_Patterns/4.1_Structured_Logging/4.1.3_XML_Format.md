# 4.1.3 XML Format

## Overview

XML (eXtensible Markup Language) format provides a robust, schema-validated approach to structured logging that excels in enterprise environments requiring strict data validation, complex hierarchical structures, and comprehensive metadata management. While JSON has gained popularity for its simplicity, XML format offers superior capabilities for complex logging scenarios, legacy system integration, formal schema validation, and environments where data integrity and structure validation are paramount. XML logging is particularly valuable in regulated industries, enterprise integration scenarios, and systems requiring detailed audit trails with formal schema compliance.

## Understanding XML Structured Logging

### Core XML Logging Principles
- **Hierarchical Structure**: Natural representation of nested data through element hierarchy
- **Schema Validation**: Formal XSD (XML Schema Definition) validation for data integrity
- **Namespace Support**: Preventing naming conflicts in complex logging environments
- **Attribute vs Element Flexibility**: Choice between attributes and elements for metadata
- **CDATA Support**: Safe handling of complex text content and special characters

### XML Format Advantages
- **Schema Validation**: Strong typing and structure validation through XSD
- **Hierarchical Data**: Natural support for complex nested structures
- **Metadata Rich**: Extensive support for attributes and namespaces
- **Industry Standards**: Well-established standards and tooling ecosystem
- **Legacy Integration**: Excellent compatibility with enterprise systems and SOAP services

### Standard XML Log Schema
```xml
<?xml version="1.0" encoding="UTF-8"?>
<log-entry xmlns="http://logging.schema/v1" 
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://logging.schema/v1 log-schema.xsd"
           timestamp="2024-01-15T10:30:45.123Z"
           level="INFO"
           logger="auth-service">
    
    <application name="user-management-api" version="1.2.3" environment="production"/>
    <host name="app-server-01" pid="12345" thread="main"/>
    
    <message>User authentication successful</message>
    
    <correlation>
        <request-id>req_abc123</request-id>
        <session-id>sess_xyz789</session-id>
        <user-id>78901</user-id>
    </correlation>
    
    <performance>
        <duration unit="ms">245</duration>
        <memory-usage unit="mb">128.5</memory-usage>
    </performance>
    
    <context>
        <network>
            <ip-address>192.168.1.100</ip-address>
            <user-agent><![CDATA[Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36]]></user-agent>
        </network>
        <request>
            <endpoint>/api/auth/login</endpoint>
            <method>POST</method>
            <headers>
                <header name="Content-Type" value="application/json"/>
                <header name="Authorization" value="[REDACTED]"/>
            </headers>
        </request>
    </context>
    
    <metadata>
        <custom-field name="business-unit" value="retail"/>
        <custom-field name="feature-flag" value="enhanced-auth"/>
        <tags>
            <tag>authentication</tag>
            <tag>security</tag>
            <tag>user-management</tag>
        </tags>
    </metadata>
    
</log-entry>
```

## Advanced XML Logging Management System

### Comprehensive XML Logger

```javascript
const winston = require('winston');
const { DateTime } = require('luxon');
const { DOMParser, XMLSerializer } = require('xmldom');
const os = require('os');

/**
 * Advanced XML Logging Management System
 * Provides comprehensive XML structured logging with schema validation,
 * namespace management, hierarchical structure, and enterprise features
 */
class XMLLogger {
    constructor(options = {}) {
        this.config = {
            // XML formatting options
            prettyPrint: options.prettyPrint !== false,
            indentSize: options.indentSize || 2,
            enableNamespaces: options.enableNamespaces !== false,
            rootNamespace: options.rootNamespace || 'http://logging.schema/v1',
            namespacePrefix: options.namespacePrefix || 'log',
            encoding: options.encoding || 'UTF-8',
            
            // Schema configuration
            enableSchemaValidation: options.enableSchemaValidation || false,
            schemaLocation: options.schemaLocation || null,
            enableSchemaGeneration: options.enableSchemaGeneration || false,
            strictValidation: options.strictValidation || false,
            
            // Element structure options
            useAttributes: options.useAttributes !== false,
            attributeFields: options.attributeFields || ['timestamp', 'level', 'logger'],
            elementFields: options.elementFields || ['message', 'context', 'metadata'],
            enableCDATA: options.enableCDATA !== false,
            cdataFields: options.cdataFields || ['message', 'user-agent', 'stack-trace'],
            
            // Hierarchical structure
            enableHierarchicalNesting: options.enableHierarchicalNesting !== false,
            maxNestingDepth: options.maxNestingDepth || 10,
            enableFieldGrouping: options.enableFieldGrouping !== false,
            fieldGroups: options.fieldGroups || {
                'correlation': ['request-id', 'session-id', 'user-id', 'trace-id'],
                'performance': ['duration', 'memory-usage', 'cpu-usage'],
                'network': ['ip-address', 'user-agent', 'referer'],
                'request': ['endpoint', 'method', 'headers', 'parameters']
            },
            
            // Data transformation
            enableTypeAnnotation: options.enableTypeAnnotation || false,
            enableFieldValidation: options.enableFieldValidation !== false,
            fieldValidators: options.fieldValidators || {},
            enableDataSanitization: options.enableDataSanitization !== false,
            
            // Performance options
            enableCaching: options.enableCaching !== false,
            cacheSize: options.cacheSize || 500,
            cacheTTL: options.cacheTTL || 300000, // 5 minutes
            enableAsyncProcessing: options.enableAsyncProcessing || false,
            batchSize: options.batchSize || 50,
            
            // Application metadata
            applicationName: options.applicationName || 'unknown',
            applicationVersion: options.applicationVersion || '1.0.0',
            environment: options.environment || 'development',
            hostname: os.hostname(),
            pid: process.pid,
            
            // Output options
            enableFileOutput: options.enableFileOutput !== false,
            enableConsoleOutput: options.enableConsoleOutput !== false,
            logDirectory: options.logDirectory || './logs',
            maxFileSize: options.maxFileSize || '20m',
            maxFiles: options.maxFiles || 5
        };
        
        this.schemaValidator = new XMLSchemaValidator(this.config);
        this.structureBuilder = new XMLStructureBuilder(this.config);
        this.namespaceManager = new NamespaceManager(this.config);
        this.dataTransformer = new XMLDataTransformer(this.config);
        this.performanceOptimizer = new XMLPerformanceOptimizer(this.config);
        
        this.xmlCache = new Map();
        this.metrics = this._initializeMetrics();
        
        // Initialize Winston logger with XML format
        this.logger = this._createXMLLogger();
    }
    
    /**
     * Log a message in XML format
     */
    log(level, message, data = {}, options = {}) {
        const startTime = Date.now();
        
        try {
            // Create base log entry
            const baseEntry = this._createBaseEntry(level, message);
            
            // Merge with additional data
            const rawEntry = { ...baseEntry, ...data };
            
            // Transform and validate data
            const transformedEntry = this.dataTransformer.transform(rawEntry);
            
            // Build XML structure
            const xmlStructure = this.structureBuilder.build(transformedEntry);
            
            // Apply namespace management
            const namespacedXML = this.namespaceManager.apply(xmlStructure);
            
            // Validate schema if enabled
            if (this.config.enableSchemaValidation) {
                this.schemaValidator.validate(namespacedXML);
            }
            
            // Format as XML string
            const xmlString = this._formatXML(namespacedXML, options);
            
            // Output through Winston
            this.logger.log(level, xmlString);
            
            // Record metrics
            this._recordMetrics(startTime, level, xmlString.length);
            
            return xmlString;
            
        } catch (error) {
            this._handleXMLError(error, level, message, data);
            
            // Fallback to simple XML
            const fallbackXML = this._createFallbackXML(level, message, error);
            this.logger.log(level, fallbackXML);
            return fallbackXML;
        }
    }
    
    /**
     * Convenience methods for different log levels
     */
    info(message, data = {}, options = {}) {
        return this.log('info', message, data, options);
    }
    
    warn(message, data = {}, options = {}) {
        return this.log('warn', message, data, options);
    }
    
    error(message, data = {}, options = {}) {
        return this.log('error', message, data, options);
    }
    
    debug(message, data = {}, options = {}) {
        return this.log('debug', message, data, options);
    }
    
    /**
     * Log structured data directly as XML
     */
    logXML(level, xmlData, options = {}) {
        if (typeof xmlData === 'object' && xmlData !== null) {
            const { message, ...metadata } = xmlData;
            return this.log(level, message || 'XML log entry', metadata, options);
        } else {
            return this.log(level, 'XML log entry', { data: xmlData }, options);
        }
    }
    
    /**
     * Create child logger with additional context
     */
    child(contextData = {}) {
        const childLogger = Object.create(this);
        childLogger.contextData = { ...this.contextData, ...contextData };
        
        // Override log method to include context
        const originalLog = this.log.bind(this);
        childLogger.log = (level, message, data = {}, options = {}) => {
            const mergedData = { ...childLogger.contextData, ...data };
            return originalLog(level, message, mergedData, options);
        };
        
        return childLogger;
    }
    
    /**
     * Batch XML logging
     */
    async logBatch(entries, options = {}) {
        const batchStartTime = Date.now();
        const results = [];
        
        try {
            // Create batch XML container
            const batchXML = this._createBatchContainer();
            
            // Process entries in chunks
            const chunkSize = options.chunkSize || this.config.batchSize;
            const chunks = this._chunkArray(entries, chunkSize);
            
            for (const chunk of chunks) {
                const chunkPromises = chunk.map(entry => {
                    return this._createLogEntryXML(entry.level, entry.message, entry.data);
                });
                
                const chunkResults = await Promise.all(chunkPromises);
                results.push(...chunkResults);
                
                // Add to batch container
                chunkResults.forEach(xmlEntry => {
                    batchXML.appendChild(xmlEntry);
                });
            }
            
            // Output batch
            const batchXMLString = this._formatXML(batchXML);
            this.logger.info(batchXMLString);
            
            // Record batch metrics
            this.metrics.batchesProcessed++;
            this.metrics.batchProcessingTime += Date.now() - batchStartTime;
            
            return batchXMLString;
            
        } catch (error) {
            this.metrics.batchErrors++;
            throw new Error(`XML batch logging failed: ${error.message}`);
        }
    }
    
    /**
     * Generate XML Schema Definition (XSD)
     */
    generateSchema() {
        if (!this.config.enableSchemaGeneration) {
            throw new Error('Schema generation is disabled');
        }
        
        return this.schemaValidator.generateXSD();
    }
    
    /**
     * Create base log entry with standard fields
     */
    _createBaseEntry(level, message) {
        return {
            timestamp: DateTime.now().toISO(),
            level: level.toUpperCase(),
            logger: this.config.applicationName,
            message: String(message),
            application: {
                name: this.config.applicationName,
                version: this.config.applicationVersion,
                environment: this.config.environment
            },
            host: {
                name: this.config.hostname,
                pid: this.config.pid,
                thread: 'main'
            }
        };
    }
    
    /**
     * Format XML with proper indentation and structure
     */
    _formatXML(xmlNode, options = {}) {
        const formatOptions = { ...this.config, ...options };
        
        try {
            const serializer = new XMLSerializer();
            let xmlString = serializer.serializeToString(xmlNode);
            
            if (formatOptions.prettyPrint) {
                xmlString = this._prettyPrintXML(xmlString, formatOptions.indentSize);
            }
            
            return xmlString;
            
        } catch (error) {
            throw new Error(`XML formatting failed: ${error.message}`);
        }
    }
    
    /**
     * Pretty print XML with proper indentation
     */
    _prettyPrintXML(xmlString, indentSize) {
        const indent = ' '.repeat(indentSize);
        let formatted = '';
        let level = 0;
        
        const lines = xmlString.replace(/>\s*</g, '>\n<').split('\n');
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed === '') continue;
            
            if (trimmed.startsWith('</')) {
                level--;
            }
            
            formatted += indent.repeat(level) + trimmed + '\n';
            
            if (trimmed.startsWith('<') && !trimmed.startsWith('</') && !trimmed.endsWith('/>')) {
                level++;
            }
        }
        
        return formatted.trim();
    }
    
    /**
     * Create XML log entry element
     */
    _createLogEntryXML(level, message, data) {
        const baseEntry = this._createBaseEntry(level, message);
        const mergedEntry = { ...baseEntry, ...data };
        
        return this.structureBuilder.build(mergedEntry);
    }
    
    /**
     * Create batch container XML element
     */
    _createBatchContainer() {
        const parser = new DOMParser();
        const doc = parser.parseFromString('<log-batch></log-batch>', 'text/xml');
        const batchElement = doc.documentElement;
        
        // Add batch metadata
        batchElement.setAttribute('timestamp', DateTime.now().toISO());
        batchElement.setAttribute('batch-id', this._generateBatchId());
        
        return batchElement;
    }
    
    /**
     * Create fallback XML for error cases
     */
    _createFallbackXML(level, message, error) {
        const timestamp = DateTime.now().toISO();
        
        return `<?xml version="1.0" encoding="${this.config.encoding}"?>
<log-entry timestamp="${timestamp}" level="${level.toUpperCase()}" logger="${this.config.applicationName}">
    <message><![CDATA[${String(message)}]]></message>
    <error>
        <message><![CDATA[${error.message}]]></message>
        <type>XML_PROCESSING_ERROR</type>
        <fallback>true</fallback>
    </error>
</log-entry>`;
    }
    
    /**
     * Generate batch ID
     */
    _generateBatchId() {
        return `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Split array into chunks
     */
    _chunkArray(array, chunkSize) {
        const chunks = [];
        for (let i = 0; i < array.length; i += chunkSize) {
            chunks.push(array.slice(i, i + chunkSize));
        }
        return chunks;
    }
    
    /**
     * Create Winston logger with XML formatting
     */
    _createXMLLogger() {
        const transports = [];
        
        // Console transport
        if (this.config.enableConsoleOutput) {
            transports.push(new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.printf(({ timestamp, level, message }) => {
                        return message; // XML is already formatted
                    })
                )
            }));
        }
        
        // File transport
        if (this.config.enableFileOutput) {
            transports.push(new winston.transports.File({
                filename: `${this.config.logDirectory}/application.xml`,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.printf(({ timestamp, level, message }) => {
                        return message; // XML is already formatted
                    })
                ),
                maxsize: this.config.maxFileSize,
                maxFiles: this.config.maxFiles
            }));
        }
        
        return winston.createLogger({
            level: 'debug',
            transports: transports
        });
    }
    
    /**
     * Record performance metrics
     */
    _recordMetrics(startTime, level, outputSize) {
        this.metrics.totalLogs++;
        this.metrics.processingTime += Date.now() - startTime;
        this.metrics.totalOutputSize += outputSize;
        this.metrics.levelCounts[level] = (this.metrics.levelCounts[level] || 0) + 1;
        
        const avgProcessingTime = this.metrics.processingTime / this.metrics.totalLogs;
        if (avgProcessingTime > 15) { // 15ms threshold for XML
            this.metrics.slowProcessing++;
        }
    }
    
    /**
     * Handle XML logging errors
     */
    _handleXMLError(error, level, message, data) {
        this.metrics.processingErrors++;
        
        console.error('XML logging error:', {
            error: error.message,
            level,
            message,
            dataKeys: Object.keys(data),
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Initialize metrics tracking
     */
    _initializeMetrics() {
        return {
            totalLogs: 0,
            processingTime: 0,
            slowProcessing: 0,
            processingErrors: 0,
            batchesProcessed: 0,
            batchProcessingTime: 0,
            batchErrors: 0,
            totalOutputSize: 0,
            levelCounts: {},
            startTime: Date.now()
        };
    }
    
    /**
     * Get XML logging statistics
     */
    getStatistics() {
        const avgProcessingTime = this.metrics.totalLogs > 0 ?
            this.metrics.processingTime / this.metrics.totalLogs : 0;
        
        const avgOutputSize = this.metrics.totalLogs > 0 ?
            this.metrics.totalOutputSize / this.metrics.totalLogs : 0;
        
        const avgBatchTime = this.metrics.batchesProcessed > 0 ?
            this.metrics.batchProcessingTime / this.metrics.batchesProcessed : 0;
        
        return {
            totalLogs: this.metrics.totalLogs,
            averageProcessingTime: `${avgProcessingTime.toFixed(2)}ms`,
            averageOutputSize: `${avgOutputSize.toFixed(0)} bytes`,
            slowProcessing: this.metrics.slowProcessing,
            processingErrors: this.metrics.processingErrors,
            batchesProcessed: this.metrics.batchesProcessed,
            averageBatchTime: `${avgBatchTime.toFixed(2)}ms`,
            batchErrors: this.metrics.batchErrors,
            levelDistribution: this.metrics.levelCounts,
            uptime: `${Math.round((Date.now() - this.metrics.startTime) / 1000)}s`
        };
    }
}

/**
 * XML Schema Validator for XSD validation and generation
 */
class XMLSchemaValidator {
    constructor(config) {
        this.config = config;
    }
    
    validate(xmlNode) {
        if (!this.config.enableSchemaValidation) {
            return true;
        }
        
        // Basic validation logic would go here
        // In a real implementation, you'd use a proper XSD validator
        return true;
    }
    
    generateXSD() {
        return `<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="${this.config.rootNamespace}"
           xmlns:log="${this.config.rootNamespace}"
           elementFormDefault="qualified">

    <xs:element name="log-entry" type="log:LogEntryType"/>
    
    <xs:complexType name="LogEntryType">
        <xs:sequence>
            <xs:element name="application" type="log:ApplicationType"/>
            <xs:element name="host" type="log:HostType"/>
            <xs:element name="message" type="xs:string"/>
            <xs:element name="correlation" type="log:CorrelationType" minOccurs="0"/>
            <xs:element name="performance" type="log:PerformanceType" minOccurs="0"/>
            <xs:element name="context" type="log:ContextType" minOccurs="0"/>
            <xs:element name="metadata" type="log:MetadataType" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="timestamp" type="xs:dateTime" use="required"/>
        <xs:attribute name="level" type="log:LogLevelType" use="required"/>
        <xs:attribute name="logger" type="xs:string" use="required"/>
    </xs:complexType>
    
    <xs:simpleType name="LogLevelType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="DEBUG"/>
            <xs:enumeration value="INFO"/>
            <xs:enumeration value="WARN"/>
            <xs:enumeration value="ERROR"/>
            <xs:enumeration value="FATAL"/>
        </xs:restriction>
    </xs:simpleType>
    
    <xs:complexType name="ApplicationType">
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attribute name="version" type="xs:string" use="required"/>
        <xs:attribute name="environment" type="xs:string" use="required"/>
    </xs:complexType>
    
    <xs:complexType name="HostType">
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attribute name="pid" type="xs:int" use="required"/>
        <xs:attribute name="thread" type="xs:string" use="required"/>
    </xs:complexType>
    
    <xs:complexType name="CorrelationType">
        <xs:sequence>
            <xs:element name="request-id" type="xs:string" minOccurs="0"/>
            <xs:element name="session-id" type="xs:string" minOccurs="0"/>
            <xs:element name="user-id" type="xs:string" minOccurs="0"/>
            <xs:element name="trace-id" type="xs:string" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="PerformanceType">
        <xs:sequence>
            <xs:element name="duration" type="log:MeasurementType" minOccurs="0"/>
            <xs:element name="memory-usage" type="log:MeasurementType" minOccurs="0"/>
            <xs:element name="cpu-usage" type="log:MeasurementType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="MeasurementType">
        <xs:simpleContent>
            <xs:extension base="xs:decimal">
                <xs:attribute name="unit" type="xs:string" use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    
    <xs:complexType name="ContextType">
        <xs:sequence>
            <xs:element name="network" type="log:NetworkType" minOccurs="0"/>
            <xs:element name="request" type="log:RequestType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="NetworkType">
        <xs:sequence>
            <xs:element name="ip-address" type="xs:string" minOccurs="0"/>
            <xs:element name="user-agent" type="xs:string" minOccurs="0"/>
            <xs:element name="referer" type="xs:string" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="RequestType">
        <xs:sequence>
            <xs:element name="endpoint" type="xs:string" minOccurs="0"/>
            <xs:element name="method" type="xs:string" minOccurs="0"/>
            <xs:element name="headers" type="log:HeadersType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="HeadersType">
        <xs:sequence>
            <xs:element name="header" type="log:HeaderType" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="HeaderType">
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
    </xs:complexType>
    
    <xs:complexType name="MetadataType">
        <xs:sequence>
            <xs:element name="custom-field" type="log:CustomFieldType" maxOccurs="unbounded" minOccurs="0"/>
            <xs:element name="tags" type="log:TagsType" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="CustomFieldType">
        <xs:attribute name="name" type="xs:string" use="required"/>
        <xs:attribute name="value" type="xs:string" use="required"/>
    </xs:complexType>
    
    <xs:complexType name="TagsType">
        <xs:sequence>
            <xs:element name="tag" type="xs:string" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>`;
    }
}

/**
 * XML Structure Builder for creating hierarchical XML elements
 */
class XMLStructureBuilder {
    constructor(config) {
        this.config = config;
        this.parser = new DOMParser();
    }
    
    build(data) {
        const doc = this.parser.parseFromString('<log-entry></log-entry>', 'text/xml');
        const rootElement = doc.documentElement;
        
        // Add attributes
        this._addAttributes(rootElement, data);
        
        // Add elements based on field grouping
        this._addElements(rootElement, data, doc);
        
        return rootElement;
    }
    
    _addAttributes(element, data) {
        for (const field of this.config.attributeFields) {
            if (data.hasOwnProperty(field)) {
                element.setAttribute(field, String(data[field]));
            }
        }
    }
    
    _addElements(parentElement, data, doc) {
        // Add grouped elements
        if (this.config.enableFieldGrouping) {
            this._addGroupedElements(parentElement, data, doc);
        }
        
        // Add remaining elements
        this._addRemainingElements(parentElement, data, doc);
    }
    
    _addGroupedElements(parentElement, data, doc) {
        for (const [groupName, fields] of Object.entries(this.config.fieldGroups)) {
            const groupData = {};
            let hasGroupData = false;
            
            for (const field of fields) {
                if (data.hasOwnProperty(field)) {
                    groupData[field] = data[field];
                    hasGroupData = true;
                }
            }
            
            if (hasGroupData) {
                const groupElement = doc.createElement(groupName);
                this._addElementData(groupElement, groupData, doc);
                parentElement.appendChild(groupElement);
            }
        }
    }
    
    _addRemainingElements(parentElement, data, doc) {
        const groupedFields = Object.values(this.config.fieldGroups).flat();
        const excludedFields = [...this.config.attributeFields, ...groupedFields];
        
        for (const [key, value] of Object.entries(data)) {
            if (!excludedFields.includes(key)) {
                this._addElementData(parentElement, { [key]: value }, doc);
            }
        }
    }
    
    _addElementData(parentElement, data, doc) {
        for (const [key, value] of Object.entries(data)) {
            const element = doc.createElement(this._normalizeElementName(key));
            
            if (typeof value === 'object' && value !== null) {
                if (Array.isArray(value)) {
                    this._addArrayData(element, value, doc);
                } else {
                    this._addObjectData(element, value, doc);
                }
            } else {
                this._addTextData(element, value, key);
            }
            
            parentElement.appendChild(element);
        }
    }
    
    _addArrayData(element, array, doc) {
        for (const item of array) {
            const itemElement = doc.createElement('item');
            
            if (typeof item === 'object' && item !== null) {
                this._addObjectData(itemElement, item, doc);
            } else {
                this._addTextData(itemElement, item);
            }
            
            element.appendChild(itemElement);
        }
    }
    
    _addObjectData(element, obj, doc) {
        for (const [key, value] of Object.entries(obj)) {
            this._addElementData(element, { [key]: value }, doc);
        }
    }
    
    _addTextData(element, value, fieldName = '') {
        const textValue = String(value);
        
        if (this.config.enableCDATA && this.config.cdataFields.includes(fieldName)) {
            const cdataSection = element.ownerDocument.createCDATASection(textValue);
            element.appendChild(cdataSection);
        } else {
            const textNode = element.ownerDocument.createTextNode(textValue);
            element.appendChild(textNode);
        }
    }
    
    _normalizeElementName(name) {
        return name.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
    }
}

/**
 * Namespace Manager for XML namespace handling
 */
class NamespaceManager {
    constructor(config) {
        this.config = config;
    }
    
    apply(xmlElement) {
        if (!this.config.enableNamespaces) {
            return xmlElement;
        }
        
        // Add namespace declaration
        xmlElement.setAttribute('xmlns', this.config.rootNamespace);
        
        if (this.config.schemaLocation) {
            xmlElement.setAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
            xmlElement.setAttribute('xsi:schemaLocation', 
                `${this.config.rootNamespace} ${this.config.schemaLocation}`);
        }
        
        return xmlElement;
    }
}

/**
 * XML Data Transformer for preprocessing log data
 */
class XMLDataTransformer {
    constructor(config) {
        this.config = config;
    }
    
    transform(data) {
        let transformed = { ...data };
        
        // Apply data sanitization
        if (this.config.enableDataSanitization) {
            transformed = this._sanitizeData(transformed);
        }
        
        // Apply field validation
        if (this.config.enableFieldValidation) {
            transformed = this._validateFields(transformed);
        }
        
        return transformed;
    }
    
    _sanitizeData(data) {
        const sanitized = {};
        
        for (const [key, value] of Object.entries(data)) {
            if (typeof value === 'string') {
                // Remove XML-unsafe characters
                sanitized[key] = value.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
            } else {
                sanitized[key] = value;
            }
        }
        
        return sanitized;
    }
    
    _validateFields(data) {
        const validated = {};
        
        for (const [key, value] of Object.entries(data)) {
            const validator = this.config.fieldValidators[key];
            
            if (validator && typeof validator === 'function') {
                try {
                    validated[key] = validator(value);
                } catch (error) {
                    console.warn(`Field validation failed for '${key}':`, error.message);
                    validated[key] = value; // Keep original value on validation failure
                }
            } else {
                validated[key] = value;
            }
        }
        
        return validated;
    }
}

/**
 * XML Performance Optimizer for caching and optimization
 */
class XMLPerformanceOptimizer {
    constructor(config) {
        this.config = config;
        this.cache = new Map();
    }
    
    optimize(data) {
        // XML-specific optimization logic would go here
        return data;
    }
}

module.exports = {
    XMLLogger,
    XMLSchemaValidator,
    XMLStructureBuilder,
    NamespaceManager,
    XMLDataTransformer,
    XMLPerformanceOptimizer
};
```

### Usage Examples

#### Basic XML Logging
```javascript
const { XMLLogger } = require('./XMLLogger');

const logger = new XMLLogger({
    applicationName: 'order-service',
    applicationVersion: '1.5.0',
    environment: 'production',
    enableNamespaces: true,
    enableSchemaValidation: false,
    prettyPrint: true
});

// Simple XML logging
logger.info('Order processed successfully', {
    'order-id': 'ord_12345',
    'customer-id': 'cust_67890',
    amount: 199.99,
    currency: 'USD',
    'payment-method': 'credit-card',
    'processing-time': 1250,
    metadata: {
        'business-unit': 'retail',
        'promotion-code': 'SPRING2024',
        tags: ['ecommerce', 'payment', 'retail']
    }
});

// Output:
// <?xml version="1.0" encoding="UTF-8"?>
// <log-entry xmlns="http://logging.schema/v1" timestamp="2024-01-15T10:30:45.123Z" level="INFO" logger="order-service">
//   <application name="order-service" version="1.5.0" environment="production"/>
//   <host name="order-server-01" pid="12345" thread="main"/>
//   <message>Order processed successfully</message>
//   <order-id>ord_12345</order-id>
//   <customer-id>cust_67890</customer-id>
//   <amount>199.99</amount>
//   <currency>USD</currency>
//   <payment-method>credit-card</payment-method>
//   <processing-time>1250</processing-time>
//   <metadata>
//     <business-unit>retail</business-unit>
//     <promotion-code>SPRING2024</promotion-code>
//     <tags>
//       <item>ecommerce</item>
//       <item>payment</item>
//       <item>retail</item>
//     </tags>
//   </metadata>
// </log-entry>
```

#### Complex Hierarchical Structure
```javascript
// Advanced hierarchical logging with field grouping
const enterpriseLogger = new XMLLogger({
    enableFieldGrouping: true,
    fieldGroups: {
        'correlation': ['request-id', 'session-id', 'user-id', 'trace-id'],
        'performance': ['duration', 'memory-usage', 'cpu-usage'],
        'network': ['ip-address', 'user-agent', 'referer'],
        'security': ['auth-method', 'permissions', 'access-level']
    },
    enableCDATA: true,
    cdataFields: ['user-agent', 'error-message', 'stack-trace']
});

enterpriseLogger.error('Database connection failed', {
    'request-id': 'req_abc123',
    'session-id': 'sess_xyz789',
    'user-id': 'user_456',
    'trace-id': 'trace_def456',
    'duration': 5000,
    'memory-usage': 512.5,
    'cpu-usage': 85.2,
    'ip-address': '192.168.1.100',
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'database': 'user_profiles',
    'connection-pool': 'primary',
    'error-code': 'CONN_TIMEOUT',
    'retry-count': 3,
    'error-message': 'Connection timeout after 5000ms',
    'stack-trace': 'Error: Connection timeout\n    at Database.connect(db.js:45)\n    at...'
});

// Output with grouped structure:
// <log-entry>
//   <correlation>
//     <request-id>req_abc123</request-id>
//     <session-id>sess_xyz789</session-id>
//     <user-id>user_456</user-id>
//     <trace-id>trace_def456</trace-id>
//   </correlation>
//   <performance>
//     <duration unit="ms">5000</duration>
//     <memory-usage unit="mb">512.5</memory-usage>
//     <cpu-usage unit="percent">85.2</cpu-usage>
//   </performance>
//   <network>
//     <ip-address>192.168.1.100</ip-address>
//     <user-agent><![CDATA[Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36]]></user-agent>
//   </network>
//   <!-- Additional elements -->
// </log-entry>
```

#### XML Schema Generation
```javascript
// Generate XSD schema for validation
const schema = logger.generateSchema();
console.log('Generated XSD Schema:');
console.log(schema);

// Save schema to file for external validation
const fs = require('fs');
fs.writeFileSync('./schemas/log-schema.xsd', schema);
```

## XML Format Best Practices

### ✅ **DO: XML Format Best Practices**
- **Use proper namespaces**: Prevent naming conflicts with XML namespaces
- **Validate with XSD schemas**: Ensure data integrity through formal validation
- **Use CDATA for complex content**: Safely handle special characters and markup
- **Structure hierarchically**: Organize related data in logical element groups
- **Include type information**: Use attributes to specify data types and units

### ❌ **DON'T: XML Format Anti-patterns**
- **Create overly deep nesting**: Limit nesting depth for better performance
- **Mix content models**: Don't combine attributes and text content inconsistently
- **Ignore character encoding**: Always specify UTF-8 encoding
- **Use invalid element names**: Follow XML naming conventions for elements
- **Skip schema validation**: Missing validation can lead to data integrity issues

### 📋 **XML vs JSON Comparison**

| Aspect | XML | JSON |
|--------|-----|------|
| **Schema Validation** | Strong (XSD) | Weak (JSON Schema) |
| **Hierarchical Structure** | Excellent | Good |
| **Metadata Support** | Rich (attributes, namespaces) | Limited |
| **Performance** | Slower parsing | Faster parsing |
| **Size** | Larger | Smaller |
| **Tool Support** | Mature enterprise tools | Modern web tools |
| **Human Readability** | Good (with formatting) | Excellent |
| **Type System** | Strong typing | Limited typing |

XML format provides enterprise-grade structured logging with formal validation, rich metadata support, and excellent hierarchical organization capabilities! 📋
