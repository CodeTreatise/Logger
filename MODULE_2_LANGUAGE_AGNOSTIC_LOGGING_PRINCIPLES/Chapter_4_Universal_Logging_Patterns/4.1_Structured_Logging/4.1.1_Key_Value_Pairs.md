# 4.1.1 Key-Value Pairs

## Overview

Key-value pairs form the foundation of structured logging, providing a consistent and parseable format for log data that enables automated processing, efficient searching, and meaningful analysis. Unlike traditional unstructured logging where information is embedded within free-form text, key-value pair logging separates data into discrete, labeled fields that can be independently processed and analyzed. This approach transforms logs from human-readable narratives into machine-processable datasets while maintaining human readability and operational utility.

## Understanding Key-Value Pair Logging

### Fundamental Concepts
- **Key**: A descriptive label identifying the type or purpose of the data
- **Value**: The actual data content associated with the key
- **Delimiter**: Characters separating key-value pairs and keys from values
- **Escaping**: Handling special characters within keys or values
- **Type Preservation**: Maintaining data type information through serialization

### Benefits of Key-Value Structure
- **Machine Parsability**: Automated log processing and analysis
- **Search Efficiency**: Direct field-based querying and filtering
- **Consistency**: Standardized field names across different log sources
- **Extensibility**: Easy addition of new fields without breaking existing parsers
- **Type Safety**: Explicit data types enable proper analysis and aggregation

### Common Patterns and Conventions
- **Hierarchical Keys**: Using dots or underscores for nested data (e.g., `user.id`, `request_headers`)
- **Naming Conventions**: snake_case, camelCase, or kebab-case consistency
- **Reserved Keys**: Standard fields like timestamp, level, message, logger
- **Custom Fields**: Application-specific data points and metrics

## Advanced Key-Value Pair Management System

### Comprehensive Structured Logger

```javascript
const winston = require('winston');
const { DateTime } = require('luxon');

/**
 * Advanced Key-Value Pair Management System
 * Provides structured logging with intelligent key-value handling,
 * type preservation, validation, and automated formatting
 */
class StructuredLogger {
    constructor(options = {}) {
        this.config = {
            // Key-value configuration
            keyDelimiter: options.keyDelimiter || '=',
            pairDelimiter: options.pairDelimiter || ' ',
            keyValueSeparator: options.keyValueSeparator || '=',
            enableTypePreservation: options.enableTypePreservation !== false,
            enableKeyValidation: options.enableKeyValidation !== false,
            enableValueEscaping: options.enableValueEscaping !== false,
            
            // Naming conventions
            keyNamingStyle: options.keyNamingStyle || 'snake_case', // snake_case, camelCase, kebab-case
            enableKeyNormalization: options.enableKeyNormalization !== false,
            forbiddenKeys: options.forbiddenKeys || ['password', 'secret', 'token', 'key'],
            requiredKeys: options.requiredKeys || ['timestamp', 'level', 'message'],
            
            // Value handling
            maxValueLength: options.maxValueLength || 1000,
            enableValueTruncation: options.enableValueTruncation !== false,
            truncationSuffix: options.truncationSuffix || '...',
            enableObjectFlattening: options.enableObjectFlattening !== false,
            flatteningSeparator: options.flatteningSeparator || '.',
            
            // Type preservation
            stringQuoteChar: options.stringQuoteChar || '"',
            enableNumericTypes: options.enableNumericTypes !== false,
            enableBooleanTypes: options.enableBooleanTypes !== false,
            enableDateTimeTypes: options.enableDateTimeTypes !== false,
            enableArrayTypes: options.enableArrayTypes !== false,
            
            // Formatting options
            sortKeys: options.sortKeys || false,
            prettyPrint: options.prettyPrint || false,
            enableColorCoding: options.enableColorCoding || false,
            enableFieldAlignment: options.enableFieldAlignment || false,
            
            // Performance options
            enableCaching: options.enableCaching !== false,
            cacheTTL: options.cacheTTL || 300000, // 5 minutes
            maxCacheSize: options.maxCacheSize || 1000,
            enableAsyncProcessing: options.enableAsyncProcessing || false,
            
            // Application metadata
            applicationName: options.applicationName || 'unknown',
            serviceVersion: options.serviceVersion || '1.0.0',
            environment: options.environment || 'development'
        };
        
        this.keyValidator = new KeyValidator(this.config);
        this.valueProcessor = new ValueProcessor(this.config);
        this.typeManager = new TypeManager(this.config);
        this.formatter = new StructuredFormatter(this.config);
        this.fieldCache = new Map();
        this.metrics = this._initializeMetrics();
        
        // Initialize Winston logger
        this.logger = this._createWinstonLogger();
    }
    
    /**
     * Log a message with structured key-value pairs
     */
    log(level, message, kvPairs = {}, options = {}) {
        const startTime = Date.now();
        
        try {
            // Validate and normalize input
            const validatedPairs = this._validateKeyValuePairs(kvPairs);
            const processedPairs = this._processValues(validatedPairs);
            const typedPairs = this._preserveTypes(processedPairs);
            
            // Create structured log entry
            const structuredEntry = {
                timestamp: DateTime.now().toISO(),
                level: level.toUpperCase(),
                message: this._processMessage(message),
                application: this.config.applicationName,
                version: this.config.serviceVersion,
                environment: this.config.environment,
                ...typedPairs
            };
            
            // Apply formatting
            const formattedEntry = this.formatter.format(structuredEntry, options);
            
            // Log through Winston
            this.logger.log(level, formattedEntry.message, formattedEntry.metadata);
            
            // Record metrics
            this._recordMetrics(startTime, level, Object.keys(kvPairs).length);
            
            return formattedEntry;
            
        } catch (error) {
            this._handleLoggingError(error, level, message, kvPairs);
            
            // Fallback to simple logging
            this.logger.log(level, `${message} (structured logging failed: ${error.message})`);
        }
    }
    
    /**
     * Convenience methods for different log levels
     */
    info(message, kvPairs = {}, options = {}) {
        return this.log('info', message, kvPairs, options);
    }
    
    warn(message, kvPairs = {}, options = {}) {
        return this.log('warn', message, kvPairs, options);
    }
    
    error(message, kvPairs = {}, options = {}) {
        return this.log('error', message, kvPairs, options);
    }
    
    debug(message, kvPairs = {}, options = {}) {
        return this.log('debug', message, kvPairs, options);
    }
    
    /**
     * Log structured data with automatic key-value extraction
     */
    logStructured(level, data, options = {}) {
        if (typeof data === 'object' && data !== null) {
            const { message, ...kvPairs } = data;
            return this.log(level, message || 'Structured log entry', kvPairs, options);
        } else {
            return this.log(level, String(data), {}, options);
        }
    }
    
    /**
     * Create a child logger with predefined key-value pairs
     */
    child(baseKVPairs = {}) {
        const childLogger = Object.create(this);
        childLogger.baseKVPairs = { ...this.baseKVPairs, ...baseKVPairs };
        
        // Override log method to include base pairs
        const originalLog = this.log.bind(this);
        childLogger.log = (level, message, kvPairs = {}, options = {}) => {
            const mergedPairs = { ...childLogger.baseKVPairs, ...kvPairs };
            return originalLog(level, message, mergedPairs, options);
        };
        
        return childLogger;
    }
    
    /**
     * Validate key-value pairs
     */
    _validateKeyValuePairs(kvPairs) {
        const validatedPairs = {};
        
        for (const [key, value] of Object.entries(kvPairs)) {
            // Validate key
            if (!this.keyValidator.isValidKey(key)) {
                console.warn(`Invalid key '${key}' skipped in structured logging`);
                continue;
            }
            
            // Check forbidden keys
            if (this.config.forbiddenKeys.includes(key.toLowerCase())) {
                console.warn(`Forbidden key '${key}' skipped in structured logging`);
                continue;
            }
            
            // Normalize key name
            const normalizedKey = this.keyValidator.normalizeKey(key);
            validatedPairs[normalizedKey] = value;
        }
        
        // Check required keys
        for (const requiredKey of this.config.requiredKeys) {
            if (!validatedPairs.hasOwnProperty(requiredKey) && !['timestamp', 'level', 'message'].includes(requiredKey)) {
                console.warn(`Required key '${requiredKey}' missing in structured logging`);
            }
        }
        
        return validatedPairs;
    }
    
    /**
     * Process and sanitize values
     */
    _processValues(kvPairs) {
        const processedPairs = {};
        
        for (const [key, value] of Object.entries(kvPairs)) {
            processedPairs[key] = this.valueProcessor.processValue(value, key);
        }
        
        return processedPairs;
    }
    
    /**
     * Preserve type information
     */
    _preserveTypes(kvPairs) {
        const typedPairs = {};
        
        for (const [key, value] of Object.entries(kvPairs)) {
            typedPairs[key] = this.typeManager.preserveType(value);
        }
        
        return typedPairs;
    }
    
    /**
     * Process log message
     */
    _processMessage(message) {
        if (typeof message !== 'string') {
            return String(message);
        }
        
        // Truncate if necessary
        if (this.config.enableValueTruncation && message.length > this.config.maxValueLength) {
            return message.substring(0, this.config.maxValueLength - this.config.truncationSuffix.length) + 
                   this.config.truncationSuffix;
        }
        
        return message;
    }
    
    /**
     * Create Winston logger instance
     */
    _createWinstonLogger() {
        return winston.createLogger({
            level: 'debug',
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.json()
            ),
            transports: [
                new winston.transports.Console({
                    format: winston.format.combine(
                        winston.format.colorize(),
                        winston.format.timestamp(),
                        winston.format.printf(({ timestamp, level, message, ...meta }) => {
                            const kvString = Object.entries(meta)
                                .map(([k, v]) => `${k}=${JSON.stringify(v)}`)
                                .join(' ');
                            return `${timestamp} [${level}]: ${message} ${kvString}`;
                        })
                    )
                }),
                new winston.transports.File({
                    filename: 'logs/structured.log',
                    format: winston.format.combine(
                        winston.format.timestamp(),
                        winston.format.json()
                    )
                })
            ]
        });
    }
    
    /**
     * Record performance metrics
     */
    _recordMetrics(startTime, level, pairCount) {
        this.metrics.totalLogs++;
        this.metrics.processingTime += Date.now() - startTime;
        this.metrics.levelCounts[level] = (this.metrics.levelCounts[level] || 0) + 1;
        this.metrics.totalKeyValuePairs += pairCount;
        
        const avgProcessingTime = this.metrics.processingTime / this.metrics.totalLogs;
        if (avgProcessingTime > 10) { // 10ms threshold
            this.metrics.slowLogs++;
        }
    }
    
    /**
     * Handle logging errors
     */
    _handleLoggingError(error, level, message, kvPairs) {
        this.metrics.errors++;
        
        console.error('Structured logging error:', {
            error: error.message,
            level,
            message,
            keyCount: Object.keys(kvPairs).length,
            timestamp: new Date().toISOString()
        });
    }
    
    /**
     * Initialize metrics tracking
     */
    _initializeMetrics() {
        return {
            totalLogs: 0,
            processingTime: 0,
            slowLogs: 0,
            errors: 0,
            totalKeyValuePairs: 0,
            levelCounts: {},
            startTime: Date.now()
        };
    }
    
    /**
     * Get logging statistics
     */
    getStatistics() {
        const avgProcessingTime = this.metrics.totalLogs > 0 ?
            this.metrics.processingTime / this.metrics.totalLogs : 0;
        
        const avgKeyValuePairs = this.metrics.totalLogs > 0 ?
            this.metrics.totalKeyValuePairs / this.metrics.totalLogs : 0;
        
        return {
            totalLogs: this.metrics.totalLogs,
            averageProcessingTime: `${avgProcessingTime.toFixed(2)}ms`,
            averageKeyValuePairs: avgKeyValuePairs.toFixed(2),
            slowLogs: this.metrics.slowLogs,
            errors: this.metrics.errors,
            levelDistribution: this.metrics.levelCounts,
            uptime: `${Math.round((Date.now() - this.metrics.startTime) / 1000)}s`
        };
    }
}

/**
 * Key Validator for validating and normalizing keys
 */
class KeyValidator {
    constructor(config) {
        this.config = config;
        this.keyPattern = /^[a-zA-Z][a-zA-Z0-9_.-]*$/;
    }
    
    isValidKey(key) {
        if (typeof key !== 'string' || key.length === 0) {
            return false;
        }
        
        if (!this.keyPattern.test(key)) {
            return false;
        }
        
        return true;
    }
    
    normalizeKey(key) {
        if (!this.config.enableKeyNormalization) {
            return key;
        }
        
        switch (this.config.keyNamingStyle) {
            case 'snake_case':
                return key
                    .replace(/([A-Z])/g, '_$1')
                    .toLowerCase()
                    .replace(/[-\s]+/g, '_')
                    .replace(/^_/, '');
            
            case 'camelCase':
                return key
                    .replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
                    .replace(/^[A-Z]/, c => c.toLowerCase());
            
            case 'kebab-case':
                return key
                    .replace(/([A-Z])/g, '-$1')
                    .toLowerCase()
                    .replace(/[_\s]+/g, '-')
                    .replace(/^-/, '');
            
            default:
                return key;
        }
    }
}

/**
 * Value Processor for handling different value types
 */
class ValueProcessor {
    constructor(config) {
        this.config = config;
    }
    
    processValue(value, key) {
        // Handle null and undefined
        if (value === null || value === undefined) {
            return value;
        }
        
        // Handle objects (flatten if configured)
        if (typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {
            if (this.config.enableObjectFlattening) {
                return this._flattenObject(value);
            } else {
                return JSON.stringify(value);
            }
        }
        
        // Handle arrays
        if (Array.isArray(value)) {
            if (this.config.enableArrayTypes) {
                return value.map(item => this.processValue(item, key));
            } else {
                return JSON.stringify(value);
            }
        }
        
        // Handle strings (truncate if necessary)
        if (typeof value === 'string') {
            if (this.config.enableValueTruncation && value.length > this.config.maxValueLength) {
                return value.substring(0, this.config.maxValueLength - this.config.truncationSuffix.length) + 
                       this.config.truncationSuffix;
            }
            
            // Escape special characters
            if (this.config.enableValueEscaping) {
                return this._escapeValue(value);
            }
        }
        
        return value;
    }
    
    _flattenObject(obj, prefix = '') {
        const flattened = {};
        
        for (const [key, value] of Object.entries(obj)) {
            const newKey = prefix ? `${prefix}${this.config.flatteningSeparator}${key}` : key;
            
            if (typeof value === 'object' && value !== null && !Array.isArray(value) && !(value instanceof Date)) {
                Object.assign(flattened, this._flattenObject(value, newKey));
            } else {
                flattened[newKey] = this.processValue(value, newKey);
            }
        }
        
        return flattened;
    }
    
    _escapeValue(value) {
        return value
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
    }
}

/**
 * Type Manager for preserving type information
 */
class TypeManager {
    constructor(config) {
        this.config = config;
    }
    
    preserveType(value) {
        if (!this.config.enableTypePreservation) {
            return value;
        }
        
        // Number types
        if (typeof value === 'number' && this.config.enableNumericTypes) {
            return value; // Keep as number
        }
        
        // Boolean types
        if (typeof value === 'boolean' && this.config.enableBooleanTypes) {
            return value; // Keep as boolean
        }
        
        // Date types
        if (value instanceof Date && this.config.enableDateTimeTypes) {
            return value.toISOString(); // Convert to ISO string but preserve as date type
        }
        
        // String types
        if (typeof value === 'string') {
            return value; // Keep as string
        }
        
        // Other types - convert to string
        return String(value);
    }
}

/**
 * Structured Formatter for output formatting
 */
class StructuredFormatter {
    constructor(config) {
        this.config = config;
    }
    
    format(entry, options = {}) {
        const formatOptions = { ...this.config, ...options };
        
        // Separate message from metadata
        const { message, ...metadata } = entry;
        
        // Sort keys if requested
        const sortedMetadata = formatOptions.sortKeys ?
            this._sortKeys(metadata) : metadata;
        
        // Format based on output style
        if (formatOptions.prettyPrint) {
            return this._formatPretty(message, sortedMetadata);
        } else {
            return this._formatCompact(message, sortedMetadata);
        }
    }
    
    _formatCompact(message, metadata) {
        const kvString = Object.entries(metadata)
            .map(([key, value]) => {
                const formattedValue = this._formatValue(value);
                return `${key}${this.config.keyValueSeparator}${formattedValue}`;
            })
            .join(this.config.pairDelimiter);
        
        return {
            message: `${message} ${kvString}`,
            metadata
        };
    }
    
    _formatPretty(message, metadata) {
        const maxKeyLength = Math.max(...Object.keys(metadata).map(k => k.length));
        
        const kvLines = Object.entries(metadata)
            .map(([key, value]) => {
                const paddedKey = this.config.enableFieldAlignment ?
                    key.padEnd(maxKeyLength) : key;
                const formattedValue = this._formatValue(value);
                return `  ${paddedKey}${this.config.keyValueSeparator} ${formattedValue}`;
            })
            .join('\n');
        
        return {
            message: `${message}\n${kvLines}`,
            metadata
        };
    }
    
    _formatValue(value) {
        if (typeof value === 'string') {
            return `${this.config.stringQuoteChar}${value}${this.config.stringQuoteChar}`;
        }
        
        if (value === null || value === undefined) {
            return 'null';
        }
        
        return String(value);
    }
    
    _sortKeys(obj) {
        const sorted = {};
        const keys = Object.keys(obj).sort();
        
        for (const key of keys) {
            sorted[key] = obj[key];
        }
        
        return sorted;
    }
}

module.exports = {
    StructuredLogger,
    KeyValidator,
    ValueProcessor,
    TypeManager,
    StructuredFormatter
};
```

### Usage Examples

#### Basic Key-Value Logging
```javascript
const { StructuredLogger } = require('./StructuredLogger');

const logger = new StructuredLogger({
    keyNamingStyle: 'snake_case',
    enableTypePreservation: true,
    enableObjectFlattening: true
});

// Simple key-value logging
logger.info('User login successful', {
    user_id: 12345,
    username: 'john_doe',
    login_time: new Date(),
    session_duration: 3600,
    is_admin: false,
    ip_address: '192.168.1.100'
});

// Output: 2024-01-15T10:30:45.123Z [INFO]: User login successful user_id=12345 username="john_doe" login_time="2024-01-15T10:30:45.123Z" session_duration=3600 is_admin=false ip_address="192.168.1.100"
```

#### Complex Object Flattening
```javascript
// Object flattening example
logger.warn('API rate limit approaching', {
    endpoint: '/api/users',
    rate_limit: {
        max_requests: 1000,
        current_requests: 950,
        window_seconds: 3600,
        reset_time: new Date(Date.now() + 3600000)
    },
    client: {
        id: 'client_123',
        tier: 'premium',
        country: 'US'
    }
});

// Output with flattening:
// rate_limit.max_requests=1000 rate_limit.current_requests=950 rate_limit.window_seconds=3600 client.id="client_123" client.tier="premium" client.country="US"
```

#### Child Logger with Base Pairs
```javascript
// Create child logger with base context
const requestLogger = logger.child({
    request_id: 'req_abc123',
    user_id: 456,
    endpoint: '/api/orders'
});

// All logs from this child logger include base pairs
requestLogger.info('Processing order', {
    order_id: 'ord_789',
    amount: 99.99,
    currency: 'USD'
});

// Output includes both base and specific pairs:
// request_id="req_abc123" user_id=456 endpoint="/api/orders" order_id="ord_789" amount=99.99 currency="USD"
```

## Key-Value Pair Best Practices

### ‚úÖ **DO: Key-Value Best Practices**
- **Use descriptive keys**: Choose clear, meaningful key names
- **Maintain consistency**: Use consistent naming conventions across all logs
- **Preserve types**: Keep numeric, boolean, and date types when possible
- **Validate input**: Ensure keys are valid and values are properly formatted
- **Handle special characters**: Properly escape values containing delimiters

### ‚ùå **DON'T: Key-Value Anti-patterns**
- **Use spaces in keys**: Avoid spaces or special characters in key names
- **Mix naming styles**: Don't combine camelCase, snake_case, and kebab-case
- **Log sensitive data**: Never include passwords, tokens, or secrets as values
- **Create overly long keys**: Keep key names concise but descriptive
- **Ignore type information**: Don't convert everything to strings unnecessarily

### üîë **Key Naming Conventions**

#### **Snake Case (Recommended)**
```javascript
{
    user_id: 12345,
    login_time: '2024-01-15T10:30:45Z',
    is_authenticated: true,
    session_timeout: 3600
}
```

#### **Camel Case**
```javascript
{
    userId: 12345,
    loginTime: '2024-01-15T10:30:45Z',
    isAuthenticated: true,
    sessionTimeout: 3600
}
```

#### **Hierarchical Keys**
```javascript
{
    user.id: 12345,
    user.profile.name: 'John Doe',
    request.headers.user_agent: 'Mozilla/5.0...',
    response.status.code: 200
}
```

Key-value pairs provide the essential structure for modern logging systems, enabling both human readability and automated processing capabilities! üîë
